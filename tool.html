<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSVLink</title>
<script src="https://app.lemonsqueezy.com/js/lemon.js" defer></script>
<!-- Fabric.js -->
<script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
<!-- SheetJS -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<!-- JSZip & FileSaver -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
<!-- jsPDF -->
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<style>
  :root{
    --bg:#111; --fg:#fff; --muted:#888; --panel:#1a1a1a; --panel-2:#222;
    --border:#333; --accent:#fff;
  }
  *{ box-sizing: border-box; }
  .app{ display:grid; grid-template-rows:auto 1fr auto; flex-grow: 1; min-height: 0; }
  header{ display:flex; gap:16px; align-items:center; padding:12px 16px; background:var(--panel); border-bottom:1px solid var(--border); flex-wrap:wrap; }
  .title{ font-weight:700; font-size:16px; margin-right: auto; }
  input[type="text"], input[type="search"], input[type="number"], input[type="password"], select, textarea {
    background:var(--panel-2); color:var(--fg); border:1px solid var(--border);
    padding:8px 10px; border-radius:8px; outline:none; transition: border-color .2s;
    width: 100%; font-family: inherit;
  }
html {
    height: 100%;
    background: var(--bg);
}
body {
    height: 100%;
    margin: 0;
    color: var(--fg);
    font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
nav {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    background: var(--panel);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
}
nav .logo {
    font-weight: 700;
    font-size: 16px;
    color: var(--fg);
    text-decoration: none;
}
nav .nav-links {
    display: flex;
    gap: 16px;
    align-items: center;
}
nav .nav-links a {
    text-decoration: none;
    color: var(--muted);
    font-weight: 500;
    transition: color .2s;
    font-size: 14px;
}
nav .nav-links a:hover {
    color: var(--fg);
}
nav .nav-links .btn {
    background: var(--accent);
    color: var(--bg);
    padding: 8px 14px;
    font-size: 14px;
    border-radius: 8px;
}
nav .nav-links .btn:hover {
    background: #ccc;
}
  textarea { resize: vertical; }
  input[type="text"]:focus, input[type="number"]:focus, input[type="password"]:focus, select:focus, textarea:focus { border-color: #555; }
  .btn{ background:var(--accent); color: var(--bg); border:none; padding:9px 16px; border-radius:8px; cursor:pointer; font-weight:600; display:inline-flex; align-items:center; justify-content:center; gap: 8px; transition: background .2s; }
  .btn:hover{ background: #ccc; }
  .btn:disabled{ opacity:.4; cursor:not-allowed; }
  .btn.ghost{ background:transparent; color:var(--fg); border:1px solid var(--border); }
  .btn.ghost:hover{ background: var(--panel-2); }
  .toolbar{ display:flex; gap:12px; align-items:center; }
  .main{ display:grid; grid-template-columns: 260px 1fr 320px; gap:12px; padding:12px; min-height:0; }
  .panel{ background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px; min-height:0; display:flex; flex-direction:column; position:relative; }

  /* Canvas and Page Styling */
  .canvas-container-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    border-radius: 12px;
  }
  .canvas-wrap{
    position: absolute;
    inset: 0;
    overflow: hidden;
    background-color: #2a2a2a;
    background-image: radial-gradient(#444 1px, transparent 0);
    background-size: 16px 16px;
    cursor: grab;
  }
  .canvas-wrap:active { cursor: grabbing; }

  .right{ gap:12px; }
  .stack{ display:grid; gap:8px; }
  .row{ display:flex; gap:8px; align-items:center; }
  h3{ margin:0 0 8px; font-size:13px; color:#ddd; text-transform:uppercase; letter-spacing:.1em; }
  label{ font-size:12px; color:var(--muted); }

  /* Custom Scrollbar Styling */
  #inspectorWrap, .left-panel-content, #components-content, #elements-content, #layers-content {
    overflow-y: auto;
    overflow-x: hidden;
    flex: 1;
    min-height: 0;
    padding-right: 8px;
  }
  ::-webkit-scrollbar { width: 8px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 4px; }
  ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.3); }

  #inspector, #multiSelectInspector{ display:grid; gap:16px; }
  .inspector-panel {
  display: grid;
  gap: 16px;
  align-content: start;
}
  #noSelection {
  border: 1px dashed var(--border);
  border-radius: 12px;
  padding: 24px;
  text-align: center;
}
#noSelection h4 {
  margin: 0 0 12px;
  font-size: 14px;
}
  footer{ display:flex; justify-content:space-between; align-items:center; padding:12px 16px; background:var(--panel); border-top:1px solid var(--border); }
  .toolbar-group { display: flex; align-items: center; gap: 8px; padding: 4px 8px; border: 1px solid var(--border); border-radius: 8px; background: var(--panel-2); }

  /* Components Grid */
  .components-grid { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .shape-chip { background: var(--panel-2); border:1px solid var(--border); border-radius: 8px; padding: 12px; cursor:grab; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:8px; transition: border-color .2s; user-select:none; }
  .shape-chip:hover { border-color:#555; }
  .shape-chip svg { width: 32px; height: 32px; stroke: #fff; stroke-width: 1.5px; fill: transparent; }
  .shape-chip span { font-size: 12px; color: var(--muted); }

  /* Modal */
  .modal-backdrop{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.6); z-index:50; }
  .modal{ width:720px; max-width:95vw; background:var(--panel); border:1px solid var(--border); border-radius:16px; padding:16px; display:flex; flex-direction:column; max-height:80vh; overflow: scroll;}
  .col-list{ max-height:46vh; overflow:auto; display:grid; gap:8px; margin-top:8px; }
  .col-item{ border:1px solid var(--border); border-radius:12px; padding:8px; cursor:pointer; }
  .col-item[aria-selected="true"]{ border-color:#444; background:#121212; }

  .toolbar-group .btn.active { background: var(--accent); color: var(--bg); }
  .color-picker-wrapper { display: flex; align-items: center; gap: 8px; background: var(--panel-2); border: 1px solid var(--border); border-radius: 8px; padding-right: 8px; }
  .color-picker-wrapper input[type="text"] { border: none; flex-grow: 1; }
  .color-picker-wrapper input[type="color"] { -webkit-appearance: none; -moz-appearance: none; appearance: none; width: 28px; height: 28px; background-color: transparent; border: none; cursor: pointer; }
  .color-picker-wrapper input[type="color"]::-webkit-color-swatch { border-radius: 6px; border: 1px solid var(--border); }
  .color-picker-wrapper input[type="color"]::-moz-color-swatch { border-radius: 6px; border: 1px solid var(--border); }

  /* === NEW/MODIFIED: Inspector & Layer Styles === */
  .prop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .prop-grid .full-width { grid-column: 1 / -1; }
  .slider-wrapper { display: flex; align-items: center; gap: 8px; }
  .slider-wrapper input[type="range"] { flex-grow: 1; }
  .slider-wrapper input[type="number"] { width: 60px; text-align: right; }
  .action-buttons { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 8px; }
  .align-buttons { display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px; }
  .align-buttons .btn { padding: 8px; }
  #multiSelectInspector .btn-group { display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 16px; }

  .layers-list .layer-item { display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 6px; border: 1px solid var(--border); background: var(--panel-2); font-size: 12px; cursor: pointer; }
  .layers-list .layer-item.active { border-color: var(--accent); background: #2a2a2a; }
  .layers-list .layer-item span { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .layers-list .layer-item .layer-actions { display: flex; gap: 4px; }
  .layers-list .layer-item .layer-actions button { padding: 4px; line-height: 0; }
  .layers-list .layer-item[data-locked="true"] { opacity: 0.6; }

.data-links-object-item {
    padding: 8px 12px;
    border: 1px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    font-size: 13px;
    transition: background .2s, border-color .2s;
    height: 72px;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
}

.data-links-object-item:hover { background: var(--panel-2); }
.data-links-object-item[aria-selected="true"] { background: #2a2a2a; border-color: var(--accent); }
.data-links-object-item .muted { font-size: 11px; }
.bindings-editor-container { display: flex; flex-direction: column; }
#dataLinksEditorContent { display: flex; flex-direction: column; flex-grow: 1; min-height: 0; }
.links-list-wrapper { flex-grow: 1; overflow-y: auto; padding-right: 8px; }
.add-link-button-wrapper { flex-shrink: 0; padding-top: 12px; margin-top: 8px; border-top: 1px solid var(--border); }
.ai-bubble { position: absolute; bottom: 24px; right: 24px; width: 56px; height: 56px; background: var(--accent); color: var(--bg); border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,.3); z-index: 20; transition: transform .2s ease-in-out; }
.ai-bubble:hover { transform: scale(1.1); }
#aiLoadingSpinner { display: inline-flex; align-items: flex-end; gap: 2px; }
#aiLoadingSpinner span { animation: blink 1.2s infinite; font-size: 24px; line-height: 1; }
#aiLoadingSpinner span:nth-child(2) { animation-delay: 0.2s; }
#aiLoadingSpinner span:nth-child(3) { animation-delay: 0.4s; }
@keyframes blink { 0%, 100% { opacity: 0.2; } 50% { opacity: 1; } }
#newKeyDisplay { background: var(--bg); padding: 1rem; border-radius: 8px; border: 1px solid var(--border); font-family: monospace; word-break: break-all; }
.api-key-item { display: flex; justify-content: space-between; align-items: center; background: var(--panel-2); padding: 8px 12px; border-radius: 8px; font-family: monospace; }
body.light-mode { --bg:#f5f5f5; --fg:#111; --muted:#555; --panel:#fff; --panel-2:#f0f0f0; --border:#ddd; --accent:#111; color: white; }
.settings-section { border: 1px solid var(--border); border-radius: 12px; height: fit-content; padding: 16px; }
.settings-section h4 { margin: 0 0 12px; font-size: 14px; text-transform: uppercase; letter-spacing: .05em; color: var(--fg); }
.main { display: grid; grid-template-columns: minmax(200px, 1fr) 5px 6fr 5px minmax(260px, 1.5fr); gap: 0; padding: 12px; min-height: 0; }
.resizer { background: var(--border); cursor: col-resize; z-index: 10; }
.panel-toggle { position: absolute; top: 50%; z-index: 20; width: 28px; height: 28px; padding: 0; border: 1px solid var(--border); background: var(--panel-2); color: var(--fg); cursor: pointer; border-radius: 50%; box-shadow: 0 2px 8px rgba(0,0,0,.2); transform: translateY(-50%); display: flex; align-items: center; justify-content: center; transition: background .2s, transform .2s ease-in-out; }
.panel-toggle:hover { background: var(--panel); transform: translateY(-50%) scale(1.1); }
#left-panel-toggle { left: 100%; margin-left: -14px; }
#right-panel-toggle { right: 100%; margin-right: -14px; }
.panel-toggle svg { width: 18px; height: 18px; }
#start-tour-btn { width: 38px; height: 38px; border-radius: 50%; padding: 0; font-size: 18px; font-weight: bold; }
#tour-modal { position: fixed; z-index: 1001; background: var(--panel); border: 1px solid var(--border); border-radius: 12px; width: 300px; box-shadow: 0 8px 24px rgba(0,0,0,.4); display: none; flex-direction: column; transition: all 0.4s ease-in-out; }
#tour-modal-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid var(--border); cursor: move; }
#tour-modal-header h4 { margin: 0; font-size: 14px; }
#tour-modal-controls button { padding: 4px; line-height: 0; }
#tour-modal-content { padding: 12px; font-size: 13px; line-height: 1.5; }
#tour-modal-content p { margin: 0 0 10px; }
#tour-modal-content ul { margin: 0; padding-left: 18px; }
#tour-modal-nav { display: flex; justify-content: space-between; padding: 12px; margin-top: auto; border-top: 1px solid var(--border); }
#tour-highlight { position: fixed; z-index: 1000; background: rgba(0, 150, 255, 0.15); border: 2px solid #0099ff; border-radius: 8px; box-shadow: 0 0 0 9999px rgba(0,0,0,0.5); pointer-events: none; display: none; transition: all 0.4s ease-in-out; }
  
  /* NEW: Left Panel Tabs - H3 Style */
  .panel-tabs { display: flex; gap: 16px; border-bottom: 1px solid var(--border); margin: 0 -12px 12px -12px; padding: 0 12px;}
  .panel-tab-btn { flex: 0; border: none; background: transparent; padding: 0 0 8px 0; cursor: pointer; margin:0; font-size:12px; color: var(--muted); text-transform:uppercase; letter-spacing:.1em; font-weight: 600; border-bottom: 2px solid transparent; transition: color .2s, border-color .2s; }
  .panel-tab-btn.active { color: var(--fg); border-bottom-color: var(--accent); }
  .panel-tab-btn:hover { color: var(--fg); }
  .panel-tab-content { display: none; flex-direction: column; min-height: 0; flex: 1; }
  .panel-tab-content.active { display: flex; }

  #elements-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(64px, 1fr)); gap: 8px; margin-top: 8px; }
  .element-chip { background: var(--panel-2); border: 1px solid var(--border); border-radius: 8px; padding: 8px; cursor: grab; user-select: none; transition: border-color .2s; }
  .element-chip:hover { border-color: #555; }
  .element-chip img { width: 100%; height: auto; object-fit: contain; }

  #visualCropModal .modal { width: 80vw; height: 85vh; max-width: 1200px; }
  #visualCropContainer { flex-grow: 1; position: relative; background: var(--bg); border-radius: 8px; overflow: hidden; }

</style>
</head>
<body>
<nav>
    <a href="/" class="logo">CSVLink</a>
    <div class="nav-links" id="nav-links"><!-- Auth links will be injected here --></div>
</nav>

<input type="file" id="imageUpload" accept="image/*" style="display:none;" />
<input type="file" id="imageFillUpload" accept="image/*" style="display:none;" />

<div class="app">
  <header>
    <div class="toolbar">
      <input id="titleInput" type="text" placeholder="Untitled_Template" value="Untitled_Template" style="min-width: 200px;"/>
      <div class="row" title="Page Dimensions (W x H)">
            <input id="pageWidth" type="number" value="768" min="100" max="10000" style="width:90px;"/>
            <span class="muted">x</span>
            <input id="pageHeight" type="number" value="1024" min="100" max="10000" style="width:90px;"/>
        </div>
    </div>
      <div class="toolbar-group">
        <button id="undoBtn" class="btn ghost" title="Undo (Ctrl+Z)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3l3 2.7"/></svg></button>
        <button id="redoBtn" class="btn ghost" title="Redo (Ctrl+Y)"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l-3 2.7"/></svg></button>
    </div>
    <div class="toolbar" style="margin-left: auto;">
        <span id="saveStatus" class="muted" style="margin-right: 16px;"></span>
        <button id="start-tour-btn" class="btn ghost" title="Start Tutorial">?</button>
        <label for="csvInput" class="btn ghost">Load Data</label>
        <input id="csvInput" type="file" accept=".csv,.xlsx,.xls" style="display:none;"/>
        <span id="fileName" class="muted" style="max-width: 150px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">No file selected</span>
        <input hidden id="startCell" type="text" placeholder="Starting cell" value="A1" style="width: 100px;"/>
        <button id="settingsBtn" class="btn ghost" title="Settings"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0 2l.15.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg></button>
    </div>
  </header>

  <main class="main" id="main-layout">
    <div class="panel left" id="left-panel">
      <button id="left-panel-toggle" class="panel-toggle" title="Toggle Left Panel"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg></button>
      <div class="left-panel-content">
        <div class="panel-tabs">
            <button id="components-tab-btn" class="panel-tab-btn active" data-target="components-content">Components</button>
            <button id="layers-tab-btn" class="panel-tab-btn" data-target="layers-content">Layers</button>
            <button id="elements-tab-btn" class="panel-tab-btn" data-target="elements-content">Elements</button>
        </div>

        <div id="components-content" class="panel-tab-content active">
            <div class="components-grid">
                <div class="shape-chip" draggable="true" data-add="text"><svg viewBox="0 0 24 24"><path d="M5 4h14M12 4v16M8 20h8" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></svg><span>Text</span></div>
                <div class="shape-chip" draggable="true" data-add="image"><svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><path d="M21 15l-5-5L5 21" fill="none"></path></svg><span>Image</span></div>
                <div class="shape-chip" draggable="true" data-add="square"><svg viewBox="0 0 24 24"><rect x="5" y="5" width="14" height="14" rx="1"></rect></svg><span>Square</span></div>
                <div class="shape-chip" draggable="true" data-add="circle"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"></circle></svg><span>Circle</span></div>
                <div class="shape-chip" draggable="true" data-add="triangle"><svg viewBox="0 0 24 24"><path d="M12 2L2 22h20L12 2z"></path></svg><span>Triangle</span></div>
                <div class="shape-chip" draggable="true" data-add="star"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg><span>Star</span></div>
                <div class="shape-chip" draggable="true" data-add="arrow"><svg viewBox="0 0 24 24"><path d="M5 12h14M12 5l7 7-7 7" fill="none"></path></svg><span>Arrow</span></div>
                <div class="shape-chip" draggable="true" data-add="table"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="3" y1="15" x2="21" y2="15"></line><line x1="9" y1="3" x2="9" y2="21"></line><line x1="15" y1="3" x2="15" y2="21"></line></svg><span>Table</span></div>
                <div class="shape-chip" draggable="true" data-add="line"><svg viewBox="0 0 24 24"> <path d="M4 12h16" fill="none"></path> </svg> <span>Line</span></div>
            </div>
        </div>

        <div id="layers-content" class="panel-tab-content">
            <div id="layersList" class="layers-list stack"></div>
        </div>

        <div id="elements-content" class="panel-tab-content">
            <input type="search" id="element-search" placeholder="Search elements...">
            <div id="elements-grid"></div>
        </div>
      </div>
    </div>
    <div class="resizer" id="left-resizer"></div>

    <div class="canvas-container-wrapper">
      <div class="canvas-wrap"><canvas id="c"></canvas></div>
      <button id="openDataLinksManagerBtn" class="btn" style="position: absolute; top: 16px; right: 16px; z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,.3);"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg><span>Data Links</span></button>
      <div id="ai-bubble" class="ai-bubble" title="AI Template Assistant"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sparkles"><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/><path d="M5 3v4"/><path d="M19 17v4"/><path d="M3 5h4"/><path d="M17 19h4"/></svg></div>
    </div>
       <div class="resizer" id="right-resizer"></div>
    <div class="panel right" id="right-panel">
       <button id="right-panel-toggle" class="panel-toggle" title="Toggle Right Panel"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg></button>
      <div id="inspectorWrap">
        <h3>Inspector</h3>
        <div id="noSelection">
            <h4>Page Properties</h4>
            <div class="stack" id="pageInspector">
                <p class="muted" style="margin:0 0 12px; font-size:13px; text-align:center;">Select an element to edit its properties or modify the page below.</p>
            </div>
            <button id="loadTemplateBtnPage" class="btn ghost" style="width:100%; margin-top:12px;">Load Template</button>
        </div>
        <div id="inspector" style="display:none;"></div>
        <div id="multiSelectInspector" style="display:none;"></div>
      </div>
    </div>
  </main>

  <footer>
      <div class="toolbar-group">
        <button id="exportZipBtn" class="btn">Export as ZIP</button>
        <button id="exportSinglePdfBtn" class="btn">Export Single PDF</button>
        <button id="exportPngBtn" class="btn" style="display: none;">Export as PNG</button>
      </div>
      <div class="toolbar">
          <button id="centerViewBtn" class="btn ghost" title="Reset View"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg></button>
          <div id="zoomLevel" class="muted">Zoom: 100%</div>
      </div>
      <div class="toolbar-group">
        <label for="gridSizeInput" class="muted" style="font-size:12px; margin-left:8px;">Size:</label>
        <input type="number" id="gridSizeInput" min="12" max="64" style="width: 60px; padding: 4px 8px;">
        <button id="toggleGridBtn" class="btn ghost">Toggle Grid</button>
        <button id="toggleSnapBtn" class="btn ghost active">Toggle Snap</button>
      </div>
  </footer>
</div>

<!-- Data Links Manager Modal -->
<div id="dataLinksManagerModal" class="modal-backdrop">
    <div class="modal" style="width: 800px; max-width: 90vw; height: 70vh; max-height: 600px; display: flex; flex-direction: column;">
        <div class="row" style="justify-content:space-between;align-items:center;gap:12px; flex-shrink: 0;">
            <h3>Data Links Manager</h3>
            <button id="closeDataLinksManagerModal" class="btn ghost">Close</button>
        </div>
        <div class="main-content" style="display: grid; grid-template-columns: 250px 1fr; gap: 16px; margin-top: 16px; flex-grow: 1; min-height: 0;">
            <div class="objects-list-container stack" style="border: 1px solid var(--border); border-radius: 12px; padding: 8px; overflow-y: auto;">
                <h4 style="padding: 0 8px;">Canvas Objects</h4>
                <div id="dataLinksObjectsList" class="stack"></div>
            </div>
            <div class="bindings-editor-container" style="border: 1px solid var(--border); border-radius: 12px; padding: 12px; overflow-y: auto;">
                <div id="dataLinksEditorContent" class="stack"><p class="muted" style="text-align:center; padding-top: 24px;">Select an object from the left to manage its data links.</p></div>
            </div>
        </div>
    </div>
</div>

<!-- Column Link Modal -->
<div id="modalBackdrop" class="modal-backdrop">
  <div class="modal">
    <div class="row" style="justify-content:space-between;align-items:center;gap:12px;"><h3>Link to Column</h3><button id="closeModal" class="btn ghost">Close</button></div>
    <div class="row" style="gap:8px; margin-top:8px;"><input id="columnSearch" type="text" placeholder="Search columns..." style="flex:1"/><label class="row" style="gap:8px; align-items:center;"><span class="muted">Start at</span><input id="modalStartCell" type="text" value="A1" style="width:88px;"/></label></div>
    <div id="colList" class="col-list"></div>
    <div class="row" style="margin-top:12px; justify-content:flex-end;"><button id="confirmColumn" class="btn">Use Selected Column</button></div>
  </div>
</div>

<!-- Table Creator Modal -->
<div id="tableCreatorModal" class="modal-backdrop">
    <div class="modal" style="width: 360px;">
        <div class="row" style="justify-content:space-between;align-items:center;gap:12px;"><h3>Create Table</h3><button id="closeTableCreator" class="btn ghost">&times;</button></div>
        <div class="stack" style="margin-top: 16px; gap: 12px;">
            <div class="stack"><label for="tableRows">Rows</label><input type="number" id="tableRows" value="3" min="1" max="100"></div>
            <div class="stack"><label for="tableCols">Columns</label><input type="number" id="tableCols" value="3" min="1" max="100"></div>
        </div>
        <div class="row" style="margin-top: 24px; justify-content:flex-end; gap: 8px;">
            <button id="cancelTableCreate" class="btn ghost">Cancel</button>
            <button id="confirmTableCreate" class="btn">Create Table</button>
        </div>
    </div>
</div>

<!-- Visual Crop Modal -->
<div id="visualCropModal" class="modal-backdrop">
    <div class="modal">
        <div class="row" style="justify-content:space-between;align-items:center;gap:12px;"><h3>Crop Image</h3><button id="closeVisualCropModal" class="btn ghost">&times;</button></div>
        <div id="visualCropContainer" style="margin-top: 16px;"><canvas id="cropCanvas"></canvas></div>
        <div class="row" style="margin-top:16px; justify-content:flex-end; gap: 8px;">
            <button id="cancelCropBtn" class="btn ghost">Cancel</button>
            <button id="applyCropBtn" class="btn">Apply Crop</button>
        </div>
    </div>
</div>

<!-- AI Assistant Modal --> 
<div id="aiModalBackdrop" class="modal-backdrop">
  <div class="modal" style="width: 500px;">
    <div class="row" style="justify-content:space-between;align-items:center;gap:12px;"><h3>AI Template Assistant</h3><button id="aiCloseModal" class="btn ghost" style="padding: 4px 8px; line-height: 1;">&times;</button></div>
    <div class="stack" style="margin-top: 16px; gap: 12px;">
       <div class="stack"><label for="aiApiKey">Google AI Studio API Key <a href="https://aistudio.google.com/apikey" target="_blank" id="get-it-btn">(Get it)</a></label><input type="password" id="aiApiKey" placeholder="Enter your API key"></div>
      <div class="stack"><label for="aiPrompt">Request</label><textarea id="aiPrompt" rows="4" placeholder="e.g., 'Create an invoice template with fields for item, quantity, price, and total.'"></textarea></div>
      <div id="pasted-image-container" style="display: none; text-align: center;"><label>Pasted Image Preview:</label><img id="pasted-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Pasted Image" style="max-width: 100%; max-height: 150px; border: 1px solid #ccc; padding: 5px; margin-top: 5px; object-fit: contain;"></div>
    </div>
    <div class="row" style="margin-top:16px; justify-content:flex-end;"><button id="aiSendBtn" class="btn" style="background-color: white; color: black;"><span id="aiSendBtnText">Send Request</span><span id="aiLoadingSpinner" style="display: none;"><span>.</span><span>.</span><span>.</span></span></button></div>
  </div>
</div>

<div id="settingsModal" class="modal-backdrop">
    <div class="modal" style="width: 550px;">
        <div class="row" style="justify-content:space-between;align-items:center;gap:12px;"><h3>Settings & API Keys</h3><button id="closeSettingsModal" class="btn ghost">&times;</button></div>
        <div id="settingsContent" class="stack" style="margin-top: 16px; gap: 12px;"></div>
    </div>
</div>

<div id="tour-highlight"></div>
<div id="tour-modal">
    <div id="tour-modal-header"><h4 id="tour-modal-title">Welcome!</h4><div id="tour-modal-controls" class="row"><button id="tour-close-btn" class="btn ghost" title="Close Tutorial">&times;</button></div></div>
    <div id="tour-modal-content"><p>This is an interactive tour to guide you through the main features of the editor.</p></div>
    <div id="tour-modal-nav"><button id="tour-prev-btn" class="btn ghost">Previous</button><div id="tour-step-counter" class="muted"></div><button id="tour-next-btn" class="btn">Next</button><button id="tour-finish-btn" class="btn" style="display: none;">Finish</button></div>
</div>

<script type="module" src="assets/js/supabase-client.js"></script>
<script type="module" src="assets/js/auth.js"></script>

<script type="module">
// --- Supabase and Auth Integration ---
import { supabase } from './assets/js/supabase-client.js';

// --- UTILITIES & SETUP ---
const $ = (sel) => document.querySelector(sel);
const { jsPDF } = window.jspdf;

// --- STATE ---
const canvasWrapper = $('.canvas-wrap');
const canvas = new fabric.Canvas('c', { backgroundColor: 'transparent', selection: true });
let pageRect;
let bindings = new Map();
let workbook, worksheet, headers = [], dataRows = [], selectedColumn;
let gridEnabled = false, snapEnabled = true;
let gridCellSize = 32;
let historyStack = [];
let historyIndex = -1;
let historyLocked = false;
let _clipboard = null;
const FONT_LIST = ["Arial", "Helvetica", "Times New Roman", "Georgia", "Courier New", "Verdana", "Impact", "Comic Sans MS"];
let editingFillObject = null;
let cropCanvas, croppingImage = null;
let currentUser = null, currentTemplateId = null; 
const saveStatusEl = $('#saveStatus');

window.createLemonSqueezy();
LemonSqueezy.Setup({ eventHandler: (event) => { if (event.event === 'Checkout.Success') console.log('Checkout successful!', event.data); } });

// --- DEBOUNCE UTILITY ---
function debounce(func, delay = 1500) { let timeout; const debounced = (...args) => { clearTimeout(timeout); timeout = setTimeout(() => { func.apply(this, args); }, delay); }; debounced.clear = () => { clearTimeout(timeout); }; return debounced; }

// --- AUTH & DATA LOADING ---
async function initializeEditor() {
    applyTheme(localStorage.getItem('csvlink-theme') || 'dark');
    const { data: { session } } = await supabase.auth.getSession();
    currentUser = session?.user;

    if (currentUser) {
        const { data: profile } = await supabase.from('profiles').select('role').eq('id', currentUser.id).single();
        if (profile && (profile.role === 'pro' || profile.role === 'admin')) {
            const exportPngBtn = $('#exportPngBtn');
            if(exportPngBtn) exportPngBtn.style.display = 'inline-flex';
        }
    }

    const urlParams = new URLSearchParams(window.location.search);
    const templateId = urlParams.get('id');

    const tableResizer = new TableResizer(canvas);
    tableResizer.init();

    initializeCanvas(); 
    initializeVisualCropper();
    renderPageInspector();

    if (templateId && currentUser) { await loadTemplateFromDB(templateId); } 
    else if (!currentUser) { showGuestWarning(); centerAndFitPage(); } 
    else { centerAndFitPage(); }

    if (!localStorage.getItem('hasSeenTour')) startTour();
    initializeLeftPanelTabs();
}

function showGuestWarning() { saveStatusEl.textContent = "Log in to save your work."; }
async function loadTemplateFromDB(templateId) {
    saveStatusEl.textContent = 'Loading...';
    const urlParams = new URLSearchParams(window.location.search);
    const isPublic = urlParams.get('public') === 'true';
    let data = null;

    if (isPublic) {
        if (!currentUser) { saveStatusEl.textContent = 'Please log in to load this template.'; return; }
        let { data: existingTemplate, error: existingError } = await supabase.from('templates').select('id, title, template_data').eq('user_id', currentUser.id).eq('source_template_id', templateId).single();
        if (existingTemplate && !existingError) { data = existingTemplate; currentTemplateId = data.id; } 
        else {
            const { data: publicData, error: publicError } = await supabase.from('public_templates').select('id, title, template_data').eq('id', templateId).single();
            if (publicError) { console.error('Error loading public template:', publicError); saveStatusEl.textContent = 'Could not load the selected template.'; return; }
            data = publicData; currentTemplateId = null;
        }
    } else { 
        if (!currentUser) { saveStatusEl.textContent = 'Please log in to load your templates.'; return; }
        let { data: privateData, error: privateError } = await supabase.from('templates').select('id, title, template_data').eq('id', templateId).eq('user_id', currentUser.id).single();
        if (privateError) {
            const { data: purchasedData, error: purchasedError } = await supabase.from('purchased_templates').select('store_templates (id, title, template_data)').eq('user_id', currentUser.id).eq('template_id', templateId).single();
            if (purchasedData && purchasedData.store_templates) { data = purchasedData.store_templates; currentTemplateId = null; } 
            else { console.error('Error or template not found:', purchasedError || privateError); saveStatusEl.textContent = 'Could not load template.'; return; }
        } else { data = privateData; currentTemplateId = data.id; }
    }

    if (data && data.template_data) {
        const template = data.template_data; historyLocked = true;
        $('#titleInput').value = data.title || template.page.title || 'Untitled Template';
        $('#pageWidth').value = template.page.width || 768; $('#pageHeight').value = template.page.height || 1024;
        pageRect.set({ width: parseInt(template.page.width), height: parseInt(template.page.height) });
        bindings = new Map(template.bindings || []);
        canvas.loadFromJSON(template.canvas, () => {
            restoreCanvasStateAfterLoad(); centerAndFitPage(); historyStack = []; historyIndex = -1; historyLocked = false; saveState();
            saveStatusEl.textContent = currentTemplateId ? 'Template loaded. Your work will be saved to your copy.' : 'Template loaded. Your work will be saved as a new copy.';
        });
    } else { saveStatusEl.textContent = 'Template data is corrupted or empty.'; }
}

const debouncedSave = debounce(async () => {
    if (!currentUser || historyLocked) return; saveStatusEl.textContent = 'Saving...';
    const fullTemplateData = { canvas: canvas.toJSON(['oid', 'isTable', 'rows', 'cols', 'colWidths', 'rowHeights', 'locked']), page: { title: $('#titleInput').value, width: $('#pageWidth').value, height: $('#pageHeight').value }, bindings: Array.from(bindings.entries()), };
    const previewJson = { version: fullTemplateData.canvas.version, objects: fullTemplateData.canvas.objects, background: fullTemplateData.canvas.background || pageRect.fill };

    if (currentTemplateId) {
        const { error } = await supabase.from('templates').update({ title: $('#titleInput').value, template_data: fullTemplateData, preview_url: previewJson }).eq('id', currentTemplateId);
        if (error) { saveStatusEl.textContent = 'Error saving.'; console.error('Update Error:', error); } else { saveStatusEl.textContent = 'All changes saved.'; }
    } else {
        const { data: profile } = await supabase.from('profiles').select('role').eq('id', currentUser.id).single();
        const isFreeUser = !profile || (profile.role !== 'pro' && profile.role !== 'admin');
        if (isFreeUser) { const { count } = await supabase.from('templates').select('*', { count: 'exact', head: true }).eq('user_id', currentUser.id); if (count >= 5) { saveStatusEl.textContent = 'Free account limit (5 templates) reached.'; return; } }
        const { data, error } = await supabase.from('templates').insert({ user_id: currentUser.id, title: $('#titleInput').value, template_data: fullTemplateData, preview_url: previewJson }).select('id').single();
        if (error) { saveStatusEl.textContent = 'Error creating template.'; console.error('Insert Error:', error); } 
        else { currentTemplateId = data.id; const newUrl = `${window.location.pathname}?id=${currentTemplateId}`; window.history.replaceState({ path: newUrl }, '', newUrl); saveStatusEl.textContent = 'Template saved.'; }
    }
});

function saveState(){ if (historyLocked) return; historyStack.splice(historyIndex + 1); historyStack.push(canvas.toJSON(['oid', 'isTable', 'rows', 'cols', 'colWidths', 'rowHeights', 'locked'])); historyIndex = historyStack.length - 1; updateHistoryButtons(); if (currentUser) { saveStatusEl.textContent = 'Unsaved changes...'; debouncedSave(); } }

// --- CANVAS & PAGE SETUP ---
function initializeCanvas() {
    fabric.Object.prototype.set({ transparentCorners: false, cornerStyle: 'circle', cornerColor: '#000000', cornerSize: 10, borderColor: '#000000', borderScaleFactor: 1, padding: 10 });
    fabric.ActiveSelection.prototype.set({ cornerStyle: 'circle', cornerColor: '#000000', borderColor: 'black' });
    const resizeCanvas = () => { const { width, height } = canvasWrapper.getBoundingClientRect(); canvas.setWidth(width); canvas.setHeight(height); canvas.renderAll(); };
    pageRect = new fabric.Rect({ left: 0, top: 0, width: 768, height: 1024, fill: '#fff', stroke: 'transparent', strokeWidth: 0, selectable: false, evented: false, hasControls: false, hasBorders: false, lockMovementX: true, lockMovementY: true, lockScalingX: true, lockScalingY: true, lockRotation: true, oid: 'pageRect' });
    canvas.add(pageRect); resizeCanvas(); drawGrid(); new ResizeObserver(resizeCanvas).observe(canvasWrapper);
    canvas.on({ 'object:added': () => { saveState(); renderLayers(); if (dataLinksManagerModal.style.display === 'flex') renderDataLinksManager(); }, 'object:removed': () => { saveState(); renderLayers(); if (dataLinksManagerModal.style.display === 'flex') renderDataLinksManager(); }, 'object:modified': (e) => { saveState(); if (e.target) { refreshInspector({target: e.target}); } }, 'object:moving': handleSmartSnapping, 'object:scaling': updateLiveInspector, 'object:rotating': updateLiveInspector });
    saveState(); renderLayers();
}
window.addEventListener('paste', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return; const items = e.clipboardData.items; if (!items) return;
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (item.type.indexOf('image') !== -1) { e.preventDefault(); const blob = item.getAsFile(); const reader = new FileReader(); reader.onload = (event) => { const {x, y} = canvas.getVpCenter(); adders.image(x, y, event.target.result); }; reader.readAsDataURL(blob); break; }
        if (item.type.indexOf('text/plain') !== -1) { e.preventDefault(); item.getAsString((text) => { const {x, y} = canvas.getVpCenter(); adders.text(x, y, text); }); break; }
    }
});
const setPageDimensions = debounce(() => { if (!pageRect) return; const w = parseInt($('#pageWidth').value, 10) || 768; const h = parseInt($('#pageHeight').value, 10) || 1024; pageRect.set({ width: w, height: h }); canvas.centerObject(pageRect); pageRect.setCoords(); drawGrid(); canvas.renderAll(); saveState(); }, 300);
$('#titleInput').addEventListener("input", () => { saveState(); }); $('#pageWidth').addEventListener('input', setPageDimensions); $('#pageHeight').addEventListener('input', setPageDimensions);
function drawGrid() { canvas.remove(...canvas.getObjects('line').filter(o => o.excludeFromExport)); if (!gridEnabled || !pageRect) { canvas.renderAll(); return; } const { width, height, left, top } = pageRect; const gridLines = []; const lineOption = { stroke: 'rgba(0,0,0,0.1)', selectable: false, evented: false, excludeFromExport: true }; const step = gridCellSize; for (let i = 1; i < (width / step); i++) gridLines.push(new fabric.Line([left + i * step, top, left + i * step, top + height], lineOption)); for (let i = 1; i < (height / step); i++) gridLines.push(new fabric.Line([left, top + i * step, left + width, top + i * step], lineOption)); canvas.add(...gridLines); gridLines.forEach(line => canvas.sendToBack(line)); canvas.sendToBack(pageRect); canvas.renderAll(); }
$('#toggleGridBtn').addEventListener('click', () => { gridEnabled = !gridEnabled; $('#toggleGridBtn').classList.toggle('active', gridEnabled); drawGrid(); });
$('#toggleSnapBtn').addEventListener('click', () => { snapEnabled = !snapEnabled; $('#toggleSnapBtn').classList.toggle('active', snapEnabled); });
const gridSizeInput = $('#gridSizeInput'); gridSizeInput.value = gridCellSize; gridSizeInput.addEventListener('input', (e) => { const newSize = Math.max(12, Math.min(64, parseInt(e.target.value, 10))); if (!isNaN(newSize) && gridCellSize !== newSize) { gridCellSize = newSize; drawGrid(); } });

// --- CANVAS PANNING & ZOOM ---
// Detect if running on a touch device
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

let isPanning = false;
let lastPosX, lastPosY;

// Track double click state
let lastClickTime = 0;
let doubleClickActive = false;

// --- Zoom (works everywhere with wheel) ---
canvas.on('mouse:wheel', function(opt) {
  const delta = opt.e.deltaY;
  let zoom = canvas.getZoom();
  zoom *= 0.999 ** delta;
  if (zoom > 20) zoom = 20;
  if (zoom < 0.05) zoom = 0.05;

  canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
  document.getElementById('zoomLevel').textContent =
    `Zoom: ${Math.round(zoom * 100)}%`;

  opt.e.preventDefault();
  opt.e.stopPropagation();
});

// --- Panning only on non-touch devices ---
if (!isTouchDevice) {
  canvas.on('mouse:down', function(opt) {
    const e = opt.e;
    const now = Date.now();

    // Detect double click on left button (desktop only)
    if (now - lastClickTime < 300 && e.button === 0) {
      doubleClickActive = true;
    } else {
      doubleClickActive = false;
    }
    lastClickTime = now;

    // Prevent middle mouse auto-scroll
    if (e.button === 1) e.preventDefault();

    // Middle button, double left click, or Alt+drag → start panning
    if (e.button === 1 || doubleClickActive || e.altKey) {
      isPanning = true;
      this.selection = false;
      lastPosX = e.clientX;
      lastPosY = e.clientY;
    }
  });

  canvas.on('mouse:move', function(opt) {
    if (isPanning) {
      const e = opt.e;
      const vpt = this.viewportTransform;
      vpt[4] += e.clientX - lastPosX;
      vpt[5] += e.clientY - lastPosY;
      this.requestRenderAll();
      lastPosX = e.clientX;
      lastPosY = e.clientY;
    }
  });

  canvas.on('mouse:up', function() {
    if (isPanning) {
      this.setViewportTransform(this.viewportTransform);
      isPanning = false;
      this.selection = true;
      doubleClickActive = false;
    }
  });
}

// --- DATA HANDLING ---
$('#csvInput').addEventListener('change', async (e) => { const file = e.target.files?.[0]; if (!file) { $('#fileName').textContent = 'No file selected'; return; } $('#fileName').textContent = file.name; const data = await file.arrayBuffer(); try { workbook = XLSX.read(data, { type: 'array' }); const sheetName = workbook.SheetNames[0]; worksheet = workbook.Sheets[sheetName]; const json = XLSX.utils.sheet_to_json(worksheet, { defval: '', raw: false }); if (!json.length) { alert('No data found in the sheet.'); return; } headers = Object.keys(json[0]); dataRows = json; alert(`Loaded "${sheetName}" with ${dataRows.length} rows.`); } catch (err) { alert('Error reading file.'); $('#fileName').textContent = 'No file selected'; } });

// --- COMPONENT ADDITION ---
const tableCreatorModal = $('#tableCreatorModal');
const adders = {
  text: (x, y, content = 'Sample Text') => canvas.add(new fabric.Textbox(content, { left: x, top: y, fontSize: 28, fill: '#000', fontFamily: 'Arial', originX: 'center', originY: 'center', styles: [], padding: 10 })).setActiveObject(canvas.getObjects().pop()),
  rect: ({x, y, asSquare=true}={}) => canvas.add(new fabric.Rect({ left: x, top: y, width: asSquare?150:220, height: 150, fill: '#f0f0f0', stroke: '#333', strokeWidth: 2, originX: 'center', originY: 'center' })).setActiveObject(canvas.getObjects().pop()),
  circle: (x, y) => canvas.add(new fabric.Circle({ left: x, top: y, radius: 75, fill: '#f0f0f0', stroke: '#333', strokeWidth: 2, originX: 'center', originY: 'center' })).setActiveObject(canvas.getObjects().pop()),
  triangle: (x, y) => canvas.add(new fabric.Triangle({ left: x, top: y, width: 150, height: 130, fill: '#f0f0f0', stroke: '#333', strokeWidth: 2, originX: 'center', originY: 'center' })).setActiveObject(canvas.getObjects().pop()),
  line: (x, y) => canvas.add(new fabric.Line([-75, 0, 75, 0], { left: x, top: y, stroke: '#333', strokeWidth: 2, originX: 'center', originY: 'center', padding: 10 })).setActiveObject(canvas.getObjects().pop()),
  star: (x, y) => { const pts = (n, oR, iR) => { const p=[]; let a=-Math.PI/2; const s=(Math.PI*2)/n; for(let i=0;i<n;i++){p.push({x:oR*Math.cos(a),y:oR*Math.sin(a)});a+=s/2;p.push({x:iR*Math.cos(a),y:iR*Math.sin(a)});a+=s/2;} return p;}; canvas.add(new fabric.Polygon(pts(5, 75, 35), { left: x, top: y, fill: '#f0f0f0', stroke: '#333', strokeWidth: 2, originX: 'center', originY: 'center' })).setActiveObject(canvas.getObjects().pop()); },
  square: (x, y) => adders.rect({x, y, asSquare: true}),
  arrow: (x, y) => canvas.add(new fabric.Path('M 0 20 L 60 20 L 60 0 L 100 30 L 60 60 L 60 40 L 0 40 Z', { left: x, top: y, fill: '#f0f0f0', stroke: '#333', strokeWidth: 2, originX: 'center', originY: 'center' })).setActiveObject(canvas.getObjects().pop()),
  image: (x, y, url, elementData = {}) => { fabric.Image.fromURL(url, (img) => { img.set({ left: x, top: y, scaleX: 0.5, scaleY: 0.5, originX: 'center', originY: 'center', ...elementData }); canvas.add(img).setActiveObject(img); }, { crossOrigin: 'anonymous' }); },
  svg: (x, y, url, elementData = {}) => {
        const fillColor = elementData.fill || '#f0f0f0';
        const strokeColor = elementData.stroke || '#333';
        const strokeWidth = elementData.strokeWidth ?? 2;

        fabric.loadSVGFromURL(url, (objects, options) => {
            if (!objects || objects.length === 0) return;

            const group = new fabric.Group(objects, {
                ...options,
                ...elementData,
                left: x,
                top: y,
                originX: 'center',
                originY: 'center'
            });

            // Scale to a standard size
            group.scaleToWidth(150);

            canvas.add(group).setActiveObject(canvas.getObjects().pop());
            canvas.renderAll();
        }, null, { crossOrigin: 'anonymous' });
    },
  table: (x, y) => {
    tableCreatorModal.style.display = 'flex';

    const createHandler = () => {
        const rows = parseInt($('#tableRows').value, 10) || 3;
        const cols = parseInt($('#tableCols').value, 10) || 3;
        if (rows <= 0 || cols <= 0) return;

        const cellWidth = 120, cellHeight = 50;
        const tableItems = [];
        const colWidths = Array(cols).fill(cellWidth);
        const rowHeights = Array(rows).fill(cellHeight);

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const cell = new fabric.Rect({
                    left: 0, top: 0,
                    width: cellWidth, height: cellHeight,
                    fill: 'transparent', stroke: '#333', strokeWidth: 1,
                    selectable: false, evented: false,
                });
                tableItems.push(cell);
            }
        }

        const table = new fabric.Group(tableItems, {
            left: x, top: y,
            originX: 'center', originY: 'center',
            isTable: true,
            rows, cols, colWidths, rowHeights,
            originalColWidths: [...colWidths],
            originalRowHeights: [...rowHeights],
            hasControls: true,
            hasBorders: true,
            cornerColor: '#4285F4',
            cornerStyle: 'circle',
            transparentCorners: false,
            borderColor: '#4285F4',
            borderScaleFactor: 2,
            objectCaching: false, 
            lockScalingFlip: true,
        });
        
        updateTableLayout(table);

        canvas.add(table).setActiveObject(table);
        canvas.requestRenderAll();
        closeTableModal();
    };

    const closeTableModal = () => {
        tableCreatorModal.style.display = 'none';
        $('#confirmTableCreate').removeEventListener('click', createHandler);
        $('#cancelTableCreate').removeEventListener('click', closeTableModal);
        $('#closeTableCreator').removeEventListener('click', closeTableModal);
    };

    $('#confirmTableCreate').addEventListener('click', createHandler, { once: true });
    $('#cancelTableCreate').addEventListener('click', closeTableModal, { once: true });
    $('#closeTableCreator').addEventListener('click', closeTableModal, { once: true });
  }
};

function updateTableLayout(table) {
    if (!table || !table.isTable) return;

    const totalWidth = table.colWidths.reduce((sum, w) => sum + w, 0);
    const totalHeight = table.rowHeights.reduce((sum, h) => sum + h, 0);

    let currentY = -totalHeight / 2;
    for (let r = 0; r < table.rows; r++) {
        let currentX = -totalWidth / 2;
        for (let c = 0; c < table.cols; c++) {
            const cellIndex = r * table.cols + c;
            const cell = table.item(cellIndex);
            const width = table.colWidths[c];
            const height = table.rowHeights[r];

            cell.set({ width, height, left: currentX, top: currentY });
            currentX += width;
        }
        currentY += table.rowHeights[r];
    }
    
    table.width = totalWidth;
    table.height = totalHeight;
    table.setCoords(); 
}

class TableResizer {

    constructor(canvas) {
        this.canvas = canvas;
        this.state = {};
        this.resetState();

        this.RESIZE_HANDLE_AREA = 12;
        this.MIN_CELL_SIZE = 25;
    }

    resetState() {
        if (this.state.target) {
            this.state.target.lockMovementX = false;
            this.state.target.lockMovementY = false;
        }
        this.state = {
            isResizing: false,
            target: null, 
            type: null,  
            index: -1, 
            startX: 0,
            startY: 0,
            originalPos: { x: 0, y: 0 },
            originalWidths: [],
            originalHeights: [],
        };
        this.canvas.defaultCursor = 'default';
    }

    init() {
        this.canvas.on('mouse:down', this.handleMouseDown.bind(this));
        this.canvas.on('mouse:move', this.handleMouseMove.bind(this));
        this.canvas.on('mouse:up', this.handleMouseUp.bind(this));
        this.canvas.on('object:scaling', this.handleObjectScaling.bind(this));
    }
    
    handleObjectScaling(options) {
        const table = options.target;
        if (!table || !table.isTable) return;

        const { scaleX, scaleY } = table;
        
        let totalWidth = 0;
        for (let i = 0; i < table.colWidths.length; i++) {
            const newWidth = table.originalColWidths[i] * scaleX;
            table.colWidths[i] = Math.max(this.MIN_CELL_SIZE, newWidth);
            totalWidth += table.colWidths[i];
        }
        
        let totalHeight = 0;
        for (let i = 0; i < table.rowHeights.length; i++) {
            const newHeight = table.originalRowHeights[i] * scaleY;
            table.rowHeights[i] = Math.max(this.MIN_CELL_SIZE, newHeight);
            totalHeight += table.rowHeights[i];
        }
        
        table.width = totalWidth;
        table.height = totalHeight;
        table.scaleX = 1;
        table.scaleY = 1;

        updateTableLayout(table);
    }

    handleMouseDown(options) {
        if (options.target && options.target.isTable) {
            options.target.originalColWidths = [...options.target.colWidths];
            options.target.originalRowHeights = [...options.target.rowHeights];
        }

        if (!this.canvas.defaultCursor.includes('resize') || !options.target || !options.target.isTable) {
            return;
        }

        const pointer = this.canvas.getPointer(options.e);
        const table = options.target;

        this.state.isResizing = true;
        this.state.target = table;
        this.state.startX = pointer.x;
        this.state.startY = pointer.y;
        this.state.originalPos = { x: table.left, y: table.top };
        this.state.originalWidths = [...table.colWidths];
        this.state.originalHeights = [...table.rowHeights];

        table.lockMovementX = true;
        table.lockMovementY = true;
    }

    handleMouseMove(options) {
        if (this.state.isResizing) {
            this.performResize(options);
        } else {
            this.detectHover(options);
        }
    }

    performResize(options) {
        const pointer = this.canvas.getPointer(options.e);
        const { target, type, index, startX, startY, originalPos } = this.state;
        const dx = pointer.x - startX;
        const dy = pointer.y - startY;

        switch (type) {
            // --- INTERNAL RESIZING (PUSH/PULL) ---
            case 'col': {
                const newWidth = this.state.originalWidths[index] + dx;
                const adjacentNewWidth = this.state.originalWidths[index + 1] - dx;
                if (newWidth >= this.MIN_CELL_SIZE && adjacentNewWidth >= this.MIN_CELL_SIZE) {
                    target.colWidths[index] = newWidth;
                    target.colWidths[index + 1] = adjacentNewWidth;
                }
                break;
            }
            case 'row': {
                const newHeight = this.state.originalHeights[index] + dy;
                const adjacentNewHeight = this.state.originalHeights[index + 1] - dy;
                if (newHeight >= this.MIN_CELL_SIZE && adjacentNewHeight >= this.MIN_CELL_SIZE) {
                    target.rowHeights[index] = newHeight;
                    target.rowHeights[index + 1] = adjacentNewHeight;
                }
                break;
            }
            // --- EDGE RESIZING (PIVOT LOGIC) ---
            case 'edge-right': {
                const newWidth = this.state.originalWidths[index] + dx;
                if (newWidth >= this.MIN_CELL_SIZE) {
                    target.colWidths[index] = newWidth;
                    // [FIX] Move the table's center by HALF the delta to keep the left edge anchored.
                    target.left = originalPos.x + dx / 2;
                }
                break;
            }
             case 'edge-left': {
                const newWidth = this.state.originalWidths[index] - dx;
                if (newWidth >= this.MIN_CELL_SIZE) {
                    target.colWidths[index] = newWidth;
                    // Move the table's center by HALF the delta to keep the right edge anchored.
                    target.left = originalPos.x + dx / 2;
                }
                break;
            }
            case 'edge-bottom': {
                const newHeight = this.state.originalHeights[index] + dy;
                if (newHeight >= this.MIN_CELL_SIZE) {
                    target.rowHeights[index] = newHeight;
                    // [FIX] Move the table's center by HALF the delta to keep the top edge anchored.
                    target.top = originalPos.y + dy / 2;
                }
                break;
            }
            case 'edge-top': {
                const newHeight = this.state.originalHeights[index] - dy;
                if (newHeight >= this.MIN_CELL_SIZE) {
                    target.rowHeights[index] = newHeight;
                     // Move the table's center by HALF the delta to keep the bottom edge anchored.
                    target.top = originalPos.y + dy / 2;
                }
                break;
            }
        }
        
        // This function recalculates total dimensions and repositions internal cells.
        updateTableLayout(target);
        
        // We must re-render the canvas to see the changes.
        this.canvas.requestRenderAll();
    }
    
    detectHover(options) {
        const target = this.canvas.findTarget(options.e);
        if (!target || !target.isTable || !target.hasControls) {
            if (this.canvas.defaultCursor !== 'default') this.canvas.defaultCursor = 'default';
            if (this.canvas.hoverCursor !== 'default') this.canvas.hoverCursor = 'default';
            return;
        }

        const pointer = this.canvas.getPointer(options.e);
        const table = target;
        const localPoint = table.toLocalPoint(new fabric.Point(pointer.x, pointer.y), 'center', 'center');
        
        let onBoundary = false;

        let currentX = -table.width / 2;
        for (let c = 0; c < table.cols; c++) {
            if (c === 0 && Math.abs(localPoint.x - currentX) < this.RESIZE_HANDLE_AREA) {
                this.canvas.defaultCursor = 'ew-resize';
                this.canvas.hoverCursor = 'ew-resize';
                this.state.type = 'edge-left';
                this.state.index = 0;
                onBoundary = true; break;
            }
            currentX += table.colWidths[c];
            if (Math.abs(localPoint.x - currentX) < this.RESIZE_HANDLE_AREA) {
                this.canvas.defaultCursor = 'ew-resize';
                this.canvas.hoverCursor = 'ew-resize';
                this.state.type = (c === table.cols - 1) ? 'edge-right' : 'col';
                this.state.index = c;
                onBoundary = true; break;
            }
        }

        if (!onBoundary) {
            let currentY = -table.height / 2;
            for (let r = 0; r < table.rows; r++) {
                if (r === 0 && Math.abs(localPoint.y - currentY) < this.RESIZE_HANDLE_AREA) {
                    this.canvas.defaultCursor = 'ns-resize';
                    this.canvas.hoverCursor = 'ns-resize';
                    this.state.type = 'edge-top';
                    this.state.index = 0;
                    onBoundary = true; break;
                }
                currentY += table.rowHeights[r];
                if (Math.abs(localPoint.y - currentY) < this.RESIZE_HANDLE_AREA) {
                    this.canvas.defaultCursor = 'ns-resize';
                    this.canvas.hoverCursor = 'ns-resize';
                    this.state.type = (r === table.rows - 1) ? 'edge-bottom' : 'row';
                    this.state.index = r;
                    onBoundary = true; break;
                }
            }
        }
        
        if (!onBoundary) {
            this.canvas.defaultCursor = 'default';
            this.canvas.hoverCursor = 'default';
        }
    }

    handleMouseUp() {
        if (this.state.isResizing) {
            if (this.state.target) {
                this.state.target.originalColWidths = [...this.state.target.colWidths];
                this.state.target.originalRowHeights = [...this.state.target.rowHeights];
            }
            this.resetState();
            this.canvas.requestRenderAll();
        }
    }
}

document.getElementById('imageUpload').addEventListener('change', e => { if (!e.target.files || !e.target.files[0]) return; const reader = new FileReader(); reader.onload = (ev) => { const {x, y} = canvas.getVpCenter(); adders.image(x, y, ev.target.result); e.target.value = ''; }; reader.readAsDataURL(e.target.files[0]); });
document.querySelectorAll('.shape-chip').forEach(chip => { const type = chip.getAttribute('data-add'); chip.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', `component:${type}`); }); chip.addEventListener('click', () => { if (!adders[type]) return; if (type === 'image') { $('#imageUpload').click(); return; } const center = canvas.getVpCenter(); adders[type](center.x, center.y); }); });
const dropTarget = canvas.upperCanvasEl; canvas.calcOffset();
dropTarget.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
dropTarget.addEventListener('drop', (e) => {
  e.preventDefault(); const { x, y } = canvas.getPointer(e); const data = e.dataTransfer.getData('text/plain'); const [dataType, value] = data.split(/:(.*)/s);
  if (dataType === 'component' && adders[value]) { if (value === 'image') { const file = e.dataTransfer.files?.[0]; if (file?.type.startsWith('image/')) { const reader = new FileReader(); reader.onload = (ev) => adders.image(x, y, ev.target.result); reader.readAsDataURL(file); } else { $('#imageUpload').click(); } } else { adders[value](x, y); } } 
  else if (dataType === 'element') { const elementData = JSON.parse(value); adders.image(x, y, elementData.image_url, { oid: elementData.id }); }
});

// --- SIDEBAR RESIZING & TOGGLING ---
const mainLayout = document.getElementById('main-layout'); const leftResizer = document.getElementById('left-resizer'); const rightResizer = document.getElementById('right-resizer'); let isResizingLeft = false, isResizingRight = false; let lastLeftPanelWidth = '300px', lastRightPanelWidth = '300px'; mainLayout.style.gridTemplateColumns = `${lastLeftPanelWidth} 5px 1fr 5px ${lastRightPanelWidth}`;
function initResizer(resizer, resizeFlagSetter, panelSide) { resizer.addEventListener('mousedown', (e) => { e.preventDefault(); resizeFlagSetter(true); document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none'; }); document.addEventListener('mousemove', (e) => { if (!resizeFlagSetter()) return; const mainRect = mainLayout.getBoundingClientRect(); if (panelSide === 'left') { const newWidth = e.clientX - mainRect.left; if (newWidth > 150 && newWidth < mainRect.width / 2) { mainLayout.style.gridTemplateColumns = `${newWidth}px 5px 1fr 5px ${mainLayout.style.gridTemplateColumns.split(' ')[4]}`; lastLeftPanelWidth = `${newWidth}px`; } } else { const newWidth = mainRect.right - e.clientX; if (newWidth > 200 && newWidth < mainRect.width / 2) { mainLayout.style.gridTemplateColumns = `${mainLayout.style.gridTemplateColumns.split(' ')[0]} 5px 1fr 5px ${newWidth}px`; lastRightPanelWidth = `${newWidth}px`; } } canvas.setWidth(canvasWrapper.getBoundingClientRect().width); canvas.renderAll(); }); document.addEventListener('mouseup', () => { if (resizeFlagSetter()) { resizeFlagSetter(false); document.body.style.cursor = 'default'; document.body.style.userSelect = 'auto'; } }); }
initResizer(leftResizer, (v) => { if(v !== undefined) isResizingLeft=v; return isResizingLeft; }, 'left'); initResizer(rightResizer, (v) => { if(v !== undefined) isResizingRight=v; return isResizingRight; }, 'right');
function refreshCanvasSize() { setTimeout(() => { const { width, height } = canvasWrapper.getBoundingClientRect(); canvas.setWidth(width); canvas.setHeight(height); canvas.renderAll(); centerAndFitPage(); }, 50); }
document.getElementById('left-panel-toggle').addEventListener('click', () => { const btn = document.getElementById('left-panel-toggle'); const cols = mainLayout.style.gridTemplateColumns.split(' '); if (cols[0] !== '0px') { lastLeftPanelWidth = cols[0]; mainLayout.style.gridTemplateColumns = `0px 0px 1fr 5px ${cols[4]}`; btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`; } else { mainLayout.style.gridTemplateColumns = `${lastLeftPanelWidth} 5px 1fr 5px ${cols[4]}`; btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`; } refreshCanvasSize(); });
document.getElementById('right-panel-toggle').addEventListener('click', () => { const btn = document.getElementById('right-panel-toggle'); const cols = mainLayout.style.gridTemplateColumns.split(' '); if (cols[4] !== '0px') { lastRightPanelWidth = cols[4]; mainLayout.style.gridTemplateColumns = `${cols[0]} 5px 1fr 0px 0px`; btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`; } else { mainLayout.style.gridTemplateColumns = `${cols[0]} 5px 1fr 5px ${lastRightPanelWidth}`; btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`; } refreshCanvasSize(); });

// --- REBUILT: SNAPPING GUIDES ---
const snapThreshold = 20, snapColor = '#FFC107';
let snapLines = [];
function handleSmartSnapping(options) {
    if (!snapEnabled) return; const target = options.target; if (!target.isLocked) {
        clearSnapLines();
        const targetCenter = target.getCenterPoint();
        const targetBoundingRect = target.getBoundingRect();
        let snapX = null, snapY = null;
        const otherObjects = canvas.getObjects().filter(o => o.visible && o.evented && o !== target && !o.excludeFromExport && !o.isSnapLine);

        const checkSnap = (targetPoint, objPoint, axis) => {
            if (Math.abs(targetPoint - objPoint) < snapThreshold) {
                const snapValue = (axis === 'X') ? snapX : snapY;
                if (snapValue === null || Math.abs(targetPoint - objPoint) < Math.abs(snapValue.targetPoint - snapValue.objPoint)) {
                    if (axis === 'X') snapX = { targetPoint, objPoint }; else snapY = { targetPoint, objPoint };
                }
            }
        };

        // Page Center Snapping
        if (pageRect) {
            const pageCenter = pageRect.getCenterPoint();
            checkSnap(targetCenter.x, pageCenter.x, 'X');
            checkSnap(targetCenter.y, pageCenter.y, 'Y');
        }

        // Object-to-Object Snapping
        otherObjects.forEach(obj => {
            const objCenter = obj.getCenterPoint(); const objBoundingRect = obj.getBoundingRect();
            // Vertical checks (X-axis)
            //checkSnap(targetBoundingRect.left, objBoundingRect.left, 'X');
            //checkSnap(targetBoundingRect.left, objBoundingRect.left + objBoundingRect.width, 'X');
            checkSnap(targetCenter.x, objCenter.x, 'X');
            checkSnap(targetCenter.x, objCenter.x + objBoundingRect.width, 'X');
            checkSnap(targetCenter.x, objCenter.x - objBoundingRect.width, 'X');
            //checkSnap(targetBoundingRect.left + targetBoundingRect.width, objBoundingRect.left, 'X');
            //checkSnap(targetBoundingRect.left + targetBoundingRect.width, objBoundingRect.left + objBoundingRect.width, 'X');
            // Horizontal checks (Y-axis)
            //checkSnap(targetBoundingRect.top, objBoundingRect.top, 'Y');
            //checkSnap(targetBoundingRect.top, objBoundingRect.top + objBoundingRect.height, 'Y');
            checkSnap(targetCenter.y, objCenter.y, 'Y');
            checkSnap(targetCenter.y, objCenter.y + objBoundingRect.height, 'Y');
            checkSnap(targetCenter.y, objCenter.y - objBoundingRect.height, 'Y');
            //checkSnap(targetBoundingRect.top + targetBoundingRect.height, objBoundingRect.top, 'Y');
            //checkSnap(targetBoundingRect.top + targetBoundingRect.height, objBoundingRect.top + objBoundingRect.height, 'Y');
        });

        if (snapX !== null) {
            target.left -= (snapX.targetPoint - snapX.objPoint);
            drawSnapLine({ x1: snapX.objPoint, y1: -5000, x2: snapX.objPoint, y2: 5000 });
        }
        if (snapY !== null) {
            target.top -= (snapY.targetPoint - snapY.objPoint);
            drawSnapLine({ y1: snapY.objPoint, x1: -5000, y2: snapY.objPoint, x2: 5000 });
        }
        target.setCoords();
    }
}
function drawSnapLine(coords) { const line = new fabric.Line([coords.x1, coords.y1, coords.x2, coords.y2], { stroke: snapColor, strokeWidth: 1, selectable: false, evented: false, isSnapLine: true, excludeFromExport: true}); snapLines.push(line); canvas.add(line); line.bringToFront(); }
function clearSnapLines() { snapLines.forEach(line => canvas.remove(line)); snapLines = []; }
canvas.on('object:modified', clearSnapLines); canvas.on('mouse:up', clearSnapLines);


// --- SETTINGS & API KEY MODAL ---
const settingsBtn = $('#settingsBtn'); const settingsModal = $('#settingsModal'); const closeSettingsModalBtn = $('#closeSettingsModal');
settingsBtn.addEventListener('click', openSettingsModal); closeSettingsModalBtn.addEventListener('click', () => settingsModal.style.display = 'none'); settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) { settingsModal.style.display = 'none'; } });
const openCustomerPortal = async () => { const btn = $('#manageSubscriptionBtn'); if (btn) { btn.disabled = true; btn.textContent = 'Generating link...'; } try { const { data, error } = await supabase.functions.invoke('lemonsqueezy-sub-manager', { body: { action: 'getPortalLink' } }); if (error) throw error; if (data && data.url) window.open(data.url, '_blank'); else throw new Error('Could not generate portal link.'); } catch (error) { alert(`Error: ${error.message}`); } finally { if (btn) { btn.disabled = false; btn.textContent = 'Manage Subscription'; } } };
async function openSettingsModal() { const settingsContent = $('#settingsContent'); settingsContent.innerHTML = '<p class="muted">Loading account details...</p>'; settingsModal.style.display = 'flex'; const { data: { user } } = await supabase.auth.getUser(); if (!user) { settingsContent.innerHTML = '<p>Please log in to manage your settings.</p>'; return; } const { data: profile, error } = await supabase.from('profiles').select('role').eq('id', user.id).single(); if (error || !profile) { settingsContent.innerHTML = '<p class="error">Could not load your profile.</p>'; return; } const currentTheme = localStorage.getItem('csvlink-theme') || 'dark'; let modalHTML = `<div class="settings-section stack"><h4>Appearance</h4><button id="themeToggleBtn" class="btn ghost" style="width: 100%;">${currentTheme === 'dark' ? 'Switch to Light Mode' : 'Switch to Dark Mode'}</button></div><div class="settings-section stack" style="gap: 16px;"><h4>Account</h4><div class="stack"><label for="newPassword">New Password</label><input type="password" id="newPassword" placeholder="Enter new password"></div><div class="stack"><label for="confirmPassword">Confirm Password</label><input type="password" id="confirmPassword" placeholder="Confirm new password"></div><button id="changePasswordBtn" class="btn">Update Password</button><p id="passwordMessage" class="muted" style="text-align:center; margin-top: 4px;"></p></div>`; if (profile.role === 'pro' || profile.role === 'admin') { modalHTML += `<div class="settings-section stack"><h4>Subscription</h4><p class="muted">You are on the Pro plan.</p><button id="manageSubscriptionBtn" class="btn ghost" style="width: 100%;">Manage Subscription</button></div>`; } else { modalHTML += `<div class="settings-section stack"><h4>Upgrade to Pro</h4><p class="muted">Upgrade for API access and unlimited templates.</p><a href="/#pricing" class="btn" style="text-decoration: none;">View Pricing Plans</a></div>`; } if (profile.role === 'pro' || profile.role === 'admin') { modalHTML += `<div class="settings-section stack" style="gap: 16px;"><h4>Developer API Keys</h4><div id="newKeyContainer" class="stack" style="display:none;"><h5>Your New API Key</h5><p class="muted">Copy this key and store it safely. <strong>You will not see it again.</strong></p><div id="newKeyDisplay"></div></div><div class="stack"><h5>Your Existing Keys</h5><div id="existingKeysList" class="stack">Loading...</div></div><button id="generateKeyBtn" class="btn">Generate New API Key</button><p id="keyMessage" class="muted" style="text-align:center; margin-top: 4px;"></p></div>`; } settingsContent.innerHTML = modalHTML; attachSettingsEventListeners(user.id, profile.role); }
function attachSettingsEventListeners(userId, role) { $('#themeToggleBtn').addEventListener('click', toggleTheme); $('#changePasswordBtn').addEventListener('click', async () => { const newPassword = $('#newPassword').value, confirmPassword = $('#confirmPassword').value, msgEl = $('#passwordMessage'); if (!newPassword || newPassword !== confirmPassword) { msgEl.textContent = 'Passwords do not match or are empty.'; return; } msgEl.textContent = 'Updating...'; const { error } = await supabase.auth.updateUser({ password: newPassword }); if (error) { msgEl.textContent = `Error: ${error.message}`; } else { msgEl.textContent = 'Password updated successfully!'; $('#newPassword').value = ''; $('#confirmPassword').value = ''; } }); if (role === 'pro' || role === 'admin') { $('#generateKeyBtn').addEventListener('click', handleGenerateKey); loadAndDisplayKeys(userId); if ($('#manageSubscriptionBtn')) $('#manageSubscriptionBtn').addEventListener('click', openCustomerPortal); } }
function applyTheme(theme) { document.body.classList.toggle('light-mode', theme === 'light'); localStorage.setItem('csvlink-theme', theme); }
function toggleTheme() { const newTheme = (localStorage.getItem('csvlink-theme') || 'dark') === 'dark' ? 'light' : 'dark'; applyTheme(newTheme); const themeBtn = $('#themeToggleBtn'); if (themeBtn) { themeBtn.textContent = newTheme === 'dark' ? 'Switch to Light Mode' : 'Switch to Dark Mode'; } }
async function loadAndDisplayKeys(userId) { const list = $('#existingKeysList'); const { data: keys, error } = await supabase.from('api_keys').select('api_key, created_at').eq('user_id', userId); if (error) { list.innerHTML = '<p class="error">Could not load keys.</p>'; return; } if (keys.length === 0) { list.innerHTML = '<p class="muted">No API keys generated.</p>'; } else { list.innerHTML = keys.map(k => `<div class="api-key-item"><span>${k.api_key.substring(0, 11)}...${k.api_key.substring(k.api_key.length - 4)}</span><span class="muted">Created: ${new Date(k.created_at).toLocaleDateString()}</span></div>`).join(''); } }
async function handleGenerateKey() { const btn = $('#generateKeyBtn'), msg = $('#keyMessage'), container = $('#newKeyContainer'), display = $('#newKeyDisplay'); btn.disabled = true; btn.textContent = 'Generating...'; msg.textContent = ''; container.style.display = 'none'; try { const { data, error } = await supabase.functions.invoke('generate-api-key'); if (error) throw error; display.textContent = data.apiKey; container.style.display = 'block'; const { data: { user } } = await supabase.auth.getUser(); loadAndDisplayKeys(user.id); } catch (error) { msg.textContent = `Error: ${error.message}`; } finally { btn.disabled = false; btn.textContent = 'Generate New API Key'; } }

// --- INSPECTOR & HELPERS ---
const inspector = $('#inspector'); const multiInspector = $('#multiSelectInspector');
canvas.on('selection:created', (e) => { refreshInspector(e); renderLayers(); }); canvas.on('selection:updated', (e) => { refreshInspector(e); renderLayers(); }); canvas.on('selection:cleared', () => { $('#noSelection').style.display='block'; inspector.style.display='none'; multiInspector.style.display='none'; renderPageInspector(); renderLayers(); });
function updateLiveInspector(options) { const target = options.target; if (!target || target.type === 'activeSelection') return; const updateValue = (id, value) => { const el = document.getElementById(id); if (el) el.value = value; }; updateValue('inspector-pos-x', Math.round(target.left)); updateValue('inspector-pos-y', Math.round(target.top)); updateValue('inspector-dim-w', Math.round(target.getScaledWidth())); updateValue('inspector-dim-h', Math.round(target.getScaledHeight())); updateValue('inspector-opacity-slider', target.opacity); updateValue('inspector-opacity-input', target.opacity); updateValue('inspector-stroke-width-slider', target.strokeWidth); updateValue('inspector-stroke-width-input', target.strokeWidth); if (target.rx !== undefined) { updateValue('inspector-corner-radius-slider', target.rx); updateValue('inspector-corner-radius-input', target.rx); } }
function refreshInspector(e) { const target = e.target || canvas.getActiveObject(); if (!target) return; if (target.type === 'activeSelection') { inspector.style.display = 'none'; multiInspector.style.display = 'grid'; $('#noSelection').style.display = 'none'; renderMultiSelectInspector(target); } else { multiInspector.style.display = 'none'; inspector.style.display = 'grid'; $('#noSelection').style.display = 'none'; renderSingleObjectInspector(target); } }
function getCommonPropertyValue(objects, property) { const firstValue = objects[0][property]; for (let i = 1; i < objects.length; i++) { if (objects[i][property] !== firstValue) return ''; } return firstValue; }
function setCommonPropertyValue(objects, property, value) { objects.forEach(obj => obj.set(property, value)); canvas.renderAll(); saveState(); }
function renderMultiSelectInspector(selection) { multiInspector.innerHTML = ''; const objects = selection.getObjects(); multiInspector.appendChild(section('Actions', [ buttonRow('Group', () => { if(selection.size() > 1) selection.toGroup(); canvas.requestRenderAll(); }), buttonRow('Remove', () => { objects.forEach(obj => canvas.remove(obj)); canvas.discardActiveObject().renderAll(); }) ])); multiInspector.appendChild(section('Common', [ sliderRow('Opacity', getCommonPropertyValue(objects, 'opacity') ?? 1, (v) => setCommonPropertyValue(objects, 'opacity', v), { min: 0, max: 1, step: 0.01 }), colorInputRow('Stroke Color', getCommonPropertyValue(objects, 'stroke') ?? '', v => setCommonPropertyValue(objects, 'stroke', v)), sliderRow('Stroke Width', getCommonPropertyValue(objects, 'strokeWidth') ?? 0, (v) => setCommonPropertyValue(objects, 'strokeWidth', v), { min: 0, max: 50, step: 1 }) ])); multiInspector.appendChild(section('Align', [alignToPageButtons()])); }
function renderSingleObjectInspector(o) {
    inspector.innerHTML = ''; 
    const actions = [];
    if (o.type === 'group' && !o.isTable) actions.push(buttonRow('Ungroup', () => o.toActiveSelection()));
    actions.push(buttonRow('Remove', () => canvas.remove(o)));
    inspector.appendChild(section('Actions', actions));
    inspector.appendChild(section('Data Links', [ buttonRow(`Manage Links (${getBindingsFor(o).length})`, () => { selectedObjectForManager = o; openDataLinksManager(); }) ]));
    if (o.type === 'image') inspector.appendChild(section('Image', [buttonRow('Crop Image', () => openVisualCropper(o))]));
    if (['rect', 'image', 'circle', 'triangle', 'polygon', 'svg', 'path'].includes(o.type)) { const shapeProps = []; if (['rect', 'image'].includes(o.type)) shapeProps.push(sliderRow('Corner Radius', o.rx ?? 0, (v) => o.set({rx: v, ry: v}), {min: 0, max: Math.min(o.width, o.height)/2, step: 1})); inspector.appendChild(section('Shape Properties', shapeProps)); }
    if (['rect', 'triangle', 'circle', 'polygon', 'path', 'svg'].includes(o.type)) { inspector.appendChild(section('Fill', [colorInputRow('Color', o.fill, v => o.set({ fill: v })), buttonRow('Fill with Image', () => { editingFillObject = o; $('#imageFillUpload').click(); })])); $('#imageFillUpload').onchange = e => { if (!e.target.files?.[0] || !editingFillObject) return; const reader = new FileReader(); reader.onload = ev => { fabric.Image.fromURL(ev.target.result, img => { editingFillObject.set('fill', new fabric.Pattern({ source: img.getElement(), repeat: 'repeat' })); canvas.renderAll(); saveState(); }, { crossOrigin: 'anonymous' }); }; reader.readAsDataURL(e.target.files[0]); e.target.value = ''; }; }
    if (o.isTable) inspector.appendChild(section('Table', [ colorInputRow('Stroke Color', o.getObjects()[0].stroke, v => o.forEachObject(cell => cell.set({stroke:v}))), sliderRow('Stroke Width', o.getObjects()[0].strokeWidth, v => o.forEachObject(cell => cell.set({strokeWidth:v})), {min:0, max: 20, step: 0.5}) ]));
    if (o.type === 'textbox') inspector.appendChild(section('Text', [ inputRow('Content', o.text, v => o.set({text:v}), 'textarea'), inputRow('Font Size', o.fontSize, v => o.set({fontSize:parseFloat(v)})), selectRow('Font Family', FONT_LIST, o.fontFamily, v => o.set({fontFamily:v})), colorInputRow('Fill Color', o.fill, v => o.set({fill:v})), selectRow('Alignment', ['left','center','right','justify'], o.textAlign, v => o.set({textAlign:v})) ]));
    inspector.appendChild(section('Common', [ xyInputRow('Position', {x: o.left, y: o.top}, (p) => o.set({left: p.x, top: p.y})), xyInputRow('Dimensions', {w: o.getScaledWidth(), h: o.getScaledHeight()}, (d) => {o.scaleToWidth(d.w); o.scaleToHeight(d.h);}), sliderRow('Opacity', o.opacity ?? 1, (v) => o.set({opacity: v}), {min: 0, max: 1, step: 0.01}), colorInputRow('Stroke Color', o.stroke ?? '', v => o.set({stroke: v})), sliderRow('Stroke Width', o.strokeWidth ?? 0, (v) => o.set({strokeWidth: v}), {min: 0, max: 50, step: 1}), ]));
    inspector.appendChild(section('Align to Page', [alignToPageButtons()]));
}
function renderPageInspector() { if (!pageRect) pageRect = canvas.getObjects().find(o => o.oid === 'pageRect'); if (!pageRect) return; const container = $('#pageInspector'); container.innerHTML = ''; const pageProps = section('Page Style', [ colorInputRow('Background Color', pageRect.fill, v => pageRect.set({fill: v})), buttonRow('Set Background Image', () => { editingFillObject = pageRect; $('#imageFillUpload').click(); }) ]); container.appendChild(pageProps); }
$('#loadTemplateBtnPage').onclick = () => {};
function section(title, rows){ const w=document.createElement('div'); w.className='stack'; w.innerHTML=`<h3>${title}</h3>`; const g=document.createElement('div'); g.className='prop-grid'; rows.forEach(r => g.appendChild(r)); w.appendChild(g); return w; }
function inputRow(label, value, onChange, type = 'text') { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const i = document.createElement(type === 'textarea' ? 'textarea' : 'input'); if (type !== 'textarea') i.type = type; i.value = value ?? ''; i.oninput = () => { onChange(i.value); canvas.requestRenderAll(); }; i.onchange = () => saveState(); if (type === 'textarea') i.rows = 3; w.appendChild(i); return w; }
function xyInputRow(label, values, onChange) { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const r = document.createElement('div'); r.className = 'row'; const x = document.createElement('input'); x.type = 'number'; x.value = Math.round(values.x ?? values.w ?? 0); const y = document.createElement('input'); y.type = 'number'; y.value = Math.round(values.y ?? values.h ?? 0); if (label === 'Position') { x.id = 'inspector-pos-x'; y.id = 'inspector-pos-y'; } else if (label === 'Dimensions') { x.id = 'inspector-dim-w'; y.id = 'inspector-dim-h'; } const update = () => { const v = label === 'Position' ? { x: parseFloat(x.value), y: parseFloat(y.value) } : { w: parseFloat(x.value), h: parseFloat(y.value) }; onChange(v); canvas.requestRenderAll(); updateLiveInspector({ target: canvas.getActiveObject() }); }; const finalUpdate = () => { update(); saveState(); }; x.oninput = update; y.oninput = update; x.onchange = finalUpdate; y.onchange = finalUpdate; r.append(x, y); w.appendChild(r); return w; }
function sliderRow(label, value, onChange, {min=0, max=100, step=1}, idPrefix = null) { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const r = document.createElement('div'); r.className = 'slider-wrapper'; const s = document.createElement('input'); s.type = 'range'; s.min = min; s.max = max; s.step = step; s.value = value; const n = document.createElement('input'); n.type = 'number'; n.min = min; n.max = max; n.step = step; n.value = value; const idBase = idPrefix || 'inspector-' + label.toLowerCase().replace(/\s+/g, '-'); s.id = idBase + '-slider'; n.id = idBase + '-input'; const update = (val) => { onChange(val); canvas.requestRenderAll(); }; s.oninput = () => { n.value = s.value; update(parseFloat(s.value)); }; n.oninput = () => { s.value = n.value; update(parseFloat(n.value)); }; if (!idPrefix) { s.onchange = () => saveState(); n.onchange = () => saveState(); } r.append(s, n); w.appendChild(r); return w; }
function selectRow(label, opts, val, onChange) { const w=document.createElement('div'); w.className='stack full-width'; w.innerHTML=`<label>${label}</label>`; const s=document.createElement('select'); opts.forEach(opt=>s.innerHTML+=`<option value="${opt}" ${opt==val?'selected':''}>${opt}</option>`); s.onchange=e=>{ onChange(e.target.value); canvas.renderAll(); saveState(); }; w.appendChild(s); return w; }
function buttonRow(label, onClick) { const w=document.createElement('div');w.className='full-width'; const b=document.createElement('button');b.className='btn ghost'; b.textContent=label; b.onclick=onClick; b.style.width='100%'; w.appendChild(b); return w;}
function colorInputRow(label, value, onChange) { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const r = document.createElement('div'); r.className = 'color-picker-wrapper'; const t = document.createElement('input'); t.type = 'text'; t.value = value; const c = document.createElement('input'); c.type = 'color'; c.value = value; const update = (val) => { onChange(val); canvas.requestRenderAll(); }; t.oninput = () => { c.value = t.value; update(t.value); }; c.oninput = () => { t.value = c.value; update(c.value); }; t.onchange = () => saveState(); c.onchange = () => saveState(); r.append(t, c); w.appendChild(r); return w; }

// --- VISUAL CROPPER ---
function initializeVisualCropper() { const modal = $('#visualCropModal'); const container = $('#visualCropContainer'); cropCanvas = new fabric.Canvas('cropCanvas', { selection: false, backgroundColor: '#222' }); new ResizeObserver(() => { const { width, height } = container.getBoundingClientRect(); cropCanvas.setWidth(width).setHeight(height); }).observe(container); $('#closeVisualCropModal').addEventListener('click', closeVisualCropper); $('#cancelCropBtn').addEventListener('click', closeVisualCropper); $('#applyCropBtn').addEventListener('click', applyCrop); }
function openVisualCropper(imageObject) { croppingImage = imageObject; const modal = $('#visualCropModal'); modal.style.display = 'flex'; cropCanvas.clear(); const { width: cW, height: cH } = $('#visualCropContainer').getBoundingClientRect(); cropCanvas.setWidth(cW).setHeight(cH); const imgEl = croppingImage.getElement(); const scale = Math.min(cW / imgEl.naturalWidth, cH / imgEl.naturalHeight) * 0.8; const imgInstance = new fabric.Image(imgEl, { selectable: false, evented: false, scaleX: scale, scaleY: scale }); cropCanvas.add(imgInstance); cropCanvas.centerObject(imgInstance); cropCanvas.add(new fabric.Rect({ fill: 'rgba(0,0,0,0.3)', width: cW, height: cH, selectable: false, evented: false })); const cropBox = new fabric.Rect({ left: imgInstance.left, top: imgInstance.top, width: imgInstance.getScaledWidth(), height: imgInstance.getScaledHeight(), fill: 'transparent', stroke: '#fff', strokeWidth: 2, cornerColor: '#fff', cornerSize: 12, transparentCorners: false, }); cropCanvas.add(cropBox); cropCanvas.setActiveObject(cropBox); cropCanvas.renderAll(); }
function closeVisualCropper() { $('#visualCropModal').style.display = 'none'; croppingImage = null; cropCanvas.clear(); }
function applyCrop() { if (!croppingImage || !cropCanvas.getActiveObject()) return; const cropBox = cropCanvas.getActiveObject(); const imgInstance = cropCanvas.getObjects('image')[0]; const cropX = (cropBox.left - imgInstance.left) / imgInstance.scaleX; const cropY = (cropBox.top - imgInstance.top) / imgInstance.scaleY; const width = cropBox.getScaledWidth() / imgInstance.scaleX; const height = cropBox.getScaledHeight() / imgInstance.scaleY; croppingImage.set({ cropX, cropY, width, height }); croppingImage.scaleToWidth(cropBox.getScaledWidth()); canvas.renderAll(); saveState(); closeVisualCropper(); }

// --- ALIGNMENT & DATA BINDING ---
function alignToPageButtons() { const container = document.createElement('div'); container.className = 'align-buttons full-width'; const icons = { left: '<svg viewBox="0 0 24 24"><path d="M18 21V3h2v18h-2zm-4 0V3h2v18h-2zM4 21h6V3H4v18z" fill="currentColor"/></svg>', h_center: '<svg viewBox="0 0 24 24"><path d="M4 21V3h2v18H4zm14 0V3h2v18h-2zM9 21V3h6v18H9z" fill="currentColor"/></svg>', right: '<svg viewBox="0 0 24 24"><path d="M4 21V3h2v18H4zm4 0V3h2v18H8zm12 0h-6V3h6v18z" fill="currentColor"/></svg>', top: '<svg viewBox="0 0 24 24" transform="rotate(90)"><path d="M18 21V3h2v18h-2zm-4 0V3h2v18h-2zM4 21h6V3H4v18z" fill="currentColor"/></svg>', v_center: '<svg viewBox="0 0 24 24" transform="rotate(90)"><path d="M4 21V3h2v18H4zm14 0V3h2v18h-2zM9 21V3h6v18H9z" fill="currentColor"/></svg>', bottom: '<svg viewBox="0 0 24 24" transform="rotate(90)"><path d="M4 21V3h2v18H4zm4 0V3h2v18H8zm12 0h-6V3h6v18z" fill="currentColor"/></svg>' }; const actions = { left: o => o.set({ originX: 'left', left: pageRect.left }), h_center: o => o.set({ originX: 'center', left: pageRect.left + pageRect.width / 2 }), right: o => o.set({ originX: 'left', left: pageRect.left + pageRect.width - o.getScaledWidth() }), top: o => o.set({ originY: 'top', top: pageRect.top }), v_center: o => o.set({ originY: 'center', top: pageRect.top + pageRect.height / 2 }), bottom: o => o.set({ originY: 'top', top: pageRect.top + pageRect.height - o.getScaledHeight() }) }; Object.keys(icons).forEach(key => { const btn = document.createElement('button'); btn.className = 'btn ghost'; btn.innerHTML = icons[key]; btn.onclick = () => { const active = canvas.getActiveObject(); if (active && pageRect) { actions[key](active); active.setCoords(); canvas.renderAll(); saveState(); } }; container.appendChild(btn); }); return container; }
function propertyOptionsFor(o){ const common=['Opacity','Stroke Color','Stroke Width']; if(o.isTable) return ['Stroke Color', 'Stroke Width']; if(o.type==='textbox')return['Text Content','Font Family','Font Size','Fill Color',...common]; if(['rect','image'].includes(o.type))common.push('Corner Radius'); if(['rect','circle','triangle','polygon','path'].includes(o.type))return['Color','Image Fill URL',...common]; return common; }
function defaultPropertyFor(o){ return o.type==='textbox'?'Text Content':'Color';}
function getBindingsFor(o){ const id=ensureId(o); if(!bindings.has(id)) bindings.set(id,[]); return bindings.get(id); }
function saveBinding(o,b){ const arr=getBindingsFor(o); if(!arr.includes(b)) arr.push(b); }
function removeBinding(o,b){ const arr=getBindingsFor(o); const i=arr.indexOf(b); if(i>-1) arr.splice(i,1); }
function ensureId(o){ if(!o.oid) o.oid=`obj_${Date.now()}_${Math.random()}`; return o.oid; }
canvas.on('object:added', (e) => ensureId(e.target));
const modal = $('#modalBackdrop'); function openModal(){ if(!workbook){ alert('Load a data file first.'); return; } modal.style.display='flex'; renderColumnList(); } function closeModal(){ modal.style.display='none'; } $('#closeModal').addEventListener('click', closeModal); $('#columnSearch').addEventListener('input', renderColumnList); $('#confirmColumn').addEventListener('click', () => { const sel = $('.col-item[aria-selected="true"]'); if (!sel) return alert('Select a column.'); const col = sel.dataset.name; $('#startCell').value = $('#modalStartCell').value; if (selectedColumn) { selectedColumn.binding.column = col; if (dataLinksManagerModal.style.display === 'flex') renderDataLinksManager(); } closeModal(); });
function renderColumnList(){ const list=$('#colList'); list.innerHTML=''; const q=($('#columnSearch').value||'').toLowerCase(); headers.filter(h=>h.toLowerCase().includes(q)).forEach(h=>{ const item=document.createElement('div'); item.className='col-item'; item.dataset.name=h; const samples=dataRows.slice(0,5).map(r=>r[h]).filter(Boolean).slice(0,3).join(' · '); item.innerHTML=`<b>${h}</b><div class="muted">Samples: ${samples||'—'}</div>`; item.onclick=()=>{document.querySelectorAll('.col-item').forEach(x=>x.removeAttribute('aria-selected')); item.setAttribute('aria-selected','true');}; list.appendChild(item); }); }
const dataLinksManagerModal = $('#dataLinksManagerModal'); const openDataLinksManagerBtn = $('#openDataLinksManagerBtn'); const closeDataLinksManagerModalBtn = $('#closeDataLinksManagerModal'); let selectedObjectForManager = null;
function openDataLinksManager() { renderDataLinksManager(); dataLinksManagerModal.style.display = 'flex'; } function closeDataLinksManager() { dataLinksManagerModal.style.display = 'none'; selectedObjectForManager = null; }
openDataLinksManagerBtn.addEventListener('click', openDataLinksManager); closeDataLinksManagerModalBtn.addEventListener('click', closeDataLinksManager);
function renderDataLinksManager() { const objectsList = $('#dataLinksObjectsList'); objectsList.innerHTML = ''; const objects = canvas.getObjects().filter(o => o.oid !== 'pageRect' && !o.excludeFromExport); if (objects.length === 0) { objectsList.innerHTML = '<p class="muted" style="font-size:12px; text-align:center;">No objects on canvas.</p>'; $('#dataLinksEditorContent').innerHTML = '<p class="muted" style="text-align:center; padding-top: 24px;">Add an object to the canvas to create a data link.</p>'; return; } objects.forEach(obj => { const item = document.createElement('div'); item.className = 'data-links-object-item'; item.setAttribute('data-oid', ensureId(obj)); let name = obj.type; if (obj.type === 'textbox') name = obj.text.substring(0, 25) || 'Textbox'; if (obj.isTable) name = `Table (${obj.rows}x${obj.cols})`; const bindingCount = getBindingsFor(obj).length; item.innerHTML = `<strong>${name}</strong> <br> <span class="muted">${bindingCount} link(s)</span>`; item.addEventListener('click', () => { selectedObjectForManager = obj; document.querySelectorAll('.data-links-object-item').forEach(el => el.removeAttribute('aria-selected')); item.setAttribute('aria-selected', 'true'); renderBindingsForObject(obj); }); objectsList.appendChild(item); }); if (selectedObjectForManager) { const selectedItem = objectsList.querySelector(`[data-oid="${selectedObjectForManager.oid}"]`); if (selectedItem) selectedItem.setAttribute('aria-selected', 'true'); else selectedObjectForManager = null; } if (selectedObjectForManager) renderBindingsForObject(selectedObjectForManager); else $('#dataLinksEditorContent').innerHTML = '<p class="muted" style="text-align:center; padding-top: 24px;">Select an object from the left to manage its data links.</p>'; }
function renderBindingsForObject(obj) { const container = $('#dataLinksEditorContent'); container.innerHTML = ''; const linksWrapper = document.createElement('div'); linksWrapper.className = 'links-list-wrapper'; const header = document.createElement('h4'); header.textContent = 'Active Links'; linksWrapper.appendChild(header); const objectBindings = getBindingsFor(obj); if (objectBindings.length === 0) { linksWrapper.innerHTML += '<p class="muted" style="text-align:center; padding: 16px 0;">No data links configured for this object.</p>'; } else { objectBindings.forEach(b => linksWrapper.appendChild(bindingEditorRow(obj, b))); } const buttonWrapper = document.createElement('div'); buttonWrapper.className = 'add-link-button-wrapper'; const addButton = document.createElement('button'); addButton.className = 'btn'; addButton.textContent = 'Add New Link'; addButton.style.width = '100%'; addButton.onclick = () => { const newBinding = { column: '', property: defaultPropertyFor(obj) }; saveBinding(obj, newBinding); saveState(); renderDataLinksManager(); }; buttonWrapper.appendChild(addButton); container.append(linksWrapper, buttonWrapper); }
function bindingEditorRow(o, b) { const box = document.createElement('div'); box.className = 'stack'; box.style.cssText = 'border:1px solid var(--border);padding:8px;border-radius:8px;margin-top:8px;'; box.appendChild(selectRow('Property', propertyOptionsFor(o), b.property, v => { b.property = v; saveState(); })); const info = document.createElement('div'); info.className = 'muted'; info.textContent = `Linked to: ${b.column || '—'}`; info.style.fontSize = '12px'; const linkBtn = document.createElement('button'); linkBtn.className = 'btn'; linkBtn.textContent = 'Link Column'; linkBtn.onclick = () => { selectedColumn = { object: o, binding: b }; openModal(); }; const delBtn = document.createElement('button'); delBtn.className = 'btn ghost'; delBtn.textContent = 'Remove'; delBtn.onclick = () => { removeBinding(o, b); saveState(); renderDataLinksManager(); }; const btnGroup = document.createElement('div'); btnGroup.className = 'row'; btnGroup.style.marginTop = '8px'; btnGroup.append(linkBtn, delBtn); box.append(info, btnGroup); return box; }

// --- EXPORT ---
async function exportAllRows({asZip, asSinglePdf}) {
    if (!pageRect) pageRect = canvas.getObjects().find(o => o.oid === 'pageRect'); if (!pageRect) { alert('Error: Page object not found. Cannot export.'); return; }
    const startOffset = Math.max(0, parseInt(($('#startCell').value.match(/\d+$/) || [2])[0], 10) - 2);
    let rows = dataRows.slice(startOffset); if (!rows.length) rows = [null];
    const title = ($('#titleInput').value || 'Untitled_Template').trim(); const { width: pageW, height: pageH } = pageRect;
    const pdf = asSinglePdf ? new jsPDF({unit:'px', format:[pageW, pageH]}) : null; const zipFile = asZip ? new JSZip() : null;
    let firstPage = true; const objectsWithBindings = canvas.getObjects().filter(obj => getBindingsFor(obj).length > 0);
    for (let i = 0; i < rows.length; i++) {
        const row = rows[i]; const originalStates = new Map();
        if (row) { objectsWithBindings.forEach(obj => { const bindings = getBindingsFor(obj); bindings.forEach(binding => { const value = row[binding.column]; if (value != null) { if (!originalStates.has(obj.oid)) originalStates.set(obj.oid, {}); const originalProps = originalStates.get(obj.oid); if (binding.property === 'Text Content' && originalProps.text === undefined) originalProps.text = obj.text; if (binding.property.includes('Color') && originalProps.fill === undefined) originalProps.fill = obj.fill; applyBinding(obj, binding.property, value); } }); }); canvas.renderAll(); }
        const dataURL = await generateCanvasForRow(row);
        if (asSinglePdf) { if (!firstPage) pdf.addPage([pageW, pageH]); pdf.addImage(dataURL, 'JPEG', 0, 0, pageW, pageH); firstPage = false; }
        if (asZip) { const pagePdf = new jsPDF({unit:'px', format:[pageW, pageH]}); pagePdf.addImage(dataURL, 'JPEG', 0, 0, pageW, pageH); zipFile.file(`${title}_${i + 1}.pdf`, await pagePdf.output('blob')); }
        if (row) { originalStates.forEach((props, oid) => { const obj = canvas.getObjects().find(o => o.oid === oid); if (obj) obj.set(props); }); canvas.renderAll(); }
    }
    if (asSinglePdf) saveAs(pdf.output('blob'), `${title}.pdf`); if (asZip) saveAs(await zipFile.generateAsync({type:'blob'}), `${title}.zip`);
}

async function exportAsPNG() {
    if (!pageRect) {
        alert('Error: Page object not found. Cannot export.');
        return;
    }

    const title = ($('#titleInput').value || 'Untitled_Template').trim();
    const multiplier = 2; // Export at 2x resolution for better quality

    // Temporarily hide gridlines for a clean export
    const gridLines = canvas.getObjects('line').filter(o => o.excludeFromExport);
    gridLines.forEach(l => l.set({ visible: false }));
    canvas.renderAll();

    // Generate the Data URL from the specific page area
    const dataURL = canvas.toDataURL({
        format: 'png', // Specify the format as png
        multiplier: multiplier,
        left: pageRect.left,
        top: pageRect.top,
        width: pageRect.width,
        height: pageRect.height
    });

    // Restore gridlines on the main canvas
    gridLines.forEach(l => l.set({ visible: true }));
    canvas.renderAll();

    // Trigger the download
    const link = document.createElement('a');
    link.download = `${title}.png`;
    link.href = dataURL;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

async function generateCanvasForRow(row) {
    const { left: pageLeft, top: pageTop, width: pageW, height: pageH } = pageRect || { left: 0, top: 0, width: 768, height: 1024 };
    const multiplier = 2;
    const gridLines = canvas.getObjects('line').filter(o => o.excludeFromExport);
    
    // Temporarily hide gridlines on the main canvas for a clean state
    gridLines.forEach(l => l.set({ visible: false }));
    canvas.renderAll();

    const tmpEl = document.createElement('canvas');
    tmpEl.width = pageW * multiplier;
    tmpEl.height = pageH * multiplier;
    const tmpCanvas = new fabric.StaticCanvas(tmpEl, { backgroundColor: pageRect.fill });

    // Create a list of promises for cloning all objects
    const clonePromises = canvas.getObjects().map(obj => {
        return new Promise(resolve => {
            if (obj.oid === 'pageRect' || obj.excludeFromExport) {
                resolve(null); // Resolve with null for objects we're skipping
                return;
            }
            // Use the asynchronous clone method
            obj.clone(clone => {
                 const center = obj.getCenterPoint();
                 const relX = (center.x - pageLeft) * multiplier;
                 const relY = (center.y - pageTop) * multiplier;
                 clone.set({
                     left: relX,
                     top: relY,
                     originX: 'center',
                     originY: 'center',
                     scaleX: (clone.scaleX || 1) * multiplier,
                     scaleY: (clone.scaleY || 1) * multiplier
                 });
                 resolve(clone);
            }, ['oid', 'isTable', 'rows', 'cols']); // Pass properties to clone
        });
    });

    // Wait for all cloning operations to complete
    const clonedObjects = await Promise.all(clonePromises);

    // Add the successfully cloned objects to the temporary canvas
    clonedObjects.forEach(clone => {
        if (clone) {
            tmpCanvas.add(clone);
        }
    });

    // Render the temporary canvas and get the data URL
    tmpCanvas.renderAll();
    const dataURL = tmpCanvas.toDataURL({ format: 'jpeg', quality: 0.9 });

    // Restore the gridlines on the main canvas
    gridLines.forEach(l => l.set({ visible: true }));
    canvas.renderAll();

    return dataURL;
}
function parseDims(s){ const m=String(s).match(/^(\d+)[xX](\d+)$/i); return m?{w:+m[1],h:+m[2]}:null; }
function applyBinding(o,prop,val){ val=String(val).trim(); const numVal=parseFloat(val); switch(prop){ case'Text Content':if(o.type==='textbox')o.set({text:val});break; case'Font Family':if(o.type==='textbox')o.set({fontFamily:val});break; case'Font Size':if(o.type==='textbox')o.set({fontSize:numVal});break; case'Fill Color':case'Color':o.set({fill:val});break; case'Opacity':o.set({opacity:numVal});break; case'Dimensions':{const d=parseDims(val);if(d){o.scaleToWidth(d.w);o.scaleToHeight(d.h);}break;} case'Stroke Color':o.set({stroke:val});break; case'Stroke Width':o.set({strokeWidth:numVal});break; case'Corner Radius':if('rx'in o)o.set({rx:numVal,ry:numVal});break; case'Image Fill URL':fabric.Image.fromURL(val,img=>o.set('fill',new fabric.Pattern({source:img.getElement()})),{crossOrigin:'anonymous'});break; } }

// --- HISTORY & UTILS ---
function undo() { if (historyIndex > 0) { historyLocked = true; historyIndex--; canvas.loadFromJSON(historyStack[historyIndex], restoreCanvasStateAfterLoad); updateHistoryButtons(); } }
function redo() { if (historyIndex < historyStack.length - 1) { historyLocked = true; historyIndex++; canvas.loadFromJSON(historyStack[historyIndex], restoreCanvasStateAfterLoad); updateHistoryButtons(); } }
function updateHistoryButtons(){ $('#undoBtn').disabled=historyIndex<=0; $('#redoBtn').disabled=historyIndex>=historyStack.length-1; }
$('#undoBtn').onclick=undo; $('#redoBtn').onclick=redo;
function restoreCanvasStateAfterLoad() { pageRect = canvas.getObjects().find(o => o.oid === 'pageRect'); if (pageRect) { pageRect.set({ selectable: false, evented: false, hasControls: false, hasBorders: false, lockMovementX: true, lockMovementY: true, lockScalingX: true, lockScalingY: true, lockRotation: true }); } drawGrid(); renderLayers(); canvas.renderAll(); historyLocked = false; }
function copy() { const activeObject = canvas.getActiveObject(); if (!activeObject) return; activeObject.clone(cloned => { _clipboard = cloned; }, ['oid']); }
function cut() { copy(); const activeObjects = canvas.getActiveObjects(); if (activeObjects.length) { activeObjects.forEach(obj => canvas.remove(obj)); canvas.discardActiveObject().renderAll(); } }
function paste() { if (!_clipboard) return; _clipboard.clone(clonedObj => { canvas.discardActiveObject(); clonedObj.set({ left: clonedObj.left + 20, top: clonedObj.top + 20, evented: true, }); if (clonedObj.type === 'activeSelection') { clonedObj.canvas = canvas; clonedObj.forEachObject(obj => { obj.oid = `obj_${Date.now()}_${Math.random()}`; canvas.add(obj); }); clonedObj.setCoords(); } else { clonedObj.oid = `obj_${Date.now()}_${Math.random()}`; canvas.add(clonedObj); } canvas.setActiveObject(clonedObj); canvas.requestRenderAll(); saveState(); }, ['oid']); }
function renderLayers() { const list = $('#layersList'); if (!list) return; list.innerHTML = ''; const activeObj = canvas.getActiveObject(); const objects = canvas.getObjects().filter(o => o.oid !== 'pageRect' && !o.excludeFromExport && !o.isSnapLine);  if (objects.length === 0) {list.innerHTML = '<p class="muted" style="text-align: center; padding: 24px 0; font-size: 13px;">Add an object to the canvas to see the layers.</p>'; return;} objects.slice().reverse().forEach(obj => { const item = document.createElement('div'); item.className = 'layer-item'; item.dataset.locked = !!obj.locked; if (obj === activeObj || (activeObj?.type === 'activeSelection' && activeObj.getObjects().includes(obj))) { item.classList.add('active'); } item.onclick = () => { if (!obj.locked) canvas.setActiveObject(obj).renderAll(); }; let name = obj.type; if (obj.type === 'textbox') name = obj.text.substring(0, 20) || 'Textbox'; if (obj.isTable) name = `Table (${obj.rows}x${obj.cols})`; item.innerHTML = `<span>${name}</span><div class="layer-actions"><button title="Lock/Unlock" class="btn ghost btn-lock"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">${obj.locked ? '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>' : '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>'}</svg></button><button title="Bring Forward" class="btn ghost btn-fwd"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M6 15l6-6 6 6"/></svg></button><button title="Send Backward" class="btn ghost btn-bwd"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M6 9l6 6 6-6"/></svg></button></div>`; item.querySelector('.btn-lock').onclick = (e) => { e.stopPropagation(); toggleLock(obj); }; item.querySelector('.btn-fwd').onclick = (e) => { e.stopPropagation(); canvas.bringForward(obj); renderLayers(); saveState(); }; item.querySelector('.btn-bwd').onclick = (e) => { e.stopPropagation(); canvas.sendBackwards(obj); renderLayers(); saveState(); }; list.appendChild(item); }); }
function toggleLock(obj) { obj.locked = !obj.locked; obj.selectable = !obj.locked; obj.evented = !obj.locked; if(obj.locked) canvas.discardActiveObject(); canvas.renderAll(); renderLayers(); saveState(); }
function centerAndFitPage(){ if(!pageRect)return; const{width:wrapperW,height:wrapperH}=canvasWrapper.getBoundingClientRect(); const pageW=pageRect.width; const pageH=pageRect.height; const zoom=Math.min(wrapperW/pageW,wrapperH/pageH)*0.95; canvas.setZoom(zoom); const center=pageRect.getCenterPoint(); const vpt=[zoom,0,0,zoom,(wrapperW/2)-center.x*zoom,(wrapperH/2)-center.y*zoom]; canvas.setViewportTransform(vpt); $('#zoomLevel').textContent=`Zoom: ${Math.round(zoom*100)}%`; canvas.renderAll(); }
$('#centerViewBtn').onclick=centerAndFitPage;
window.addEventListener('keydown', e=>{ if(e.target.tagName==='INPUT'||e.target.tagName==='TEXTAREA')return; const isCtrl=e.ctrlKey||e.metaKey; const activeObj = canvas.getActiveObject(); if(isCtrl&&e.key==='z'){e.preventDefault();undo();} if(isCtrl&&e.key==='y'){e.preventDefault();redo();} if(isCtrl&&e.key==='c'){e.preventDefault();copy();} if(isCtrl&&e.key==='x'){e.preventDefault();cut();} if(isCtrl&&e.key==='v'){e.preventDefault();paste();} if(isCtrl&&e.key.toLowerCase()==='g'){ e.preventDefault(); if(activeObj && activeObj.type === 'activeSelection') activeObj.toGroup(); } if(isCtrl&&e.shiftKey&&e.key.toLowerCase()==='g'){ e.preventDefault(); if(activeObj && activeObj.type === 'group') activeObj.toActiveSelection(); } if (e.key.startsWith('Arrow') && activeObj) { e.preventDefault(); const amount = e.shiftKey ? 10 : 1; switch(e.key) { case 'ArrowUp': activeObj.top -= amount; break; case 'ArrowDown': activeObj.top += amount; break; case 'ArrowLeft': activeObj.left -= amount; break; case 'ArrowRight': activeObj.left += amount; break; } activeObj.setCoords(); canvas.renderAll(); } if(e.key==='Delete'||e.key==='Backspace'){ const activeObjects=canvas.getActiveObjects(); if(activeObjects.length){ activeObjects.forEach(obj=>canvas.remove(obj)); canvas.discardActiveObject().renderAll(); } } });
window.addEventListener('keyup', e => { if (e.key.startsWith('Arrow') && canvas.getActiveObject()) { saveState(); } });
$('#exportZipBtn').addEventListener('click',()=>exportAllRows({asZip:true})); $('#exportSinglePdfBtn').addEventListener('click',()=>exportAllRows({asSinglePdf:true})); $('#exportPngBtn').addEventListener('click', exportAsPNG);

// --- AI ASSISTANT ---
const aiBubble = $('#ai-bubble'); 
const aiModal = $('#aiModalBackdrop'); 
const aiCloseBtn = $('#aiCloseModal'); 
const aiSendBtn = $('#aiSendBtn'); 
const aiApiKeyInput = $('#aiApiKey'); 
const aiPromptInput = $('#aiPrompt'); 
const aiSendBtnText = $('#aiSendBtnText'); 
const aiLoadingSpinner = $('#aiLoadingSpinner'); 
const pastedImageContainer = $('#pasted-image-container'); 
const pastedImage = $('#pasted-image'); 
let pastedImageData = null; 

const savedApiKey = localStorage.getItem('googleAiApiKey'); 
if (savedApiKey) { 
 aiApiKeyInput.value = savedApiKey; 
} 

// Handle the paste event 
aiPromptInput.addEventListener('paste', (event) => { 
 const items = (event.clipboardData || event.originalEvent.clipboardData).items; 
 for (const index in items) { 
 const item = items[index]; 
 if (item.kind === 'file') { 
 const blob = item.getAsFile(); 
 const reader = new FileReader(); 
 reader.onload = (event) => { 
 pastedImageData = event.target.result; 
 pastedImage.src = pastedImageData; 
 pastedImageContainer.style.display = 'block'; 
 }; 
 reader.readAsDataURL(blob); 
 } 
 } 
}); 

aiBubble.addEventListener('click', () => { aiModal.style.display = 'flex'; }); 
aiCloseBtn.addEventListener('click', () => { aiModal.style.display = 'none'; }); 
aiModal.addEventListener('click', (e) => { if (e.target === aiModal) aiModal.style.display = 'none'; }); 

aiSendBtn.addEventListener('click', async () => { 
 const apiKey = aiApiKeyInput.value.trim(); 
 const userPrompt = aiPromptInput.value.trim(); 
 if (!apiKey) { alert('Please enter your Google AI Studio API key.'); return; } 
 if (!userPrompt && !pastedImageData) { alert('Please enter a request or paste an image.'); return; }
 localStorage.setItem('googleAiApiKey', apiKey); 

 aiSendBtn.disabled = true; 
 aiSendBtnText.style.display = 'none'; 
 aiLoadingSpinner.style.display = 'inline-flex'; 
const fullPrompt = `
# AI Template Generation Instructions

## 1. Core Principles

You are an AI assistant for a web-based template editor. Your primary task is to create templates based on user requests. Adhere to the following principles to ensure a high-quality outcome:

*   **Readability and Layout**: Ensure that no objects improperly overlap. All text and important elements must be clearly readable and accessible. Arrange elements in a professional and aesthetically pleasing manner.
*   **Creative Freedom**: While adhering to the user's request, allow for creative interpretations to enhance the design. This includes using appropriate decorations, layouts, and color schemes that align with the context.
*   **Professional Outcome**: The final template should look polished and professional. Pay attention to alignment, spacing, and font choices.

## 2. Dynamic Properties

Adapt the template's properties based on the user's input and the context of the request:

*   **Page Dimensions**: Adjust the page.width and page.height to a suitable size that aligns with the context of the user's request (e.g., a business card template will have different dimensions than a poster).
*   **File Name**: Generate a descriptive and relevant page.title based on the user's prompt.
*   **Background Color**: Set an appropriate canvas.background color that complements the template's purpose. You can also use a full-page rectangle as the background layer.
*   **Decorative Shapes**: Use shapes like rectangles, circles, and lines to add decorative elements, borders, or to structure the layout.

## 3. Data Bindings

If the user's prompt mentions specific column names or fields, you must set up bindings. The bindings array connects canvas objects to data columns.

The structure for a binding is: ["object_id", [{"column": "column_name", "property": "property_name"}]]

*   object_id: The oid of the canvas object to be bound.
*   column_name: The name of the data column specified by the user in their prompt.
*   property_name: The object property to be updated by the data from the column.

Here are the available properties for binding:

*   **Text Properties**:
    *   Text Content
    *   Font Family
    *   Font Size
    *   Fill Color
    *   Opacity
    *   Stroke Color
    *   Stroke Width
*   **Shape Properties**:
    *   Fill
    *   Fill Color
    *   Opacity
    *   Stroke Color
    *   Stroke Width

**Example:**

If the user says, "The main text should come from the 'product_description' column," you would identify the oid of the main text object (e.g., "analysis_text") and create the following binding:

"bindings": [
  ["analysis_text", [{"column": "product_description", "property": "Text Content"}]]
]
4. JSON Structure and Object Definitions
You MUST respond ONLY with the updated Fabric.js JSON object. Do not add any explanatory text or markdown formatting.
4.1. Root Structure
All templates must adhere to the following root structure:

{
  "page": {
    "title": "[GENERATE A CONTEXTUAL TITLE]",
    "width": "[USER_PAGE_WIDTH]",
    "height": "[USER_PAGE_HEIGHT]"
  },
  "canvas": {
    "version": "5.3.0",
    "objects": [],
    "background": "transparent"
  },
  "bindings": []
}
The first object in canvas.objects MUST be the page rectangle with the oid "pageRect". This object defines the page size and background color.
The page should always be selectable False
4.2. Common Object Properties
Every object in the canvas.objects array MUST include these properties:
{
  "type": "[rect|textbox|line|circle|image|path|group]",
  "version": "5.3.0",
  "originX": "left",
  "originY": "top",
  "left": 0,
  "top": 0,
  "width": 0,
  "height": 0,
  "fill": "#000000",
  "stroke": null,
  "strokeWidth": 1,
  "strokeDashArray": null,
  "strokeLineCap": "butt",
  "strokeDashOffset": 0,
  "strokeLineJoin": "miter",
  "strokeUniform": false,
  "strokeMiterLimit": 4,
  "scaleX": 1,
  "scaleY": 1,
  "angle": 0,
  "flipX": false,
  "flipY": false,
  "opacity": 1,
  "shadow": null,
  "visible": true,
  "backgroundColor": "",
  "fillRule": "nonzero",
  "paintFirst": "fill",
  "globalCompositeOperation": "source-over",
  "skewX": 0,
  "skewY": 0,
  "oid": "unique_id"
}
4.3. Object Type Examples
Rectangle (rect)
{
  "type": "rect",
  "oid": "rect",
  "left": 0,
  "top": 0,
  "width": 768,
  "height": 1024,
  "fill": "#f8f8f8",
  "stroke": "transparent",
  "strokeWidth": 0
}
Textbox (textbox)
{
  "type": "textbox",
  "oid": "graph_title",
  "left": 384,
  "top": 80,
  "width": 600,
  "height": 102.51,
  "text": "Global Car Production Over Time",
  "fontSize": 42,
  "fontWeight": "bold",
  "fontFamily": "Roboto Slab",
  "fill": "#2c3e50",
  "textAlign": "center",
  "originX": "center",
  "originY": "top",
  "styles": []
}
Line (line)
{
  "type": "line",
  "oid": "x_axis",
  "left": 120,
  "top": 650,
  "width": 500,
  "height": 0,
  "stroke": "#bdc3c7",
  "strokeWidth": 2,
  "x1": -250,
  "y1": 0,
  "x2": 250,
  "y2": 0
}
5. Final Output Checklist
Before generating the final JSON, ensure the following:
The entire response is a single, valid JSON object.
The page object has a relevant title, width, and height.
All objects in the canvas.objects array have unique oids.
All required properties for each object type are present.
Text objects have an empty styles array ([]).
The bindings array is correctly populated if the user specified column names.
The overall design is professional and adheres to the user's request.

## 6. Icons

You have access to the full [Lucide](https://lucide.dev) icon set.  
All icons are available in Supabase storage at:

**Base URL**  
https://mzdhdmfjwdpolrxraqtv.supabase.co/storage/v1/object/public/elements/icons/

**File pattern**  
Each icon corresponds to its Lucide filename (kebab-case) with .svg extension.  

Examples:  
- arrow-right → https://mzdhdmfjwdpolrxraqtv.supabase.co/storage/v1/object/public/elements/icons/arrow-right.svg  
- check → https://mzdhdmfjwdpolrxraqtv.supabase.co/storage/v1/object/public/elements/icons/check.svg  
- star → https://mzdhdmfjwdpolrxraqtv.supabase.co/storage/v1/object/public/elements/icons/star.svg  

**Usage rules**  
- Treat all icons as SVGs.  
- Use the full URL as the src when creating an icon object.  
- Icons are monochrome by default; apply fill or stroke styles to match design.  

User Request: "${userPrompt}""
`;

try {
    const parts = [ { text: fullPrompt } ];
    if (pastedImageData) {
        parts.push({
            inline_data: {
                mime_type: pastedImageData.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/)[1],
                data: pastedImageData.split(',')[1]
            }
        });
    }
    const response = await fetch(
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent",
        {
            method: "POST",
            headers: { "Content-Type": "application/json", "X-goog-api-key": apiKey, },
            body: JSON.stringify({ contents: [{ parts: parts }] }),
        }
    );
    if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`API Error: ${response.status} - ${errorData.error?.message || "Unknown error"}`);
    }
    const data = await response.json();
    let aiResponseText = data.candidates[0].content.parts[0].text;
    aiResponseText = aiResponseText.replace(/^```json\s*|```$/g, "").trim();
    const newCanvasState = JSON.parse(aiResponseText);
    if (newCanvasState.page) {
        $('#titleInput').value = newCanvasState.page.title || 'Untitled Template';
        $('#pageWidth').value = newCanvasState.page.width || 768;
        $('#pageHeight').value = newCanvasState.page.height || 1024;
        if (typeof pageRect !== 'undefined' && pageRect) {
            pageRect.set({
                width: parseInt(newCanvasState.page.width, 10),
                height: parseInt(newCanvasState.page.height, 10)
            });
        }
    }
    if (newCanvasState.bindings) {
        bindings = new Map(newCanvasState.bindings);
    }
    const canvasDataToLoad = newCanvasState.canvas || newCanvasState;
    historyLocked = true;
    canvas.loadFromJSON(canvasDataToLoad, () => {
        restoreCanvasStateAfterLoad();
        centerAndFitPage();
        historyLocked = false;
        saveState();
        aiModal.style.display = "none";
    });
} catch (error) {
    console.error("AI Assistant Error:", error);
    alert(`An error occurred: ${error.message}`);
} finally {
    aiSendBtn.disabled = false;
    aiSendBtnText.style.display = 'inline-block';
    aiLoadingSpinner.style.display = 'none';
    pastedImageContainer.style.display = 'none';
    pastedImage.removeAttribute('src');
    pastedImageData = null;
}
});

// --- LEFT PANEL TABS & ELEMENTS ---
function initializeLeftPanelTabs() {
    const tabButtons = document.querySelectorAll('.panel-tab-btn');
    const tabContents = document.querySelectorAll('.panel-tab-content');

    tabButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            // Deactivate all tabs and content panels
            tabButtons.forEach(b => b.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));

            // Activate the clicked tab
            btn.classList.add('active');

            // Find and activate the correct content panel using the robust data-target attribute
            const targetId = btn.dataset.target;
            const targetContent = document.getElementById(targetId);
            if (targetContent) {
                targetContent.classList.add('active');
            } else {
                console.error(`Tab content panel with ID "${targetId}" not found.`);
            }
        });
    });

    const searchInput = $('#element-search');
    if (searchInput) {
        const debouncedSearch = debounce(searchElements, 300);
        searchInput.addEventListener('input', () => debouncedSearch(searchInput.value));
    }

    // Initial load of elements
    searchElements('');
}
let currentPage = 0;
let isLoading = false; // Prevents fetching multiple pages at once
let currentQuery = ''; // Tracks the active search query

const ELEMENTS_PER_PAGE = 50;

/**
 * A helper function to shuffle an array in place using the Fisher-Yates algorithm.
 * @param {Array} array The array to be shuffled.
 */
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
    }
}

/**
 * Fetches and displays elements from Supabase with infinite scroll and randomization.
 * @param {string} query The search query.
 * @param {boolean} isNewSearch If true, resets pagination and clears the grid.
 */
async function searchElements(query, isNewSearch = true) {
    if (!supabase || isLoading) return;

    const grid = document.getElementById('elements-grid');
    if (!grid) return;

    // --- Reset for a new search ---
    if (isNewSearch) {
        currentQuery = query;
        currentPage = 0;
        grid.innerHTML = '';
        // Clean up any existing IntersectionObserver
        if (grid.observer) {
            grid.observer.disconnect();
        }
    }

    isLoading = true;

    // --- Loading Indicator ---
    const loadingIndicator = document.createElement('p');
    loadingIndicator.className = 'muted';
    loadingIndicator.textContent = 'Loading...';
    grid.appendChild(loadingIndicator);

    // --- Supabase Query with Pagination ---
    const from = currentPage * ELEMENTS_PER_PAGE;
    const to = from + ELEMENTS_PER_PAGE - 1;

    let queryBuilder = supabase.from('elements').select('id, name, image_url, tags');
    if (currentQuery) {
        queryBuilder = queryBuilder.or(`name.ilike.%${currentQuery}%,tags.cs.{${currentQuery}}`);
    }

    // Fetch in a consistent order (e.g., by ID) for stable pagination results.
    const { data, error } = await queryBuilder.order('id').range(from, to);

    // Always remove the loading indicator after the fetch attempt.
    grid.removeChild(loadingIndicator);
    isLoading = false;

    if (error) {
        console.error('Element search error:', error);
        grid.innerHTML = '<p class="muted">Error loading elements.</p>';
        return;
    }

    // Handle no results
    if (!data || data.length === 0) {
        if (isNewSearch) {
            grid.innerHTML = '<p class="muted">No elements found.</p>';
        }
        // Stop here; no more data to load.
        return;
    }

    // --- RANDOMIZE THE BATCH ---
    shuffleArray(data);

    // --- Element Rendering Loop ---
    for (const el of data) {
        const chip = document.createElement('div');
        chip.className = 'element-chip';
        chip.draggable = true;

        const img = document.createElement('img');
        img.alt = el.name;
        img.loading = 'lazy'; // Defer loading off-screen images

        const isSvg = el.image_url.toLowerCase().endsWith('.svg');
        const imageUrlWithCacheBust = `${el.image_url}?t=${Date.now()}`;

        // Asynchronously load the image to avoid blocking the loop
        (async () => {
            try {
                if (isSvg) {
                    const response = await fetch(imageUrlWithCacheBust);
                    const blob = await response.blob();
                    const svgBlob = blob.type === 'image/svg+xml' ?
                        blob :
                        new Blob([await blob.text()], { type: 'image/svg+xml' });
                    img.src = URL.createObjectURL(svgBlob);
                } else {
                    img.src = imageUrlWithCacheBust;
                }
            } catch (err) {
                console.error(`Failed to load image for ${el.name}:`, err);
                chip.innerHTML = `<span class="muted" style="font-size: 10px; text-align: center;">Load Error</span>`;
                chip.draggable = false;
            }
        })();

        img.onerror = () => {
            chip.innerHTML = `<span class="muted" style="font-size: 10px; text-align: center;">Load Error</span>`;
            chip.title = `Error loading: ${el.name}`;
            chip.draggable = false;
        };

        chip.appendChild(img);

        // --- Drag Support (Handles all image types) ---
        chip.addEventListener('dragend', e => {
            if (!(img.complete && img.naturalHeight !== 0)) return;

            // Get mouse position relative to the canvas
            const canvasRect = canvas.upperCanvasEl.getBoundingClientRect();
            const mouseX = e.clientX - canvasRect.left;
            const mouseY = e.clientY - canvasRect.top;

            // Convert to Fabric coordinates considering zoom/pan
            const pointer = canvas.getPointer({ clientX: e.clientX, clientY: e.clientY });

            if (isSvg) {
                adders.svg(pointer.x, pointer.y, img.src, { oid: el.id });
            } else {
                adders.image(pointer.x, pointer.y, img.src, { oid: el.id });
            }
        });

        // --- Click Support ---
        chip.addEventListener('click', () => {
            if (img.complete && img.naturalHeight !== 0) {
                const { x, y } = canvas.getVpCenter();
                // Logic correctly distinguishes between SVG and raster images
                if (isSvg) {
                    adders.svg(x, y, img.src, { oid: el.id }); // img.src is the blob URL here
                } else {
                    adders.image(x, y, img.src, { oid: el.id });
                }
            }
        });

        grid.appendChild(chip);
    }

    // Prepare for the next page
    currentPage++;

    // --- Intersection Observer Setup ---
    // If we loaded a full page, there might be more results.
    // Set up the observer on the last element to trigger loading the next page.
    if (data.length === ELEMENTS_PER_PAGE) {
        const lastElement = grid.lastElementChild;
        if (lastElement) {
            const observer = new IntersectionObserver((entries) => {
                if (entries[0].isIntersecting) {
                    observer.disconnect(); // Important: Stop observing the current last element
                    // Load the next page for the same query
                    searchElements(currentQuery, false);
                }
            }, { threshold: 0.5 }); // Trigger when 50% of the element is visible

            observer.observe(lastElement);
            grid.observer = observer; // Store for cleanup
        }
    }
}

// --- INTERACTIVE TOUR ---
const tourModal = $('#tour-modal'); const tourHighlight = $('#tour-highlight'); let currentTourStep = 0; const tourSteps = [ { title: "How to Structure Your Data", content: `<p>Before importing, make sure your data is structured correctly in a .csv or .xlsx file.</p><img src="assets/images/data-structure-example.png" alt="Example data structure" style="max-width:100%; margin-bottom:1rem;" /><ul><li>Column names should start in cell <b>A1</b>.</li><li>Each new row will be treated as a different file or page.</li></ul>`, element: null }, { title: "How to Import Your Data", content: `<p>Press the <b>Load Data</b> button to open the file picker.</p><p>Valid formats are <b>.xlsx</b> and <b>.csv</b>.</p>`, element: 'label[for="csvInput"]' }, { title: "How to Generate with AI", content: `<p>Press the AI bubble to open the assistant.`, element: '#ai-bubble', action: () => { $('#dataLinksManagerModal').style.display = 'none'; $('#aiModalBackdrop').style.display = 'none' } }, { title: "How to Generate with AI", content: `You will need a <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio API key</a>.</p><ul><li>Login to you Google Account.</li><li>Click on "+ Create API Key"</li><li>Copy the key and paste it here</li> </ul>`, element: '#aiApiKey', action: () => { $('#dataLinksManagerModal').style.display = 'none'; $('#aiModalBackdrop').style.display = 'flex' } }, { title: "How to Generate with AI", content: `Now, enter your request in the prompt box and press "Send Request".</p><p><b>Tips:</b></p><ul><li>You can paste an image into the prompt to help with your idea.</li><li>Specify your column names in the prompt and the AI will try to link them automatically.</li></ul>`, element: '#aiPrompt', action: () => { $('#dataLinksManagerModal').style.display = 'none'; $('#aiModalBackdrop').style.display = 'flex' } }, { title: "How to Link Your Data", content: `<p>First, make sure you have imported your data.</p><p>Press <b>Data Links</b> to open the manager.</p>`, element: '#openDataLinksManagerBtn', action: () => { $('#aiModalBackdrop').style.display = 'none'; $('#dataLinksManagerModal').style.display = 'none'; } }, { title: "How to Link Your Data", content: `<p>From there, you can select an object, choose a column from your data, and link it to a property like 'Text Content' or 'Color'.</p>`, element: '.objects-list-container', action: () => { $('#aiModalBackdrop').style.display = 'none'; $('#dataLinksManagerModal').style.display = 'flex'; } }, { title: "Tour Complete!", content: `<p>You now know the basics! Start creating your templates.</p>`, element: null, action: () => { $('#dataLinksManagerModal').style.display = 'none'; } } ];
function startTour() { currentTourStep = 0; tourModal.style.display = 'flex'; goToStep(currentTourStep); } function endTour() { tourModal.style.display = 'none'; tourHighlight.style.display = 'none'; localStorage.setItem('hasSeenTour', 'true'); }
function goToStep(stepIndex) {
    const step = tourSteps[stepIndex];
    if (!step) {
        endTour();
        return;
    }

    // Execute the action first to ensure the element is visible
    if(step.action) {
        step.action();
    }

    if(!step.action) {
        document.querySelectorAll('.modal-backdrop').forEach(m => m.style.display = 'none');
    }

    $('#tour-modal-title').textContent = step.title;
    $('#tour-modal-content').innerHTML = step.content;
    $('#tour-step-counter').textContent = `${stepIndex + 1} / ${tourSteps.length}`;
    $('#tour-prev-btn').disabled = stepIndex === 0;
    $('#tour-next-btn').style.display = stepIndex === tourSteps.length - 1 ? 'none' : 'inline-flex';
    $('#tour-finish-btn').style.display = stepIndex === tourSteps.length - 1 ? 'inline-flex' : 'none';

    const targetEl = step.element ? $(step.element) : null;
    if (targetEl) {
        // Now getBoundingClientRect will have the correct dimensions
        const rect = targetEl.getBoundingClientRect();
        tourHighlight.style.display = 'block';
        tourHighlight.style.width = `${rect.width + 10}px`;
        tourHighlight.style.height = `${rect.height + 10}px`;
        tourHighlight.style.top = `${rect.top - 5}px`;
        tourHighlight.style.left = `${rect.left - 5}px`;

        const modalRect = tourModal.getBoundingClientRect();
        let modalTop = rect.top + 30,
            modalLeft = rect.right + modalRect.width;

        if (modalLeft + modalRect.width > window.innerWidth) {
            modalLeft = rect.left - modalRect.width + 100;
        }
        if(modalTop + modalRect.height > window.innerHeight) {
            modalTop = window.innerHeight - modalRect.height - 30;
        }

        modalTop = Math.max(15, modalTop);
        modalLeft = Math.max(15, modalLeft);

        tourModal.style.top = `${modalTop}px`;
        tourModal.style.left = `${modalLeft}px`;
    } else {
        tourHighlight.style.display = 'none';
        tourModal.style.top = '50%';
        tourModal.style.left = '50%';
        tourModal.style.transform = 'translate(-50%, -50%)';
    }
}
$('#start-tour-btn').addEventListener('click', startTour); $('#tour-close-btn').addEventListener('click', endTour); $('#tour-finish-btn').addEventListener('click', endTour); $('#tour-next-btn').addEventListener('click', () => { currentTourStep++; goToStep(currentTourStep); }); $('#tour-prev-btn').addEventListener('click', () => { currentTourStep--; goToStep(currentTourStep); });

// --- INITIALIZE ---
window.addEventListener('DOMContentLoaded', initializeEditor);
</script>

</body>
</html>