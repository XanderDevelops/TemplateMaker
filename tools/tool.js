import { supabase as importedSupabase } from '../assets/js/supabase-client.js';

globalThis.__csvlink_supabase = importedSupabase;

// components/00-google-fonts-list.js
// Auto-generated from https://fonts.google.com/metadata/fonts
const GOOGLE_FONT_FAMILIES = [
    'ABeeZee',
    'Abel',
    'Abhaya Libre',
    'Aboreto',
    'Abril Fatface',
    'Abyssinica SIL',
    'Aclonica',
    'Acme',
    'Actor',
    'Adamina',
    'ADLaM Display',
    'Advent Pro',
    'Afacad',
    'Afacad Flux',
    'Agbalumo',
    'Agdasima',
    'Agu Display',
    'Aguafina Script',
    'Akatab',
    'Akaya Kanadaka',
    'Akaya Telivigala',
    'Akronim',
    'Akshar',
    'Aladin',
    'Alan Sans',
    'Alata',
    'Alatsi',
    'Albert Sans',
    'Aldrich',
    'Alef',
    'Alegreya',
    'Alegreya Sans',
    'Alegreya Sans SC',
    'Alegreya SC',
    'Aleo',
    'Alex Brush',
    'Alexandria',
    'Alfa Slab One',
    'Alice',
    'Alike',
    'Alike Angular',
    'Alkalami',
    'Alkatra',
    'Allan',
    'Allerta',
    'Allerta Stencil',
    'Allison',
    'Allkin',
    'Allura',
    'Almarai',
    'Almendra',
    'Almendra Display',
    'Almendra SC',
    'Alumni Sans',
    'Alumni Sans Collegiate One',
    'Alumni Sans Inline One',
    'Alumni Sans Pinstripe',
    'Alumni Sans SC',
    'Alyamama',
    'Amarante',
    'Amaranth',
    'Amarna',
    'Amatic SC',
    'Amethysta',
    'Amiko',
    'Amiri',
    'Amiri Quran',
    'Amita',
    'Anaheim',
    'Ancizar Sans',
    'Ancizar Serif',
    'Andada Pro',
    'Andika',
    'Anek Bangla',
    'Anek Devanagari',
    'Anek Gujarati',
    'Anek Gurmukhi',
    'Anek Kannada',
    'Anek Latin',
    'Anek Malayalam',
    'Anek Odia',
    'Anek Tamil',
    'Anek Telugu',
    'Angkor',
    'Annapurna SIL',
    'Annie Use Your Telescope',
    'Anonymous Pro',
    'Anta',
    'Antic',
    'Antic Didone',
    'Antic Slab',
    'Anton',
    'Anton SC',
    'Antonio',
    'Anuphan',
    'Anybody',
    'Aoboshi One',
    'AR One Sans',
    'Arapey',
    'Arbutus',
    'Arbutus Slab',
    'Architects Daughter',
    'Archivo',
    'Archivo Black',
    'Archivo Narrow',
    'Are You Serious',
    'Aref Ruqaa',
    'Aref Ruqaa Ink',
    'Arima',
    'Arimo',
    'Arizonia',
    'Armata',
    'Arsenal',
    'Arsenal SC',
    'Artifika',
    'Arvo',
    'Arya',
    'Asap',
    'Asap Condensed',
    'Asar',
    'Asimovian',
    'Asset',
    'Assistant',
    'Asta Sans',
    'Astloch',
    'Asul',
    'Athiti',
    'Atkinson Hyperlegible',
    'Atkinson Hyperlegible Mono',
    'Atkinson Hyperlegible Next',
    'Atma',
    'Atomic Age',
    'Aubrey',
    'Audiowide',
    'Autour One',
    'Average',
    'Average Sans',
    'Averia Gruesa Libre',
    'Averia Libre',
    'Averia Sans Libre',
    'Averia Serif Libre',
    'Azeret Mono',
    'B612',
    'B612 Mono',
    'Babylonica',
    'Bacasime Antique',
    'Bad Script',
    'Badeen Display',
    'Bagel Fat One',
    'Bahiana',
    'Bahianita',
    'Bai Jamjuree',
    'Bakbak One',
    'Ballet',
    'Baloo 2',
    'Baloo Bhai 2',
    'Baloo Bhaijaan 2',
    'Baloo Bhaina 2',
    'Baloo Chettan 2',
    'Baloo Da 2',
    'Baloo Paaji 2',
    'Baloo Tamma 2',
    'Baloo Tammudu 2',
    'Baloo Thambi 2',
    'Balsamiq Sans',
    'Balthazar',
    'Bangers',
    'Barlow',
    'Barlow Condensed',
    'Barlow Semi Condensed',
    'Barriecito',
    'Barrio',
    'Basic',
    'Baskervville',
    'Baskervville SC',
    'Battambang',
    'Baumans',
    'Bayon',
    'BBH Bartle',
    'BBH Bogle',
    'BBH Hegarty',
    'Be Vietnam Pro',
    'Beau Rivage',
    'Bebas Neue',
    'Beiruti',
    'Belanosima',
    'Belgrano',
    'Bellefair',
    'Belleza',
    'Bellota',
    'Bellota Text',
    'BenchNine',
    'Benne',
    'Bentham',
    'Berkshire Swash',
    'Besley',
    'Betania Patmos',
    'Betania Patmos GDL',
    'Betania Patmos In',
    'Betania Patmos In GDL',
    'Beth Ellen',
    'Bevan',
    'BhuTuka Expanded One',
    'Big Shoulders',
    'Big Shoulders Inline',
    'Big Shoulders Stencil',
    'Bigelow Rules',
    'Bigshot One',
    'Bilbo',
    'Bilbo Swash Caps',
    'BioRhyme',
    'BioRhyme Expanded',
    'Birthstone',
    'Birthstone Bounce',
    'Biryani',
    'Bitcount',
    'Bitcount Grid Double',
    'Bitcount Grid Double Ink',
    'Bitcount Grid Single',
    'Bitcount Grid Single Ink',
    'Bitcount Ink',
    'Bitcount Prop Double',
    'Bitcount Prop Double Ink',
    'Bitcount Prop Single',
    'Bitcount Prop Single Ink',
    'Bitcount Single',
    'Bitcount Single Ink',
    'Bitter',
    'BIZ UDGothic',
    'BIZ UDMincho',
    'BIZ UDPGothic',
    'BIZ UDPMincho',
    'Black And White Picture',
    'Black Han Sans',
    'Black Ops One',
    'Blaka',
    'Blaka Hollow',
    'Blaka Ink',
    'Blinker',
    'Bodoni Moda',
    'Bodoni Moda SC',
    'Bokor',
    'Boldonse',
    'Bona Nova',
    'Bona Nova SC',
    'Bonbon',
    'Bonheur Royale',
    'Boogaloo',
    'Borel',
    'Bowlby One',
    'Bowlby One SC',
    'Bpmf Huninn',
    'Bpmf Iansui',
    'Bpmf Zihi Kai Std',
    'Braah One',
    'Brawler',
    'Bree Serif',
    'Bricolage Grotesque',
    'Bruno Ace',
    'Bruno Ace SC',
    'Brygada 1918',
    'Bubblegum Sans',
    'Bubbler One',
    'Buda',
    'Buenard',
    'Bungee',
    'Bungee Hairline',
    'Bungee Inline',
    'Bungee Outline',
    'Bungee Shade',
    'Bungee Spice',
    'Bungee Tint',
    'Butcherman',
    'Butterfly Kids',
    'Bytesized',
    'Cabin',
    'Cabin Condensed',
    'Cabin Sketch',
    'Cactus Classical Serif',
    'Caesar Dressing',
    'Cagliostro',
    'Cairo',
    'Cairo Play',
    'Cal Sans',
    'Caladea',
    'Calistoga',
    'Calligraffitti',
    'Cambay',
    'Cambo',
    'Candal',
    'Cantarell',
    'Cantata One',
    'Cantora One',
    'Caprasimo',
    'Capriola',
    'Caramel',
    'Carattere',
    'Cardo',
    'Carlito',
    'Carme',
    'Carrois Gothic',
    'Carrois Gothic SC',
    'Carter One',
    'Cascadia Code',
    'Cascadia Mono',
    'Castoro',
    'Castoro Titling',
    'Catamaran',
    'Caudex',
    'Cause',
    'Caveat',
    'Caveat Brush',
    'Cedarville Cursive',
    'Ceviche One',
    'Chakra Petch',
    'Changa',
    'Changa One',
    'Chango',
    'Charis SIL',
    'Charm',
    'Charmonman',
    'Chathura',
    'Chau Philomene One',
    'Chela One',
    'Chelsea Market',
    'Chenla',
    'Cherish',
    'Cherry Bomb One',
    'Cherry Cream Soda',
    'Cherry Swash',
    'Chewy',
    'Chicle',
    'Chilanka',
    'Chiron GoRound TC',
    'Chiron Hei HK',
    'Chiron Sung HK',
    'Chivo',
    'Chivo Mono',
    'Chocolate Classical Sans',
    'Chokokutai',
    'Chonburi',
    'Cinzel',
    'Cinzel Decorative',
    'Clicker Script',
    'Climate Crisis',
    'Coda',
    'Codystar',
    'Coiny',
    'Combo',
    'Comfortaa',
    'Comforter',
    'Comforter Brush',
    'Comic Neue',
    'Comic Relief',
    'Coming Soon',
    'Comme',
    'Commissioner',
    'Concert One',
    'Condiment',
    'Content',
    'Contrail One',
    'Convergence',
    'Cookie',
    'Copse',
    'Coral Pixels',
    'Corben',
    'Corinthia',
    'Cormorant',
    'Cormorant Garamond',
    'Cormorant Infant',
    'Cormorant SC',
    'Cormorant Unicase',
    'Cormorant Upright',
    'Cossette Texte',
    'Cossette Titre',
    'Courgette',
    'Courier Prime',
    'Cousine',
    'Coustard',
    'Covered By Your Grace',
    'Crafty Girls',
    'Creepster',
    'Crete Round',
    'Crimson Pro',
    'Crimson Text',
    'Croissant One',
    'Crushed',
    'Cuprum',
    'Cute Font',
    'Cutive',
    'Cutive Mono',
    'Dai Banna SIL',
    'Damion',
    'Dancing Script',
    'Danfo',
    'Dangrek',
    'Darker Grotesque',
    'Darumadrop One',
    'David Libre',
    'Dawning of a New Day',
    'Days One',
    'Dekko',
    'Dela Gothic One',
    'Delicious Handrawn',
    'Delius',
    'Delius Swash Caps',
    'Delius Unicase',
    'Della Respira',
    'Denk One',
    'Devonshire',
    'Dhurjati',
    'Didact Gothic',
    'Diphylleia',
    'Diplomata',
    'Diplomata SC',
    'DM Mono',
    'DM Sans',
    'DM Serif Display',
    'DM Serif Text',
    'Do Hyeon',
    'Dokdo',
    'Domine',
    'Donegal One',
    'Dongle',
    'Doppio One',
    'Dorsa',
    'Dosis',
    'DotGothic16',
    'Doto',
    'Dr Sugiyama',
    'Duru Sans',
    'Dynalight',
    'DynaPuff',
    'Eagle Lake',
    'East Sea Dokdo',
    'Eater',
    'EB Garamond',
    'Economica',
    'Eczar',
    'Edu AU VIC WA NT Arrows',
    'Edu AU VIC WA NT Dots',
    'Edu AU VIC WA NT Guides',
    'Edu AU VIC WA NT Hand',
    'Edu AU VIC WA NT Pre',
    'Edu NSW ACT Cursive',
    'Edu NSW ACT Foundation',
    'Edu NSW ACT Hand Pre',
    'Edu QLD Beginner',
    'Edu QLD Hand',
    'Edu SA Beginner',
    'Edu SA Hand',
    'Edu TAS Beginner',
    'Edu VIC WA NT Beginner',
    'Edu VIC WA NT Hand',
    'Edu VIC WA NT Hand Pre',
    'El Messiri',
    'Electrolize',
    'Elms Sans',
    'Elsie',
    'Elsie Swash Caps',
    'Emblema One',
    'Emilys Candy',
    'Encode Sans',
    'Encode Sans Condensed',
    'Encode Sans Expanded',
    'Encode Sans SC',
    'Encode Sans Semi Condensed',
    'Encode Sans Semi Expanded',
    'Engagement',
    'Englebert',
    'Enriqueta',
    'Ephesis',
    'Epilogue',
    'Epunda Sans',
    'Epunda Slab',
    'Erica One',
    'Esteban',
    'Estonia',
    'Euphoria Script',
    'Ewert',
    'Exile',
    'Exo',
    'Exo 2',
    'Expletus Sans',
    'Explora',
    'Faculty Glyphic',
    'Fahkwang',
    'Familjen Grotesk',
    'Fanwood Text',
    'Farro',
    'Farsan',
    'Fascinate',
    'Fascinate Inline',
    'Faster One',
    'Fasthand',
    'Fauna One',
    'Faustina',
    'Federant',
    'Federo',
    'Felipa',
    'Fenix',
    'Festive',
    'Figtree',
    'Finger Paint',
    'Finlandica',
    'Fira Code',
    'Fira Mono',
    'Fira Sans',
    'Fira Sans Condensed',
    'Fira Sans Extra Condensed',
    'Fjalla One',
    'Fjord One',
    'Flamenco',
    'Flavors',
    'Fleur De Leah',
    'Flow Block',
    'Flow Circular',
    'Flow Rounded',
    'Foldit',
    'Fondamento',
    'Fontdiner Swanky',
    'Forum',
    'Fragment Mono',
    'Francois One',
    'Frank Ruhl Libre',
    'Fraunces',
    'Freckle Face',
    'Fredericka the Great',
    'Fredoka',
    'Freehand',
    'Freeman',
    'Fresca',
    'Frijole',
    'Fruktur',
    'Fugaz One',
    'Fuggles',
    'Funnel Display',
    'Funnel Sans',
    'Fustat',
    'Fuzzy Bubbles',
    'Ga Maamli',
    'Gabarito',
    'Gabriela',
    'Gaegu',
    'Gafata',
    'Gajraj One',
    'Galada',
    'Galdeano',
    'Galindo',
    'Gamja Flower',
    'Gantari',
    'Gasoek One',
    'Gayathri',
    'Geist',
    'Geist Mono',
    'Gelasio',
    'Gemunu Libre',
    'Genos',
    'Gentium Book Plus',
    'Gentium Plus',
    'Geo',
    'Geologica',
    'Geom',
    'Georama',
    'Geostar',
    'Geostar Fill',
    'Germania One',
    'GFS Didot',
    'GFS Neohellenic',
    'Gideon Roman',
    'Gidole',
    'Gidugu',
    'Gilda Display',
    'Girassol',
    'Give You Glory',
    'Glass Antiqua',
    'Glegoo',
    'Gloock',
    'Gloria Hallelujah',
    'Glory',
    'Gluten',
    'Goblin One',
    'Gochi Hand',
    'Goldman',
    'Golos Text',
    'Google Sans',
    'Google Sans Code',
    'Google Sans Flex',
    'Gorditas',
    'Gothic A1',
    'Gotu',
    'Goudy Bookletter 1911',
    'Gowun Batang',
    'Gowun Dodum',
    'Graduate',
    'Grand Hotel',
    'Grandiflora One',
    'Grandstander',
    'Grape Nuts',
    'Gravitas One',
    'Great Vibes',
    'Grechen Fuemen',
    'Grenze',
    'Grenze Gotisch',
    'Grey Qo',
    'Griffy',
    'Gruppo',
    'Gudea',
    'Gugi',
    'Gulzar',
    'Gupter',
    'Gurajada',
    'Gveret Levin',
    'Gwendolyn',
    'Habibi',
    'Hachi Maru Pop',
    'Hahmlet',
    'Halant',
    'Hammersmith One',
    'Hanalei',
    'Hanalei Fill',
    'Handjet',
    'Handlee',
    'Hanken Grotesk',
    'Hanuman',
    'Happy Monkey',
    'Harmattan',
    'Headland One',
    'Hedvig Letters Sans',
    'Hedvig Letters Serif',
    'Heebo',
    'Henny Penny',
    'Hepta Slab',
    'Herr Von Muellerhoff',
    'Hi Melody',
    'Hina Mincho',
    'Hind',
    'Hind Guntur',
    'Hind Madurai',
    'Hind Mysuru',
    'Hind Siliguri',
    'Hind Vadodara',
    'Holtwood One SC',
    'Homemade Apple',
    'Homenaje',
    'Honk',
    'Host Grotesk',
    'Hubballi',
    'Hubot Sans',
    'Huninn',
    'Hurricane',
    'Iansui',
    'Ibarra Real Nova',
    'IBM Plex Mono',
    'IBM Plex Sans',
    'IBM Plex Sans Arabic',
    'IBM Plex Sans Condensed',
    'IBM Plex Sans Devanagari',
    'IBM Plex Sans Hebrew',
    'IBM Plex Sans JP',
    'IBM Plex Sans KR',
    'IBM Plex Sans Thai',
    'IBM Plex Sans Thai Looped',
    'IBM Plex Serif',
    'Iceberg',
    'Iceland',
    'Idiqlat',
    'IM Fell Double Pica',
    'IM Fell Double Pica SC',
    'IM Fell DW Pica',
    'IM Fell DW Pica SC',
    'IM Fell English',
    'IM Fell English SC',
    'IM Fell French Canon',
    'IM Fell French Canon SC',
    'IM Fell Great Primer',
    'IM Fell Great Primer SC',
    'Imbue',
    'Imperial Script',
    'Imprima',
    'Inclusive Sans',
    'Inconsolata',
    'Inder',
    'Indie Flower',
    'Ingrid Darling',
    'Inika',
    'Inknut Antiqua',
    'Inria Sans',
    'Inria Serif',
    'Inspiration',
    'Instrument Sans',
    'Instrument Serif',
    'Intel One Mono',
    'Inter',
    'Inter Tight',
    'Irish Grover',
    'Island Moments',
    'Istok Web',
    'Italiana',
    'Italianno',
    'Itim',
    'Jacquard 12',
    'Jacquard 12 Charted',
    'Jacquard 24',
    'Jacquard 24 Charted',
    'Jacquarda Bastarda 9',
    'Jacquarda Bastarda 9 Charted',
    'Jacques Francois',
    'Jacques Francois Shadow',
    'Jaini',
    'Jaini Purva',
    'Jaldi',
    'Jaro',
    'Jersey 10',
    'Jersey 10 Charted',
    'Jersey 15',
    'Jersey 15 Charted',
    'Jersey 20',
    'Jersey 20 Charted',
    'Jersey 25',
    'Jersey 25 Charted',
    'JetBrains Mono',
    'Jim Nightshade',
    'Joan',
    'Jockey One',
    'Jolly Lodger',
    'Jomhuria',
    'Jomolhari',
    'Josefin Sans',
    'Josefin Slab',
    'Jost',
    'Joti One',
    'Jua',
    'Judson',
    'Julee',
    'Julius Sans One',
    'Junge',
    'Jura',
    'Just Another Hand',
    'Just Me Again Down Here',
    'K2D',
    'Kablammo',
    'Kadwa',
    'Kaisei Decol',
    'Kaisei HarunoUmi',
    'Kaisei Opti',
    'Kaisei Tokumin',
    'Kalam',
    'Kalnia',
    'Kalnia Glaze',
    'Kameron',
    'Kanchenjunga',
    'Kanit',
    'Kantumruy Pro',
    'Kapakana',
    'Karantina',
    'Karla',
    'Karla Tamil Inclined',
    'Karla Tamil Upright',
    'Karma',
    'Katibeh',
    'Kaushan Script',
    'Kavivanar',
    'Kavoon',
    'Kay Pho Du',
    'Kdam Thmor Pro',
    'Keania One',
    'Kedebideri',
    'Kelly Slab',
    'Kenia',
    'Khand',
    'Khmer',
    'Khula',
    'Kings',
    'Kirang Haerang',
    'Kite One',
    'Kiwi Maru',
    'Klee One',
    'Knewave',
    'Kodchasan',
    'Kode Mono',
    'Koh Santepheap',
    'KoHo',
    'Kolker Brush',
    'Konkhmer Sleokchher',
    'Kosugi',
    'Kosugi Maru',
    'Kotta One',
    'Koulen',
    'Kranky',
    'Kreon',
    'Kristi',
    'Krona One',
    'Krub',
    'Kufam',
    'Kulim Park',
    'Kumar One',
    'Kumar One Outline',
    'Kumbh Sans',
    'Kurale',
    'La Belle Aurore',
    'Labrada',
    'Lacquer',
    'Laila',
    'Lakki Reddy',
    'Lalezar',
    'Lancelot',
    'Langar',
    'Lateef',
    'Lato',
    'Lavishly Yours',
    'League Gothic',
    'League Script',
    'League Spartan',
    'Leckerli One',
    'Ledger',
    'Lekton',
    'Lemon',
    'Lemonada',
    'Lexend',
    'Lexend Deca',
    'Lexend Exa',
    'Lexend Giga',
    'Lexend Mega',
    'Lexend Peta',
    'Lexend Tera',
    'Lexend Zetta',
    'Libertinus Keyboard',
    'Libertinus Math',
    'Libertinus Mono',
    'Libertinus Sans',
    'Libertinus Serif',
    'Libertinus Serif Display',
    'Libre Barcode 128',
    'Libre Barcode 128 Text',
    'Libre Barcode 39',
    'Libre Barcode 39 Extended',
    'Libre Barcode 39 Extended Text',
    'Libre Barcode 39 Text',
    'Libre Barcode EAN13 Text',
    'Libre Baskerville',
    'Libre Bodoni',
    'Libre Caslon Display',
    'Libre Caslon Text',
    'Libre Franklin',
    'Licorice',
    'Life Savers',
    'Lilex',
    'Lilita One',
    'Lily Script One',
    'Limelight',
    'Linden Hill',
    'LINE Seed JP',
    'Linefont',
    'Lisu Bosa',
    'Liter',
    'Literata',
    'Liu Jian Mao Cao',
    'Livvic',
    'Lobster',
    'Lobster Two',
    'Londrina Outline',
    'Londrina Shadow',
    'Londrina Sketch',
    'Londrina Solid',
    'Long Cang',
    'Lora',
    'Love Light',
    'Love Ya Like A Sister',
    'Loved by the King',
    'Lovers Quarrel',
    'Luckiest Guy',
    'Lugrasimo',
    'Lumanosimo',
    'Lunasima',
    'Lusitana',
    'Lustria',
    'Luxurious Roman',
    'Luxurious Script',
    'LXGW Marker Gothic',
    'LXGW WenKai Mono TC',
    'LXGW WenKai TC',
    'M PLUS 1',
    'M PLUS 1 Code',
    'M PLUS 1p',
    'M PLUS 2',
    'M PLUS Code Latin',
    'M PLUS Rounded 1c',
    'Ma Shan Zheng',
    'Macondo',
    'Macondo Swash Caps',
    'Mada',
    'Madimi One',
    'Magra',
    'Maiden Orange',
    'Maitree',
    'Major Mono Display',
    'Mako',
    'Mali',
    'Mallanna',
    'Maname',
    'Mandali',
    'Manjari',
    'Manrope',
    'Mansalva',
    'Manuale',
    'Manufacturing Consent',
    'Marcellus',
    'Marcellus SC',
    'Marck Script',
    'Margarine',
    'Marhey',
    'Markazi Text',
    'Marko One',
    'Marmelad',
    'Martel',
    'Martel Sans',
    'Martian Mono',
    'Marvel',
    'Matangi',
    'Mate',
    'Mate SC',
    'Matemasie',
    'Maven Pro',
    'McLaren',
    'Mea Culpa',
    'Meddon',
    'MedievalSharp',
    'Medula One',
    'Meera Inimai',
    'Megrim',
    'Meie Script',
    'Menbere',
    'Meow Script',
    'Merienda',
    'Merriweather',
    'Merriweather Sans',
    'Metal',
    'Metal Mania',
    'Metamorphous',
    'Metrophobic',
    'Michroma',
    'Micro 5',
    'Micro 5 Charted',
    'Milonga',
    'Miltonian',
    'Miltonian Tattoo',
    'Mina',
    'Mingzat',
    'Miniver',
    'Miriam Libre',
    'Mirza',
    'Miss Fajardose',
    'Mitr',
    'Mochiy Pop One',
    'Mochiy Pop P One',
    'Modak',
    'Modern Antiqua',
    'Moderustic',
    'Mogra',
    'Mohave',
    'Moirai One',
    'Molengo',
    'Molle',
    'Momo Signature',
    'Momo Trust Display',
    'Momo Trust Sans',
    'Mona Sans',
    'Monda',
    'Monofett',
    'Monomakh',
    'Monomaniac One',
    'Monoton',
    'Monsieur La Doulaise',
    'Montaga',
    'Montagu Slab',
    'MonteCarlo',
    'Montez',
    'Montserrat',
    'Montserrat Alternates',
    'Montserrat Underline',
    'Moo Lah Lah',
    'Mooli',
    'Moon Dance',
    'Moul',
    'Moulpali',
    'Mountains of Christmas',
    'Mouse Memoirs',
    'Mozilla Headline',
    'Mozilla Text',
    'Mr Bedfort',
    'Mr Dafoe',
    'Mr De Haviland',
    'Mrs Saint Delafield',
    'Mrs Sheppards',
    'Ms Madi',
    'Mukta',
    'Mukta Mahee',
    'Mukta Malar',
    'Mukta Vaani',
    'Mulish',
    'Murecho',
    'MuseoModerno',
    'My Soul',
    'Mynerve',
    'Mystery Quest',
    'Nabla',
    'Namdhinggo',
    'Nanum Brush Script',
    'Nanum Gothic',
    'Nanum Gothic Coding',
    'Nanum Myeongjo',
    'Nanum Pen Script',
    'Narnoor',
    'Nata Sans',
    'National Park',
    'Neonderthaw',
    'Nerko One',
    'Neucha',
    'Neuton',
    'New Amsterdam',
    'New Rocker',
    'New Tegomin',
    'News Cycle',
    'Newsreader',
    'Niconne',
    'Niramit',
    'Nixie One',
    'Nobile',
    'Nokora',
    'Norican',
    'Nosifer',
    'Notable',
    'Nothing You Could Do',
    'Noticia Text',
    'Noto Color Emoji',
    'Noto Emoji',
    'Noto Kufi Arabic',
    'Noto Music',
    'Noto Naskh Arabic',
    'Noto Nastaliq Urdu',
    'Noto Rashi Hebrew',
    'Noto Sans',
    'Noto Sans Adlam',
    'Noto Sans Adlam Unjoined',
    'Noto Sans Anatolian Hieroglyphs',
    'Noto Sans Arabic',
    'Noto Sans Armenian',
    'Noto Sans Avestan',
    'Noto Sans Balinese',
    'Noto Sans Bamum',
    'Noto Sans Bassa Vah',
    'Noto Sans Batak',
    'Noto Sans Bengali',
    'Noto Sans Bhaiksuki',
    'Noto Sans Brahmi',
    'Noto Sans Buginese',
    'Noto Sans Buhid',
    'Noto Sans Canadian Aboriginal',
    'Noto Sans Carian',
    'Noto Sans Caucasian Albanian',
    'Noto Sans Chakma',
    'Noto Sans Cham',
    'Noto Sans Cherokee',
    'Noto Sans Chorasmian',
    'Noto Sans Coptic',
    'Noto Sans Cuneiform',
    'Noto Sans Cypriot',
    'Noto Sans Cypro Minoan',
    'Noto Sans Deseret',
    'Noto Sans Devanagari',
    'Noto Sans Display',
    'Noto Sans Duployan',
    'Noto Sans Egyptian Hieroglyphs',
    'Noto Sans Elbasan',
    'Noto Sans Elymaic',
    'Noto Sans Ethiopic',
    'Noto Sans Georgian',
    'Noto Sans Glagolitic',
    'Noto Sans Gothic',
    'Noto Sans Grantha',
    'Noto Sans Gujarati',
    'Noto Sans Gunjala Gondi',
    'Noto Sans Gurmukhi',
    'Noto Sans Hanifi Rohingya',
    'Noto Sans Hanunoo',
    'Noto Sans Hatran',
    'Noto Sans Hebrew',
    'Noto Sans HK',
    'Noto Sans Imperial Aramaic',
    'Noto Sans Indic Siyaq Numbers',
    'Noto Sans Inscriptional Pahlavi',
    'Noto Sans Inscriptional Parthian',
    'Noto Sans Javanese',
    'Noto Sans JP',
    'Noto Sans Kaithi',
    'Noto Sans Kannada',
    'Noto Sans Kawi',
    'Noto Sans Kayah Li',
    'Noto Sans Kharoshthi',
    'Noto Sans Khmer',
    'Noto Sans Khojki',
    'Noto Sans Khudawadi',
    'Noto Sans KR',
    'Noto Sans Lao',
    'Noto Sans Lao Looped',
    'Noto Sans Lepcha',
    'Noto Sans Limbu',
    'Noto Sans Linear A',
    'Noto Sans Linear B',
    'Noto Sans Lisu',
    'Noto Sans Lycian',
    'Noto Sans Lydian',
    'Noto Sans Mahajani',
    'Noto Sans Malayalam',
    'Noto Sans Mandaic',
    'Noto Sans Manichaean',
    'Noto Sans Marchen',
    'Noto Sans Masaram Gondi',
    'Noto Sans Math',
    'Noto Sans Mayan Numerals',
    'Noto Sans Medefaidrin',
    'Noto Sans Meetei Mayek',
    'Noto Sans Mende Kikakui',
    'Noto Sans Meroitic',
    'Noto Sans Miao',
    'Noto Sans Modi',
    'Noto Sans Mongolian',
    'Noto Sans Mono',
    'Noto Sans Mro',
    'Noto Sans Multani',
    'Noto Sans Myanmar',
    'Noto Sans Nabataean',
    'Noto Sans Nag Mundari',
    'Noto Sans Nandinagari',
    'Noto Sans New Tai Lue',
    'Noto Sans Newa',
    'Noto Sans NKo',
    'Noto Sans NKo Unjoined',
    'Noto Sans Nushu',
    'Noto Sans Ogham',
    'Noto Sans Ol Chiki',
    'Noto Sans Old Hungarian',
    'Noto Sans Old Italic',
    'Noto Sans Old North Arabian',
    'Noto Sans Old Permic',
    'Noto Sans Old Persian',
    'Noto Sans Old Sogdian',
    'Noto Sans Old South Arabian',
    'Noto Sans Old Turkic',
    'Noto Sans Oriya',
    'Noto Sans Osage',
    'Noto Sans Osmanya',
    'Noto Sans Pahawh Hmong',
    'Noto Sans Palmyrene',
    'Noto Sans Pau Cin Hau',
    'Noto Sans PhagsPa',
    'Noto Sans Phoenician',
    'Noto Sans Psalter Pahlavi',
    'Noto Sans Rejang',
    'Noto Sans Runic',
    'Noto Sans Samaritan',
    'Noto Sans Saurashtra',
    'Noto Sans SC',
    'Noto Sans Sharada',
    'Noto Sans Shavian',
    'Noto Sans Siddham',
    'Noto Sans SignWriting',
    'Noto Sans Sinhala',
    'Noto Sans Sogdian',
    'Noto Sans Sora Sompeng',
    'Noto Sans Soyombo',
    'Noto Sans Sundanese',
    'Noto Sans Sunuwar',
    'Noto Sans Syloti Nagri',
    'Noto Sans Symbols',
    'Noto Sans Symbols 2',
    'Noto Sans Syriac',
    'Noto Sans Syriac Eastern',
    'Noto Sans Syriac Western',
    'Noto Sans Tagalog',
    'Noto Sans Tagbanwa',
    'Noto Sans Tai Le',
    'Noto Sans Tai Tham',
    'Noto Sans Tai Viet',
    'Noto Sans Takri',
    'Noto Sans Tamil',
    'Noto Sans Tamil Supplement',
    'Noto Sans Tangsa',
    'Noto Sans TC',
    'Noto Sans Telugu',
    'Noto Sans Thaana',
    'Noto Sans Thai',
    'Noto Sans Thai Looped',
    'Noto Sans Tifinagh',
    'Noto Sans Tirhuta',
    'Noto Sans Ugaritic',
    'Noto Sans Vai',
    'Noto Sans Vithkuqi',
    'Noto Sans Wancho',
    'Noto Sans Warang Citi',
    'Noto Sans Yi',
    'Noto Sans Zanabazar Square',
    'Noto Serif',
    'Noto Serif Ahom',
    'Noto Serif Armenian',
    'Noto Serif Balinese',
    'Noto Serif Bengali',
    'Noto Serif Devanagari',
    'Noto Serif Display',
    'Noto Serif Dives Akuru',
    'Noto Serif Dogra',
    'Noto Serif Ethiopic',
    'Noto Serif Georgian',
    'Noto Serif Grantha',
    'Noto Serif Gujarati',
    'Noto Serif Gurmukhi',
    'Noto Serif Hebrew',
    'Noto Serif Hentaigana',
    'Noto Serif HK',
    'Noto Serif JP',
    'Noto Serif Kannada',
    'Noto Serif Khitan Small Script',
    'Noto Serif Khmer',
    'Noto Serif Khojki',
    'Noto Serif KR',
    'Noto Serif Lao',
    'Noto Serif Makasar',
    'Noto Serif Malayalam',
    'Noto Serif Myanmar',
    'Noto Serif NP Hmong',
    'Noto Serif Old Uyghur',
    'Noto Serif Oriya',
    'Noto Serif Ottoman Siyaq',
    'Noto Serif SC',
    'Noto Serif Sinhala',
    'Noto Serif Tamil',
    'Noto Serif Tangut',
    'Noto Serif TC',
    'Noto Serif Telugu',
    'Noto Serif Thai',
    'Noto Serif Tibetan',
    'Noto Serif Todhri',
    'Noto Serif Toto',
    'Noto Serif Vithkuqi',
    'Noto Serif Yezidi',
    'Noto Traditional Nushu',
    'Noto Znamenny Musical Notation',
    'Nova Cut',
    'Nova Flat',
    'Nova Mono',
    'Nova Oval',
    'Nova Round',
    'Nova Script',
    'Nova Slim',
    'Nova Square',
    'NTR',
    'Numans',
    'Nunito',
    'Nunito Sans',
    'Nuosu SIL',
    'Odibee Sans',
    'Odor Mean Chey',
    'Offside',
    'Oi',
    'Ojuju',
    'Old Standard TT',
    'Oldenburg',
    'Ole',
    'Oleo Script',
    'Oleo Script Swash Caps',
    'Onest',
    'Oooh Baby',
    'Open Sans',
    'Oranienbaum',
    'Orbit',
    'Orbitron',
    'Oregano',
    'Orelega One',
    'Orienta',
    'Original Surfer',
    'Oswald',
    'Outfit',
    'Over the Rainbow',
    'Overlock',
    'Overlock SC',
    'Overpass',
    'Overpass Mono',
    'Ovo',
    'Oxanium',
    'Oxygen',
    'Oxygen Mono',
    'Pacifico',
    'Padauk',
    'Padyakke Expanded One',
    'Palanquin',
    'Palanquin Dark',
    'Palette Mosaic',
    'Pangolin',
    'Paprika',
    'Parastoo',
    'Parisienne',
    'Parkinsans',
    'Passero One',
    'Passion One',
    'Passions Conflict',
    'Pathway Extreme',
    'Pathway Gothic One',
    'Patrick Hand',
    'Patrick Hand SC',
    'Pattaya',
    'Patua One',
    'Pavanam',
    'Paytone One',
    'Peddana',
    'Peralta',
    'Permanent Marker',
    'Petemoss',
    'Petit Formal Script',
    'Petrona',
    'Phetsarath',
    'Philosopher',
    'Phudu',
    'Piazzolla',
    'Piedra',
    'Pinyon Script',
    'Pirata One',
    'Pixelify Sans',
    'Plaster',
    'Platypi',
    'Play',
    'Playball',
    'Playfair',
    'Playfair Display',
    'Playfair Display SC',
    'Playpen Sans',
    'Playpen Sans Arabic',
    'Playpen Sans Deva',
    'Playpen Sans Hebrew',
    'Playpen Sans Thai',
    'Playwrite AR',
    'Playwrite AR Guides',
    'Playwrite AT',
    'Playwrite AT Guides',
    'Playwrite AU NSW',
    'Playwrite AU NSW Guides',
    'Playwrite AU QLD',
    'Playwrite AU QLD Guides',
    'Playwrite AU SA',
    'Playwrite AU SA Guides',
    'Playwrite AU TAS',
    'Playwrite AU TAS Guides',
    'Playwrite AU VIC',
    'Playwrite AU VIC Guides',
    'Playwrite BE VLG',
    'Playwrite BE VLG Guides',
    'Playwrite BE WAL',
    'Playwrite BE WAL Guides',
    'Playwrite BR',
    'Playwrite BR Guides',
    'Playwrite CA',
    'Playwrite CA Guides',
    'Playwrite CL',
    'Playwrite CL Guides',
    'Playwrite CO',
    'Playwrite CO Guides',
    'Playwrite CU',
    'Playwrite CU Guides',
    'Playwrite CZ',
    'Playwrite CZ Guides',
    'Playwrite DE Grund',
    'Playwrite DE Grund Guides',
    'Playwrite DE LA',
    'Playwrite DE LA Guides',
    'Playwrite DE SAS',
    'Playwrite DE SAS Guides',
    'Playwrite DE VA',
    'Playwrite DE VA Guides',
    'Playwrite DK Loopet',
    'Playwrite DK Loopet Guides',
    'Playwrite DK Uloopet',
    'Playwrite DK Uloopet Guides',
    'Playwrite ES',
    'Playwrite ES Deco',
    'Playwrite ES Deco Guides',
    'Playwrite ES Guides',
    'Playwrite FR Moderne',
    'Playwrite FR Moderne Guides',
    'Playwrite FR Trad',
    'Playwrite FR Trad Guides',
    'Playwrite GB J',
    'Playwrite GB J Guides',
    'Playwrite GB S',
    'Playwrite GB S Guides',
    'Playwrite HR',
    'Playwrite HR Guides',
    'Playwrite HR Lijeva',
    'Playwrite HR Lijeva Guides',
    'Playwrite HU',
    'Playwrite HU Guides',
    'Playwrite ID',
    'Playwrite ID Guides',
    'Playwrite IE',
    'Playwrite IE Guides',
    'Playwrite IN',
    'Playwrite IN Guides',
    'Playwrite IS',
    'Playwrite IS Guides',
    'Playwrite IT Moderna',
    'Playwrite IT Moderna Guides',
    'Playwrite IT Trad',
    'Playwrite IT Trad Guides',
    'Playwrite MX',
    'Playwrite MX Guides',
    'Playwrite NG Modern',
    'Playwrite NG Modern Guides',
    'Playwrite NL',
    'Playwrite NL Guides',
    'Playwrite NO',
    'Playwrite NO Guides',
    'Playwrite NZ',
    'Playwrite NZ Basic',
    'Playwrite NZ Basic Guides',
    'Playwrite NZ Guides',
    'Playwrite PE',
    'Playwrite PE Guides',
    'Playwrite PL',
    'Playwrite PL Guides',
    'Playwrite PT',
    'Playwrite PT Guides',
    'Playwrite RO',
    'Playwrite RO Guides',
    'Playwrite SK',
    'Playwrite SK Guides',
    'Playwrite TZ',
    'Playwrite TZ Guides',
    'Playwrite US Modern',
    'Playwrite US Modern Guides',
    'Playwrite US Trad',
    'Playwrite US Trad Guides',
    'Playwrite VN',
    'Playwrite VN Guides',
    'Playwrite ZA',
    'Playwrite ZA Guides',
    'Plus Jakarta Sans',
    'Pochaevsk',
    'Podkova',
    'Poetsen One',
    'Poiret One',
    'Poller One',
    'Poltawski Nowy',
    'Poly',
    'Pompiere',
    'Ponnala',
    'Ponomar',
    'Pontano Sans',
    'Poor Story',
    'Poppins',
    'Port Lligat Sans',
    'Port Lligat Slab',
    'Potta One',
    'Pragati Narrow',
    'Praise',
    'Prata',
    'Preahvihear',
    'Press Start 2P',
    'Pridi',
    'Princess Sofia',
    'Prociono',
    'Prompt',
    'Prosto One',
    'Protest Guerrilla',
    'Protest Revolution',
    'Protest Riot',
    'Protest Strike',
    'Proza Libre',
    'PT Mono',
    'PT Sans',
    'PT Sans Caption',
    'PT Sans Narrow',
    'PT Serif',
    'PT Serif Caption',
    'Public Sans',
    'Puppies Play',
    'Puritan',
    'Purple Purse',
    'Qahiri',
    'Quando',
    'Quantico',
    'Quattrocento',
    'Quattrocento Sans',
    'Questrial',
    'Quicksand',
    'Quintessential',
    'Qwigley',
    'Qwitcher Grypen',
    'Racing Sans One',
    'Radio Canada',
    'Radio Canada Big',
    'Radley',
    'Rajdhani',
    'Rakkas',
    'Raleway',
    'Raleway Dots',
    'Ramabhadra',
    'Ramaraja',
    'Rambla',
    'Rammetto One',
    'Rampart One',
    'Ramsina',
    'Ranchers',
    'Rancho',
    'Ranga',
    'Rasa',
    'Rationale',
    'Ravi Prakash',
    'Readex Pro',
    'Recursive',
    'Red Hat Display',
    'Red Hat Mono',
    'Red Hat Text',
    'Red Rose',
    'Redacted',
    'Redacted Script',
    'Reddit Mono',
    'Reddit Sans',
    'Reddit Sans Condensed',
    'Redressed',
    'Reem Kufi',
    'Reem Kufi Fun',
    'Reem Kufi Ink',
    'Reenie Beanie',
    'Reggae One',
    'REM',
    'Rethink Sans',
    'Revalia',
    'Rhodium Libre',
    'Ribeye',
    'Ribeye Marrow',
    'Righteous',
    'Risque',
    'Road Rage',
    'Roboto',
    'Roboto Condensed',
    'Roboto Flex',
    'Roboto Mono',
    'Roboto Serif',
    'Roboto Slab',
    'Rochester',
    'Rock 3D',
    'Rock Salt',
    'RocknRoll One',
    'Rokkitt',
    'Romanesco',
    'Ropa Sans',
    'Rosario',
    'Rosarivo',
    'Rouge Script',
    'Rowdies',
    'Rozha One',
    'Rubik',
    'Rubik 80s Fade',
    'Rubik Beastly',
    'Rubik Broken Fax',
    'Rubik Bubbles',
    'Rubik Burned',
    'Rubik Dirt',
    'Rubik Distressed',
    'Rubik Doodle Shadow',
    'Rubik Doodle Triangles',
    'Rubik Gemstones',
    'Rubik Glitch',
    'Rubik Glitch Pop',
    'Rubik Iso',
    'Rubik Lines',
    'Rubik Maps',
    'Rubik Marker Hatch',
    'Rubik Maze',
    'Rubik Microbe',
    'Rubik Mono One',
    'Rubik Moonrocks',
    'Rubik Pixels',
    'Rubik Puddles',
    'Rubik Scribble',
    'Rubik Spray Paint',
    'Rubik Storm',
    'Rubik Vinyl',
    'Rubik Wet Paint',
    'Ruda',
    'Rufina',
    'Ruge Boogie',
    'Ruluko',
    'Rum Raisin',
    'Ruslan Display',
    'Russo One',
    'Ruthie',
    'Ruwudu',
    'Rye',
    'Sacramento',
    'Sahitya',
    'Sail',
    'Saira',
    'Saira Condensed',
    'Saira Extra Condensed',
    'Saira Semi Condensed',
    'Saira Stencil One',
    'Salsa',
    'Sanchez',
    'Sancreek',
    'Sankofa Display',
    'Sansation',
    'Sansita',
    'Sansita Swashed',
    'Sarabun',
    'Sarala',
    'Sarina',
    'Sarpanch',
    'Sassy Frass',
    'Satisfy',
    'Savate',
    'Sawarabi Gothic',
    'Sawarabi Mincho',
    'Scada',
    'Scheherazade New',
    'Schibsted Grotesk',
    'Schoolbell',
    'Science Gothic',
    'Scope One',
    'Seaweed Script',
    'Secular One',
    'Sedan',
    'Sedan SC',
    'Sedgwick Ave',
    'Sedgwick Ave Display',
    'Sekuya',
    'Sen',
    'Send Flowers',
    'Sevillana',
    'Seymour One',
    'Shadows Into Light',
    'Shadows Into Light Two',
    'Shafarik',
    'Shalimar',
    'Shantell Sans',
    'Shanti',
    'Share',
    'Share Tech',
    'Share Tech Mono',
    'Shippori Antique',
    'Shippori Antique B1',
    'Shippori Mincho',
    'Shippori Mincho B1',
    'Shizuru',
    'Shojumaru',
    'Short Stack',
    'Shrikhand',
    'Siemreap',
    'Sigmar',
    'Sigmar One',
    'Signika',
    'Signika Negative',
    'Silkscreen',
    'Simonetta',
    'Single Day',
    'Sintony',
    'Sirin Stencil',
    'Sirivennela',
    'Six Caps',
    'Sixtyfour',
    'Sixtyfour Convergence',
    'Skranji',
    'Slabo 13px',
    'Slabo 27px',
    'Slackey',
    'Slackside One',
    'Smokum',
    'Smooch',
    'Smooch Sans',
    'Smythe',
    'SN Pro',
    'Sniglet',
    'Snippet',
    'Snowburst One',
    'Sofadi One',
    'Sofia',
    'Sofia Sans',
    'Sofia Sans Condensed',
    'Sofia Sans Extra Condensed',
    'Sofia Sans Semi Condensed',
    'Solitreo',
    'Solway',
    'Sometype Mono',
    'Song Myung',
    'Sono',
    'Sonsie One',
    'Sora',
    'Sorts Mill Goudy',
    'Sour Gummy',
    'Source Code Pro',
    'Source Sans 3',
    'Source Serif 4',
    'Space Grotesk',
    'Space Mono',
    'Special Elite',
    'Special Gothic',
    'Special Gothic Condensed One',
    'Special Gothic Expanded One',
    'Spectral',
    'Spectral SC',
    'Spicy Rice',
    'Spinnaker',
    'Spirax',
    'Splash',
    'Spline Sans',
    'Spline Sans Mono',
    'Squada One',
    'Square Peg',
    'Sree Krushnadevaraya',
    'Sriracha',
    'Srisakdi',
    'Staatliches',
    'Stack Sans Headline',
    'Stack Sans Notch',
    'Stack Sans Text',
    'Stalemate',
    'Stalinist One',
    'Stardos Stencil',
    'Stick',
    'Stick No Bills',
    'Stint Ultra Condensed',
    'Stint Ultra Expanded',
    'STIX Two Text',
    'Stoke',
    'Story Script',
    'Strait',
    'Style Script',
    'Stylish',
    'Sue Ellen Francisco',
    'Suez One',
    'Sulphur Point',
    'Sumana',
    'Sunflower',
    'Sunshiney',
    'Supermercado One',
    'Sura',
    'Suranna',
    'Suravaram',
    'SUSE',
    'SUSE Mono',
    'Suwannaphum',
    'Swanky and Moo Moo',
    'Syncopate',
    'Syne',
    'Syne Mono',
    'Syne Tactile',
    'Tac One',
    'Tagesschrift',
    'Tai Heritage Pro',
    'Tajawal',
    'Tangerine',
    'Tapestry',
    'Taprom',
    'TASA Explorer',
    'TASA Orbiter',
    'Tauri',
    'Taviraj',
    'Teachers',
    'Teko',
    'Tektur',
    'Telex',
    'Tenali Ramakrishna',
    'Tenor Sans',
    'Text Me One',
    'Texturina',
    'Thasadith',
    'The Girl Next Door',
    'The Nautigal',
    'Tienne',
    'TikTok Sans',
    'Tillana',
    'Tilt Neon',
    'Tilt Prism',
    'Tilt Warp',
    'Timmana',
    'Tinos',
    'Tiny5',
    'Tiro Bangla',
    'Tiro Devanagari Hindi',
    'Tiro Devanagari Marathi',
    'Tiro Devanagari Sanskrit',
    'Tiro Gurmukhi',
    'Tiro Kannada',
    'Tiro Tamil',
    'Tiro Telugu',
    'Tirra',
    'Titan One',
    'Titillium Web',
    'Tomorrow',
    'Tourney',
    'Trade Winds',
    'Train One',
    'Triodion',
    'Trirong',
    'Trispace',
    'Trocchi',
    'Trochut',
    'Truculenta',
    'Trykker',
    'Tsukimi Rounded',
    'Tuffy',
    'Tulpen One',
    'Turret Road',
    'Twinkle Star',
    'Ubuntu',
    'Ubuntu Condensed',
    'Ubuntu Mono',
    'Ubuntu Sans',
    'Ubuntu Sans Mono',
    'Uchen',
    'Ultra',
    'Unbounded',
    'Uncial Antiqua',
    'Underdog',
    'Unica One',
    'UnifrakturCook',
    'UnifrakturMaguntia',
    'Unkempt',
    'Unlock',
    'Unna',
    'UoqMunThenKhung',
    'Updock',
    'Urbanist',
    'Vampiro One',
    'Varela',
    'Varela Round',
    'Varta',
    'Vast Shadow',
    'Vazirmatn',
    'Vend Sans',
    'Vesper Libre',
    'Viaoda Libre',
    'Vibes',
    'Vibur',
    'Victor Mono',
    'Vidaloka',
    'Viga',
    'Vina Sans',
    'Voces',
    'Volkhov',
    'Vollkorn',
    'Vollkorn SC',
    'Voltaire',
    'VT323',
    'Vujahday Script',
    'Waiting for the Sunrise',
    'Wallpoet',
    'Walter Turncoat',
    'Warnes',
    'Water Brush',
    'Waterfall',
    'Wavefont',
    'WDXL Lubrifont JP N',
    'WDXL Lubrifont SC',
    'WDXL Lubrifont TC',
    'Wellfleet',
    'Wendy One',
    'Whisper',
    'WindSong',
    'Winky Rough',
    'Winky Sans',
    'Wire One',
    'Wittgenstein',
    'Wix Madefor Display',
    'Wix Madefor Text',
    'Work Sans',
    'Workbench',
    'Xanh Mono',
    'Yaldevi',
    'Yanone Kaffeesatz',
    'Yantramanav',
    'Yarndings 12',
    'Yarndings 12 Charted',
    'Yarndings 20',
    'Yarndings 20 Charted',
    'Yatra One',
    'Yellowtail',
    'Yeon Sung',
    'Yeseva One',
    'Yesteryear',
    'Yomogi',
    'Young Serif',
    'Yrsa',
    'Ysabeau',
    'Ysabeau Infant',
    'Ysabeau Office',
    'Ysabeau SC',
    'Yuji Boku',
    'Yuji Hentaigana Akari',
    'Yuji Hentaigana Akebono',
    'Yuji Mai',
    'Yuji Syuku',
    'Yusei Magic',
    'Zain',
    'Zalando Sans',
    'Zalando Sans Expanded',
    'Zalando Sans SemiExpanded',
    'ZCOOL KuaiLe',
    'ZCOOL QingKe HuangYou',
    'ZCOOL XiaoWei',
    'Zen Antique',
    'Zen Antique Soft',
    'Zen Dots',
    'Zen Kaku Gothic Antique',
    'Zen Kaku Gothic New',
    'Zen Kurenaido',
    'Zen Loop',
    'Zen Maru Gothic',
    'Zen Old Mincho',
    'Zen Tokyo Zoo',
    'Zeyada',
    'Zhi Mang Xing',
    'Zilla Slab',
    'Zilla Slab Highlight'
];

const GOOGLE_FONT_METADATA = {
    'ABeeZee': { category: 'sans-serif', classifications: [] },
    'Abel': { category: 'sans-serif', classifications: [] },
    'Abhaya Libre': { category: 'serif', classifications: [] },
    'Aboreto': { category: 'display', classifications: ['display'] },
    'Abril Fatface': { category: 'display', classifications: ['display'] },
    'Abyssinica SIL': { category: 'serif', classifications: [] },
    'Aclonica': { category: 'sans-serif', classifications: ['display'] },
    'Acme': { category: 'sans-serif', classifications: ['display'] },
    'Actor': { category: 'sans-serif', classifications: [] },
    'Adamina': { category: 'serif', classifications: [] },
    'ADLaM Display': { category: 'display', classifications: ['display'] },
    'Advent Pro': { category: 'sans-serif', classifications: ['display'] },
    'Afacad': { category: 'sans-serif', classifications: [] },
    'Afacad Flux': { category: 'sans-serif', classifications: [] },
    'Agbalumo': { category: 'display', classifications: ['display'] },
    'Agdasima': { category: 'sans-serif', classifications: ['display'] },
    'Agu Display': { category: 'display', classifications: ['display'] },
    'Aguafina Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Akatab': { category: 'sans-serif', classifications: [] },
    'Akaya Kanadaka': { category: 'display', classifications: ['display'] },
    'Akaya Telivigala': { category: 'display', classifications: ['display'] },
    'Akronim': { category: 'display', classifications: ['display'] },
    'Akshar': { category: 'sans-serif', classifications: [] },
    'Aladin': { category: 'display', classifications: ['display'] },
    'Alan Sans': { category: 'sans-serif', classifications: [] },
    'Alata': { category: 'sans-serif', classifications: [] },
    'Alatsi': { category: 'sans-serif', classifications: [] },
    'Albert Sans': { category: 'sans-serif', classifications: [] },
    'Aldrich': { category: 'sans-serif', classifications: ['display'] },
    'Alef': { category: 'sans-serif', classifications: [] },
    'Alegreya': { category: 'serif', classifications: [] },
    'Alegreya Sans': { category: 'sans-serif', classifications: [] },
    'Alegreya Sans SC': { category: 'sans-serif', classifications: [] },
    'Alegreya SC': { category: 'serif', classifications: [] },
    'Aleo': { category: 'serif', classifications: [] },
    'Alex Brush': { category: 'handwriting', classifications: ['handwriting'] },
    'Alexandria': { category: 'sans-serif', classifications: [] },
    'Alfa Slab One': { category: 'display', classifications: ['display'] },
    'Alice': { category: 'serif', classifications: [] },
    'Alike': { category: 'serif', classifications: [] },
    'Alike Angular': { category: 'serif', classifications: ['display'] },
    'Alkalami': { category: 'serif', classifications: [] },
    'Alkatra': { category: 'display', classifications: ['display'] },
    'Allan': { category: 'display', classifications: ['display'] },
    'Allerta': { category: 'sans-serif', classifications: [] },
    'Allerta Stencil': { category: 'sans-serif', classifications: ['display'] },
    'Allison': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Allkin': { category: 'display', classifications: ['display'] },
    'Allura': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Almarai': { category: 'sans-serif', classifications: [] },
    'Almendra': { category: 'serif', classifications: ['display'] },
    'Almendra Display': { category: 'display', classifications: ['display'] },
    'Almendra SC': { category: 'serif', classifications: ['display'] },
    'Alumni Sans': { category: 'sans-serif', classifications: ['display'] },
    'Alumni Sans Collegiate One': { category: 'sans-serif', classifications: ['display'] },
    'Alumni Sans Inline One': { category: 'display', classifications: ['display'] },
    'Alumni Sans Pinstripe': { category: 'sans-serif', classifications: ['display'] },
    'Alumni Sans SC': { category: 'sans-serif', classifications: ['display'] },
    'Alyamama': { category: 'serif', classifications: [] },
    'Amarante': { category: 'display', classifications: ['display'] },
    'Amaranth': { category: 'sans-serif', classifications: [] },
    'Amarna': { category: 'sans-serif', classifications: [] },
    'Amatic SC': { category: 'handwriting', classifications: ['display'] },
    'Amethysta': { category: 'serif', classifications: [] },
    'Amiko': { category: 'sans-serif', classifications: [] },
    'Amiri': { category: 'serif', classifications: [] },
    'Amiri Quran': { category: 'serif', classifications: [] },
    'Amita': { category: 'handwriting', classifications: ['display'] },
    'Anaheim': { category: 'sans-serif', classifications: [] },
    'Ancizar Sans': { category: 'sans-serif', classifications: [] },
    'Ancizar Serif': { category: 'serif', classifications: [] },
    'Andada Pro': { category: 'serif', classifications: [] },
    'Andika': { category: 'sans-serif', classifications: [] },
    'Anek Bangla': { category: 'sans-serif', classifications: [] },
    'Anek Devanagari': { category: 'sans-serif', classifications: [] },
    'Anek Gujarati': { category: 'sans-serif', classifications: [] },
    'Anek Gurmukhi': { category: 'sans-serif', classifications: [] },
    'Anek Kannada': { category: 'sans-serif', classifications: [] },
    'Anek Latin': { category: 'sans-serif', classifications: [] },
    'Anek Malayalam': { category: 'sans-serif', classifications: [] },
    'Anek Odia': { category: 'sans-serif', classifications: [] },
    'Anek Tamil': { category: 'sans-serif', classifications: [] },
    'Anek Telugu': { category: 'sans-serif', classifications: [] },
    'Angkor': { category: 'display', classifications: ['display'] },
    'Annapurna SIL': { category: 'serif', classifications: [] },
    'Annie Use Your Telescope': { category: 'handwriting', classifications: ['handwriting'] },
    'Anonymous Pro': { category: 'monospace', classifications: ['monospace'] },
    'Anta': { category: 'sans-serif', classifications: [] },
    'Antic': { category: 'sans-serif', classifications: [] },
    'Antic Didone': { category: 'serif', classifications: [] },
    'Antic Slab': { category: 'serif', classifications: [] },
    'Anton': { category: 'sans-serif', classifications: ['display'] },
    'Anton SC': { category: 'sans-serif', classifications: ['display'] },
    'Antonio': { category: 'sans-serif', classifications: ['display'] },
    'Anuphan': { category: 'sans-serif', classifications: [] },
    'Anybody': { category: 'display', classifications: ['display'] },
    'Aoboshi One': { category: 'serif', classifications: [] },
    'AR One Sans': { category: 'sans-serif', classifications: [] },
    'Arapey': { category: 'serif', classifications: [] },
    'Arbutus': { category: 'serif', classifications: ['display'] },
    'Arbutus Slab': { category: 'serif', classifications: [] },
    'Architects Daughter': { category: 'handwriting', classifications: ['handwriting'] },
    'Archivo': { category: 'sans-serif', classifications: [] },
    'Archivo Black': { category: 'sans-serif', classifications: ['display'] },
    'Archivo Narrow': { category: 'sans-serif', classifications: [] },
    'Are You Serious': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Aref Ruqaa': { category: 'serif', classifications: [] },
    'Aref Ruqaa Ink': { category: 'serif', classifications: ['display'] },
    'Arima': { category: 'display', classifications: ['display'] },
    'Arimo': { category: 'sans-serif', classifications: [] },
    'Arizonia': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Armata': { category: 'sans-serif', classifications: [] },
    'Arsenal': { category: 'sans-serif', classifications: [] },
    'Arsenal SC': { category: 'sans-serif', classifications: [] },
    'Artifika': { category: 'serif', classifications: [] },
    'Arvo': { category: 'serif', classifications: [] },
    'Arya': { category: 'sans-serif', classifications: [] },
    'Asap': { category: 'sans-serif', classifications: [] },
    'Asap Condensed': { category: 'sans-serif', classifications: [] },
    'Asar': { category: 'serif', classifications: [] },
    'Asimovian': { category: 'sans-serif', classifications: ['display'] },
    'Asset': { category: 'display', classifications: ['display'] },
    'Assistant': { category: 'sans-serif', classifications: [] },
    'Asta Sans': { category: 'sans-serif', classifications: [] },
    'Astloch': { category: 'display', classifications: ['display'] },
    'Asul': { category: 'serif', classifications: ['display'] },
    'Athiti': { category: 'sans-serif', classifications: [] },
    'Atkinson Hyperlegible': { category: 'sans-serif', classifications: [] },
    'Atkinson Hyperlegible Mono': { category: 'sans-serif', classifications: [] },
    'Atkinson Hyperlegible Next': { category: 'sans-serif', classifications: [] },
    'Atma': { category: 'display', classifications: ['display'] },
    'Atomic Age': { category: 'display', classifications: ['display'] },
    'Aubrey': { category: 'display', classifications: ['display'] },
    'Audiowide': { category: 'display', classifications: ['display'] },
    'Autour One': { category: 'display', classifications: ['display'] },
    'Average': { category: 'serif', classifications: [] },
    'Average Sans': { category: 'sans-serif', classifications: [] },
    'Averia Gruesa Libre': { category: 'display', classifications: ['display'] },
    'Averia Libre': { category: 'display', classifications: ['display'] },
    'Averia Sans Libre': { category: 'display', classifications: ['display'] },
    'Averia Serif Libre': { category: 'display', classifications: ['display'] },
    'Azeret Mono': { category: 'monospace', classifications: ['monospace'] },
    'B612': { category: 'sans-serif', classifications: [] },
    'B612 Mono': { category: 'monospace', classifications: ['monospace'] },
    'Babylonica': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Bacasime Antique': { category: 'serif', classifications: [] },
    'Bad Script': { category: 'handwriting', classifications: ['handwriting'] },
    'Badeen Display': { category: 'display', classifications: ['display'] },
    'Bagel Fat One': { category: 'display', classifications: ['display'] },
    'Bahiana': { category: 'display', classifications: ['display'] },
    'Bahianita': { category: 'display', classifications: ['display'] },
    'Bai Jamjuree': { category: 'sans-serif', classifications: [] },
    'Bakbak One': { category: 'display', classifications: ['display'] },
    'Ballet': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Baloo 2': { category: 'display', classifications: ['display'] },
    'Baloo Bhai 2': { category: 'display', classifications: ['display'] },
    'Baloo Bhaijaan 2': { category: 'display', classifications: ['display'] },
    'Baloo Bhaina 2': { category: 'display', classifications: ['display'] },
    'Baloo Chettan 2': { category: 'display', classifications: ['display'] },
    'Baloo Da 2': { category: 'display', classifications: ['display'] },
    'Baloo Paaji 2': { category: 'display', classifications: ['display'] },
    'Baloo Tamma 2': { category: 'display', classifications: ['display'] },
    'Baloo Tammudu 2': { category: 'display', classifications: ['display'] },
    'Baloo Thambi 2': { category: 'display', classifications: ['display'] },
    'Balsamiq Sans': { category: 'display', classifications: ['display'] },
    'Balthazar': { category: 'serif', classifications: [] },
    'Bangers': { category: 'display', classifications: ['display'] },
    'Barlow': { category: 'sans-serif', classifications: [] },
    'Barlow Condensed': { category: 'sans-serif', classifications: [] },
    'Barlow Semi Condensed': { category: 'sans-serif', classifications: [] },
    'Barriecito': { category: 'display', classifications: ['display'] },
    'Barrio': { category: 'display', classifications: ['display'] },
    'Basic': { category: 'sans-serif', classifications: [] },
    'Baskervville': { category: 'serif', classifications: [] },
    'Baskervville SC': { category: 'serif', classifications: [] },
    'Battambang': { category: 'display', classifications: ['display'] },
    'Baumans': { category: 'display', classifications: ['display'] },
    'Bayon': { category: 'sans-serif', classifications: ['display'] },
    'BBH Bartle': { category: 'sans-serif', classifications: [] },
    'BBH Bogle': { category: 'sans-serif', classifications: [] },
    'BBH Hegarty': { category: 'sans-serif', classifications: [] },
    'Be Vietnam Pro': { category: 'sans-serif', classifications: [] },
    'Beau Rivage': { category: 'handwriting', classifications: ['handwriting'] },
    'Bebas Neue': { category: 'sans-serif', classifications: ['display'] },
    'Beiruti': { category: 'sans-serif', classifications: [] },
    'Belanosima': { category: 'sans-serif', classifications: ['display'] },
    'Belgrano': { category: 'serif', classifications: [] },
    'Bellefair': { category: 'serif', classifications: [] },
    'Belleza': { category: 'sans-serif', classifications: [] },
    'Bellota': { category: 'display', classifications: ['display'] },
    'Bellota Text': { category: 'display', classifications: ['display'] },
    'BenchNine': { category: 'sans-serif', classifications: [] },
    'Benne': { category: 'serif', classifications: [] },
    'Bentham': { category: 'serif', classifications: [] },
    'Berkshire Swash': { category: 'handwriting', classifications: ['display'] },
    'Besley': { category: 'serif', classifications: [] },
    'Betania Patmos': { category: 'handwriting', classifications: ['handwriting'] },
    'Betania Patmos GDL': { category: 'handwriting', classifications: ['handwriting'] },
    'Betania Patmos In': { category: 'handwriting', classifications: ['handwriting'] },
    'Betania Patmos In GDL': { category: 'handwriting', classifications: ['handwriting'] },
    'Beth Ellen': { category: 'handwriting', classifications: ['handwriting'] },
    'Bevan': { category: 'serif', classifications: ['display'] },
    'BhuTuka Expanded One': { category: 'serif', classifications: ['display'] },
    'Big Shoulders': { category: 'display', classifications: ['display'] },
    'Big Shoulders Inline': { category: 'display', classifications: ['display'] },
    'Big Shoulders Stencil': { category: 'display', classifications: ['display'] },
    'Bigelow Rules': { category: 'display', classifications: ['display'] },
    'Bigshot One': { category: 'display', classifications: ['display'] },
    'Bilbo': { category: 'handwriting', classifications: ['handwriting'] },
    'Bilbo Swash Caps': { category: 'handwriting', classifications: ['handwriting'] },
    'BioRhyme': { category: 'serif', classifications: [] },
    'BioRhyme Expanded': { category: 'serif', classifications: ['display'] },
    'Birthstone': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Birthstone Bounce': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Biryani': { category: 'sans-serif', classifications: [] },
    'Bitcount': { category: 'display', classifications: ['display'] },
    'Bitcount Grid Double': { category: 'display', classifications: ['display'] },
    'Bitcount Grid Double Ink': { category: 'display', classifications: ['display'] },
    'Bitcount Grid Single': { category: 'display', classifications: ['display'] },
    'Bitcount Grid Single Ink': { category: 'display', classifications: ['display'] },
    'Bitcount Ink': { category: 'display', classifications: ['display'] },
    'Bitcount Prop Double': { category: 'display', classifications: ['display'] },
    'Bitcount Prop Double Ink': { category: 'display', classifications: ['display'] },
    'Bitcount Prop Single': { category: 'display', classifications: ['display'] },
    'Bitcount Prop Single Ink': { category: 'display', classifications: ['display'] },
    'Bitcount Single': { category: 'display', classifications: ['display'] },
    'Bitcount Single Ink': { category: 'display', classifications: ['display'] },
    'Bitter': { category: 'serif', classifications: [] },
    'BIZ UDGothic': { category: 'sans-serif', classifications: [] },
    'BIZ UDMincho': { category: 'serif', classifications: [] },
    'BIZ UDPGothic': { category: 'sans-serif', classifications: [] },
    'BIZ UDPMincho': { category: 'serif', classifications: [] },
    'Black And White Picture': { category: 'display', classifications: ['display'] },
    'Black Han Sans': { category: 'sans-serif', classifications: ['display'] },
    'Black Ops One': { category: 'display', classifications: ['display'] },
    'Blaka': { category: 'display', classifications: ['display'] },
    'Blaka Hollow': { category: 'display', classifications: ['display'] },
    'Blaka Ink': { category: 'display', classifications: ['display'] },
    'Blinker': { category: 'sans-serif', classifications: [] },
    'Bodoni Moda': { category: 'serif', classifications: [] },
    'Bodoni Moda SC': { category: 'serif', classifications: [] },
    'Bokor': { category: 'display', classifications: ['display'] },
    'Boldonse': { category: 'display', classifications: ['display'] },
    'Bona Nova': { category: 'serif', classifications: [] },
    'Bona Nova SC': { category: 'serif', classifications: [] },
    'Bonbon': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Bonheur Royale': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Boogaloo': { category: 'display', classifications: ['display'] },
    'Borel': { category: 'handwriting', classifications: ['handwriting'] },
    'Bowlby One': { category: 'display', classifications: ['display'] },
    'Bowlby One SC': { category: 'display', classifications: ['display'] },
    'Bpmf Huninn': { category: 'sans-serif', classifications: [] },
    'Bpmf Iansui': { category: 'handwriting', classifications: ['handwriting'] },
    'Bpmf Zihi Kai Std': { category: 'sans-serif', classifications: [] },
    'Braah One': { category: 'sans-serif', classifications: ['display'] },
    'Brawler': { category: 'serif', classifications: [] },
    'Bree Serif': { category: 'serif', classifications: [] },
    'Bricolage Grotesque': { category: 'sans-serif', classifications: ['display'] },
    'Bruno Ace': { category: 'display', classifications: ['display'] },
    'Bruno Ace SC': { category: 'display', classifications: ['display'] },
    'Brygada 1918': { category: 'serif', classifications: [] },
    'Bubblegum Sans': { category: 'display', classifications: ['display'] },
    'Bubbler One': { category: 'sans-serif', classifications: [] },
    'Buda': { category: 'display', classifications: ['display'] },
    'Buenard': { category: 'serif', classifications: [] },
    'Bungee': { category: 'display', classifications: ['display'] },
    'Bungee Hairline': { category: 'display', classifications: ['display'] },
    'Bungee Inline': { category: 'display', classifications: ['display'] },
    'Bungee Outline': { category: 'display', classifications: ['display'] },
    'Bungee Shade': { category: 'display', classifications: ['display'] },
    'Bungee Spice': { category: 'display', classifications: ['display'] },
    'Bungee Tint': { category: 'display', classifications: ['display'] },
    'Butcherman': { category: 'display', classifications: ['display'] },
    'Butterfly Kids': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Bytesized': { category: 'sans-serif', classifications: [] },
    'Cabin': { category: 'sans-serif', classifications: [] },
    'Cabin Condensed': { category: 'sans-serif', classifications: [] },
    'Cabin Sketch': { category: 'display', classifications: ['display'] },
    'Cactus Classical Serif': { category: 'serif', classifications: [] },
    'Caesar Dressing': { category: 'display', classifications: ['display'] },
    'Cagliostro': { category: 'sans-serif', classifications: [] },
    'Cairo': { category: 'sans-serif', classifications: [] },
    'Cairo Play': { category: 'sans-serif', classifications: [] },
    'Cal Sans': { category: 'sans-serif', classifications: [] },
    'Caladea': { category: 'serif', classifications: [] },
    'Calistoga': { category: 'display', classifications: ['display'] },
    'Calligraffitti': { category: 'handwriting', classifications: ['handwriting'] },
    'Cambay': { category: 'sans-serif', classifications: [] },
    'Cambo': { category: 'serif', classifications: [] },
    'Candal': { category: 'sans-serif', classifications: [] },
    'Cantarell': { category: 'sans-serif', classifications: [] },
    'Cantata One': { category: 'serif', classifications: [] },
    'Cantora One': { category: 'sans-serif', classifications: [] },
    'Caprasimo': { category: 'display', classifications: ['display'] },
    'Capriola': { category: 'sans-serif', classifications: [] },
    'Caramel': { category: 'handwriting', classifications: ['handwriting'] },
    'Carattere': { category: 'handwriting', classifications: ['handwriting'] },
    'Cardo': { category: 'serif', classifications: [] },
    'Carlito': { category: 'sans-serif', classifications: [] },
    'Carme': { category: 'sans-serif', classifications: [] },
    'Carrois Gothic': { category: 'sans-serif', classifications: [] },
    'Carrois Gothic SC': { category: 'sans-serif', classifications: [] },
    'Carter One': { category: 'display', classifications: ['display'] },
    'Cascadia Code': { category: 'sans-serif', classifications: [] },
    'Cascadia Mono': { category: 'sans-serif', classifications: [] },
    'Castoro': { category: 'serif', classifications: [] },
    'Castoro Titling': { category: 'display', classifications: ['display'] },
    'Catamaran': { category: 'sans-serif', classifications: [] },
    'Caudex': { category: 'serif', classifications: ['display'] },
    'Cause': { category: 'handwriting', classifications: ['handwriting'] },
    'Caveat': { category: 'handwriting', classifications: ['handwriting'] },
    'Caveat Brush': { category: 'handwriting', classifications: ['handwriting'] },
    'Cedarville Cursive': { category: 'handwriting', classifications: ['handwriting'] },
    'Ceviche One': { category: 'display', classifications: ['display'] },
    'Chakra Petch': { category: 'sans-serif', classifications: ['display'] },
    'Changa': { category: 'sans-serif', classifications: ['display'] },
    'Changa One': { category: 'display', classifications: ['display'] },
    'Chango': { category: 'display', classifications: ['display'] },
    'Charis SIL': { category: 'serif', classifications: [] },
    'Charm': { category: 'handwriting', classifications: ['handwriting'] },
    'Charmonman': { category: 'handwriting', classifications: ['handwriting'] },
    'Chathura': { category: 'sans-serif', classifications: [] },
    'Chau Philomene One': { category: 'sans-serif', classifications: [] },
    'Chela One': { category: 'display', classifications: ['display'] },
    'Chelsea Market': { category: 'display', classifications: ['display'] },
    'Chenla': { category: 'display', classifications: ['display'] },
    'Cherish': { category: 'handwriting', classifications: ['handwriting'] },
    'Cherry Bomb One': { category: 'display', classifications: ['display'] },
    'Cherry Cream Soda': { category: 'display', classifications: ['display'] },
    'Cherry Swash': { category: 'display', classifications: ['display'] },
    'Chewy': { category: 'display', classifications: ['display'] },
    'Chicle': { category: 'display', classifications: ['display'] },
    'Chilanka': { category: 'handwriting', classifications: ['handwriting'] },
    'Chiron GoRound TC': { category: 'sans-serif', classifications: [] },
    'Chiron Hei HK': { category: 'sans-serif', classifications: [] },
    'Chiron Sung HK': { category: 'serif', classifications: [] },
    'Chivo': { category: 'sans-serif', classifications: [] },
    'Chivo Mono': { category: 'monospace', classifications: ['monospace'] },
    'Chocolate Classical Sans': { category: 'sans-serif', classifications: [] },
    'Chokokutai': { category: 'display', classifications: ['display'] },
    'Chonburi': { category: 'display', classifications: ['display'] },
    'Cinzel': { category: 'serif', classifications: [] },
    'Cinzel Decorative': { category: 'display', classifications: ['display'] },
    'Clicker Script': { category: 'handwriting', classifications: ['handwriting'] },
    'Climate Crisis': { category: 'display', classifications: ['display'] },
    'Coda': { category: 'display', classifications: ['display'] },
    'Codystar': { category: 'display', classifications: ['display'] },
    'Coiny': { category: 'display', classifications: ['display'] },
    'Combo': { category: 'display', classifications: ['display'] },
    'Comfortaa': { category: 'display', classifications: ['display'] },
    'Comforter': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Comforter Brush': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Comic Neue': { category: 'handwriting', classifications: ['handwriting'] },
    'Comic Relief': { category: 'display', classifications: ['display'] },
    'Coming Soon': { category: 'handwriting', classifications: ['handwriting'] },
    'Comme': { category: 'sans-serif', classifications: [] },
    'Commissioner': { category: 'sans-serif', classifications: [] },
    'Concert One': { category: 'display', classifications: ['display'] },
    'Condiment': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Content': { category: 'display', classifications: ['display'] },
    'Contrail One': { category: 'display', classifications: ['display'] },
    'Convergence': { category: 'sans-serif', classifications: [] },
    'Cookie': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Copse': { category: 'serif', classifications: [] },
    'Coral Pixels': { category: 'display', classifications: ['display'] },
    'Corben': { category: 'display', classifications: ['display'] },
    'Corinthia': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Cormorant': { category: 'serif', classifications: [] },
    'Cormorant Garamond': { category: 'serif', classifications: [] },
    'Cormorant Infant': { category: 'serif', classifications: [] },
    'Cormorant SC': { category: 'serif', classifications: [] },
    'Cormorant Unicase': { category: 'serif', classifications: [] },
    'Cormorant Upright': { category: 'serif', classifications: [] },
    'Cossette Texte': { category: 'sans-serif', classifications: [] },
    'Cossette Titre': { category: 'sans-serif', classifications: [] },
    'Courgette': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Courier Prime': { category: 'monospace', classifications: ['monospace'] },
    'Cousine': { category: 'monospace', classifications: ['monospace'] },
    'Coustard': { category: 'serif', classifications: [] },
    'Covered By Your Grace': { category: 'handwriting', classifications: ['handwriting'] },
    'Crafty Girls': { category: 'handwriting', classifications: ['handwriting'] },
    'Creepster': { category: 'display', classifications: ['display'] },
    'Crete Round': { category: 'serif', classifications: [] },
    'Crimson Pro': { category: 'serif', classifications: [] },
    'Crimson Text': { category: 'serif', classifications: [] },
    'Croissant One': { category: 'display', classifications: ['display'] },
    'Crushed': { category: 'display', classifications: ['display'] },
    'Cuprum': { category: 'sans-serif', classifications: [] },
    'Cute Font': { category: 'display', classifications: ['display'] },
    'Cutive': { category: 'serif', classifications: ['display'] },
    'Cutive Mono': { category: 'monospace', classifications: ['monospace'] },
    'Dai Banna SIL': { category: 'serif', classifications: [] },
    'Damion': { category: 'handwriting', classifications: ['handwriting'] },
    'Dancing Script': { category: 'handwriting', classifications: ['handwriting'] },
    'Danfo': { category: 'serif', classifications: ['display'] },
    'Dangrek': { category: 'display', classifications: ['display'] },
    'Darker Grotesque': { category: 'sans-serif', classifications: [] },
    'Darumadrop One': { category: 'display', classifications: ['display'] },
    'David Libre': { category: 'serif', classifications: [] },
    'Dawning of a New Day': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Days One': { category: 'sans-serif', classifications: ['display'] },
    'Dekko': { category: 'handwriting', classifications: ['handwriting'] },
    'Dela Gothic One': { category: 'display', classifications: ['display'] },
    'Delicious Handrawn': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Delius': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Delius Swash Caps': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Delius Unicase': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Della Respira': { category: 'serif', classifications: ['display'] },
    'Denk One': { category: 'sans-serif', classifications: ['display'] },
    'Devonshire': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Dhurjati': { category: 'sans-serif', classifications: ['display'] },
    'Didact Gothic': { category: 'sans-serif', classifications: [] },
    'Diphylleia': { category: 'serif', classifications: [] },
    'Diplomata': { category: 'display', classifications: ['display'] },
    'Diplomata SC': { category: 'display', classifications: ['display'] },
    'DM Mono': { category: 'monospace', classifications: ['monospace'] },
    'DM Sans': { category: 'sans-serif', classifications: [] },
    'DM Serif Display': { category: 'serif', classifications: ['display'] },
    'DM Serif Text': { category: 'serif', classifications: [] },
    'Do Hyeon': { category: 'sans-serif', classifications: ['display'] },
    'Dokdo': { category: 'display', classifications: ['display'] },
    'Domine': { category: 'serif', classifications: [] },
    'Donegal One': { category: 'serif', classifications: [] },
    'Dongle': { category: 'sans-serif', classifications: ['display'] },
    'Doppio One': { category: 'sans-serif', classifications: [] },
    'Dorsa': { category: 'sans-serif', classifications: ['display'] },
    'Dosis': { category: 'sans-serif', classifications: ['display'] },
    'DotGothic16': { category: 'sans-serif', classifications: ['display'] },
    'Doto': { category: 'sans-serif', classifications: ['display'] },
    'Dr Sugiyama': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Duru Sans': { category: 'sans-serif', classifications: [] },
    'Dynalight': { category: 'display', classifications: ['handwriting', 'display'] },
    'DynaPuff': { category: 'display', classifications: ['display'] },
    'Eagle Lake': { category: 'handwriting', classifications: ['display'] },
    'East Sea Dokdo': { category: 'handwriting', classifications: ['display'] },
    'Eater': { category: 'display', classifications: ['display'] },
    'EB Garamond': { category: 'serif', classifications: [] },
    'Economica': { category: 'sans-serif', classifications: ['display'] },
    'Eczar': { category: 'serif', classifications: [] },
    'Edu AU VIC WA NT Arrows': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu AU VIC WA NT Dots': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu AU VIC WA NT Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu AU VIC WA NT Hand': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu AU VIC WA NT Pre': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu NSW ACT Cursive': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu NSW ACT Foundation': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu NSW ACT Hand Pre': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu QLD Beginner': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu QLD Hand': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu SA Beginner': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu SA Hand': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu TAS Beginner': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu VIC WA NT Beginner': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu VIC WA NT Hand': { category: 'handwriting', classifications: ['handwriting'] },
    'Edu VIC WA NT Hand Pre': { category: 'handwriting', classifications: ['handwriting'] },
    'El Messiri': { category: 'sans-serif', classifications: [] },
    'Electrolize': { category: 'sans-serif', classifications: ['display'] },
    'Elms Sans': { category: 'sans-serif', classifications: [] },
    'Elsie': { category: 'display', classifications: ['display'] },
    'Elsie Swash Caps': { category: 'display', classifications: ['display'] },
    'Emblema One': { category: 'display', classifications: ['display'] },
    'Emilys Candy': { category: 'display', classifications: ['display'] },
    'Encode Sans': { category: 'sans-serif', classifications: [] },
    'Encode Sans Condensed': { category: 'sans-serif', classifications: [] },
    'Encode Sans Expanded': { category: 'sans-serif', classifications: [] },
    'Encode Sans SC': { category: 'sans-serif', classifications: [] },
    'Encode Sans Semi Condensed': { category: 'sans-serif', classifications: [] },
    'Encode Sans Semi Expanded': { category: 'sans-serif', classifications: [] },
    'Engagement': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Englebert': { category: 'sans-serif', classifications: ['handwriting', 'display'] },
    'Enriqueta': { category: 'serif', classifications: ['display'] },
    'Ephesis': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Epilogue': { category: 'sans-serif', classifications: [] },
    'Epunda Sans': { category: 'sans-serif', classifications: [] },
    'Epunda Slab': { category: 'serif', classifications: [] },
    'Erica One': { category: 'display', classifications: ['display'] },
    'Esteban': { category: 'serif', classifications: [] },
    'Estonia': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Euphoria Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Ewert': { category: 'display', classifications: ['display'] },
    'Exile': { category: 'display', classifications: ['display'] },
    'Exo': { category: 'sans-serif', classifications: [] },
    'Exo 2': { category: 'sans-serif', classifications: [] },
    'Expletus Sans': { category: 'display', classifications: ['display'] },
    'Explora': { category: 'handwriting', classifications: ['display'] },
    'Faculty Glyphic': { category: 'sans-serif', classifications: [] },
    'Fahkwang': { category: 'sans-serif', classifications: [] },
    'Familjen Grotesk': { category: 'sans-serif', classifications: [] },
    'Fanwood Text': { category: 'serif', classifications: [] },
    'Farro': { category: 'sans-serif', classifications: [] },
    'Farsan': { category: 'display', classifications: ['handwriting'] },
    'Fascinate': { category: 'display', classifications: ['display'] },
    'Fascinate Inline': { category: 'display', classifications: ['display'] },
    'Faster One': { category: 'display', classifications: ['display'] },
    'Fasthand': { category: 'display', classifications: ['handwriting', 'display'] },
    'Fauna One': { category: 'serif', classifications: [] },
    'Faustina': { category: 'serif', classifications: [] },
    'Federant': { category: 'display', classifications: ['display'] },
    'Federo': { category: 'sans-serif', classifications: [] },
    'Felipa': { category: 'handwriting', classifications: ['display'] },
    'Fenix': { category: 'serif', classifications: [] },
    'Festive': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Figtree': { category: 'sans-serif', classifications: [] },
    'Finger Paint': { category: 'display', classifications: ['display'] },
    'Finlandica': { category: 'sans-serif', classifications: [] },
    'Fira Code': { category: 'monospace', classifications: ['monospace'] },
    'Fira Mono': { category: 'monospace', classifications: ['monospace'] },
    'Fira Sans': { category: 'sans-serif', classifications: [] },
    'Fira Sans Condensed': { category: 'sans-serif', classifications: [] },
    'Fira Sans Extra Condensed': { category: 'sans-serif', classifications: [] },
    'Fjalla One': { category: 'sans-serif', classifications: [] },
    'Fjord One': { category: 'serif', classifications: [] },
    'Flamenco': { category: 'display', classifications: ['display'] },
    'Flavors': { category: 'display', classifications: ['handwriting', 'display'] },
    'Fleur De Leah': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Flow Block': { category: 'display', classifications: ['display', 'symbols'] },
    'Flow Circular': { category: 'display', classifications: ['display', 'symbols'] },
    'Flow Rounded': { category: 'display', classifications: ['display', 'symbols'] },
    'Foldit': { category: 'display', classifications: ['display'] },
    'Fondamento': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Fontdiner Swanky': { category: 'display', classifications: ['display'] },
    'Forum': { category: 'display', classifications: ['display'] },
    'Fragment Mono': { category: 'monospace', classifications: ['monospace'] },
    'Francois One': { category: 'sans-serif', classifications: [] },
    'Frank Ruhl Libre': { category: 'serif', classifications: [] },
    'Fraunces': { category: 'serif', classifications: [] },
    'Freckle Face': { category: 'display', classifications: ['display'] },
    'Fredericka the Great': { category: 'display', classifications: ['display'] },
    'Fredoka': { category: 'sans-serif', classifications: [] },
    'Freehand': { category: 'display', classifications: ['handwriting', 'display'] },
    'Freeman': { category: 'display', classifications: ['display'] },
    'Fresca': { category: 'sans-serif', classifications: ['display'] },
    'Frijole': { category: 'display', classifications: ['display'] },
    'Fruktur': { category: 'display', classifications: ['display'] },
    'Fugaz One': { category: 'display', classifications: ['display'] },
    'Fuggles': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Funnel Display': { category: 'display', classifications: ['display'] },
    'Funnel Sans': { category: 'sans-serif', classifications: [] },
    'Fustat': { category: 'sans-serif', classifications: [] },
    'Fuzzy Bubbles': { category: 'handwriting', classifications: ['display'] },
    'Ga Maamli': { category: 'display', classifications: ['display'] },
    'Gabarito': { category: 'display', classifications: ['display'] },
    'Gabriela': { category: 'serif', classifications: ['display'] },
    'Gaegu': { category: 'handwriting', classifications: ['display'] },
    'Gafata': { category: 'sans-serif', classifications: ['display'] },
    'Gajraj One': { category: 'display', classifications: ['display'] },
    'Galada': { category: 'display', classifications: ['handwriting', 'display'] },
    'Galdeano': { category: 'sans-serif', classifications: [] },
    'Galindo': { category: 'display', classifications: ['display'] },
    'Gamja Flower': { category: 'handwriting', classifications: ['display'] },
    'Gantari': { category: 'sans-serif', classifications: [] },
    'Gasoek One': { category: 'sans-serif', classifications: ['display'] },
    'Gayathri': { category: 'sans-serif', classifications: ['display'] },
    'Geist': { category: 'sans-serif', classifications: [] },
    'Geist Mono': { category: 'monospace', classifications: ['monospace'] },
    'Gelasio': { category: 'serif', classifications: [] },
    'Gemunu Libre': { category: 'sans-serif', classifications: ['display'] },
    'Genos': { category: 'sans-serif', classifications: ['display'] },
    'Gentium Book Plus': { category: 'serif', classifications: [] },
    'Gentium Plus': { category: 'serif', classifications: [] },
    'Geo': { category: 'sans-serif', classifications: ['display'] },
    'Geologica': { category: 'sans-serif', classifications: [] },
    'Geom': { category: 'sans-serif', classifications: [] },
    'Georama': { category: 'sans-serif', classifications: ['display'] },
    'Geostar': { category: 'display', classifications: ['display'] },
    'Geostar Fill': { category: 'display', classifications: ['display'] },
    'Germania One': { category: 'display', classifications: ['display'] },
    'GFS Didot': { category: 'serif', classifications: [] },
    'GFS Neohellenic': { category: 'sans-serif', classifications: [] },
    'Gideon Roman': { category: 'display', classifications: ['display'] },
    'Gidole': { category: 'sans-serif', classifications: [] },
    'Gidugu': { category: 'sans-serif', classifications: ['display'] },
    'Gilda Display': { category: 'serif', classifications: ['display'] },
    'Girassol': { category: 'display', classifications: ['display'] },
    'Give You Glory': { category: 'handwriting', classifications: ['handwriting'] },
    'Glass Antiqua': { category: 'display', classifications: ['handwriting'] },
    'Glegoo': { category: 'serif', classifications: [] },
    'Gloock': { category: 'serif', classifications: ['display'] },
    'Gloria Hallelujah': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Glory': { category: 'sans-serif', classifications: ['display'] },
    'Gluten': { category: 'display', classifications: ['handwriting', 'display'] },
    'Goblin One': { category: 'display', classifications: ['display'] },
    'Gochi Hand': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Goldman': { category: 'display', classifications: ['display'] },
    'Golos Text': { category: 'sans-serif', classifications: [] },
    'Google Sans': { category: 'sans-serif', classifications: [] },
    'Google Sans Code': { category: 'monospace', classifications: ['monospace'] },
    'Google Sans Flex': { category: 'sans-serif', classifications: [] },
    'Gorditas': { category: 'display', classifications: ['display'] },
    'Gothic A1': { category: 'sans-serif', classifications: [] },
    'Gotu': { category: 'sans-serif', classifications: [] },
    'Goudy Bookletter 1911': { category: 'serif', classifications: ['display'] },
    'Gowun Batang': { category: 'serif', classifications: [] },
    'Gowun Dodum': { category: 'sans-serif', classifications: [] },
    'Graduate': { category: 'serif', classifications: ['display'] },
    'Grand Hotel': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Grandiflora One': { category: 'serif', classifications: ['handwriting', 'display'] },
    'Grandstander': { category: 'display', classifications: ['handwriting', 'display'] },
    'Grape Nuts': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Gravitas One': { category: 'display', classifications: ['display'] },
    'Great Vibes': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Grechen Fuemen': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Grenze': { category: 'serif', classifications: [] },
    'Grenze Gotisch': { category: 'display', classifications: ['display'] },
    'Grey Qo': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Griffy': { category: 'display', classifications: ['display'] },
    'Gruppo': { category: 'sans-serif', classifications: ['display'] },
    'Gudea': { category: 'sans-serif', classifications: [] },
    'Gugi': { category: 'display', classifications: ['display'] },
    'Gulzar': { category: 'serif', classifications: ['display'] },
    'Gupter': { category: 'serif', classifications: [] },
    'Gurajada': { category: 'sans-serif', classifications: ['display'] },
    'Gveret Levin': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Gwendolyn': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Habibi': { category: 'serif', classifications: [] },
    'Hachi Maru Pop': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Hahmlet': { category: 'serif', classifications: [] },
    'Halant': { category: 'serif', classifications: [] },
    'Hammersmith One': { category: 'sans-serif', classifications: [] },
    'Hanalei': { category: 'display', classifications: ['display'] },
    'Hanalei Fill': { category: 'display', classifications: ['display'] },
    'Handjet': { category: 'display', classifications: ['display'] },
    'Handlee': { category: 'handwriting', classifications: ['handwriting'] },
    'Hanken Grotesk': { category: 'sans-serif', classifications: [] },
    'Hanuman': { category: 'serif', classifications: [] },
    'Happy Monkey': { category: 'display', classifications: ['display'] },
    'Harmattan': { category: 'sans-serif', classifications: [] },
    'Headland One': { category: 'serif', classifications: [] },
    'Hedvig Letters Sans': { category: 'sans-serif', classifications: [] },
    'Hedvig Letters Serif': { category: 'serif', classifications: [] },
    'Heebo': { category: 'sans-serif', classifications: [] },
    'Henny Penny': { category: 'display', classifications: ['display'] },
    'Hepta Slab': { category: 'serif', classifications: [] },
    'Herr Von Muellerhoff': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Hi Melody': { category: 'handwriting', classifications: ['display'] },
    'Hina Mincho': { category: 'serif', classifications: ['display'] },
    'Hind': { category: 'sans-serif', classifications: [] },
    'Hind Guntur': { category: 'sans-serif', classifications: [] },
    'Hind Madurai': { category: 'sans-serif', classifications: [] },
    'Hind Mysuru': { category: 'sans-serif', classifications: [] },
    'Hind Siliguri': { category: 'sans-serif', classifications: [] },
    'Hind Vadodara': { category: 'sans-serif', classifications: [] },
    'Holtwood One SC': { category: 'serif', classifications: ['display'] },
    'Homemade Apple': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Homenaje': { category: 'sans-serif', classifications: [] },
    'Honk': { category: 'display', classifications: ['display'] },
    'Host Grotesk': { category: 'sans-serif', classifications: [] },
    'Hubballi': { category: 'sans-serif', classifications: [] },
    'Hubot Sans': { category: 'sans-serif', classifications: [] },
    'Huninn': { category: 'sans-serif', classifications: [] },
    'Hurricane': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Iansui': { category: 'handwriting', classifications: ['handwriting'] },
    'Ibarra Real Nova': { category: 'serif', classifications: ['display'] },
    'IBM Plex Mono': { category: 'monospace', classifications: ['monospace'] },
    'IBM Plex Sans': { category: 'sans-serif', classifications: [] },
    'IBM Plex Sans Arabic': { category: 'sans-serif', classifications: [] },
    'IBM Plex Sans Condensed': { category: 'sans-serif', classifications: [] },
    'IBM Plex Sans Devanagari': { category: 'sans-serif', classifications: [] },
    'IBM Plex Sans Hebrew': { category: 'sans-serif', classifications: [] },
    'IBM Plex Sans JP': { category: 'sans-serif', classifications: [] },
    'IBM Plex Sans KR': { category: 'sans-serif', classifications: [] },
    'IBM Plex Sans Thai': { category: 'sans-serif', classifications: [] },
    'IBM Plex Sans Thai Looped': { category: 'sans-serif', classifications: [] },
    'IBM Plex Serif': { category: 'serif', classifications: [] },
    'Iceberg': { category: 'display', classifications: ['display'] },
    'Iceland': { category: 'display', classifications: ['display'] },
    'Idiqlat': { category: 'serif', classifications: [] },
    'IM Fell Double Pica': { category: 'serif', classifications: [] },
    'IM Fell Double Pica SC': { category: 'serif', classifications: [] },
    'IM Fell DW Pica': { category: 'serif', classifications: [] },
    'IM Fell DW Pica SC': { category: 'serif', classifications: [] },
    'IM Fell English': { category: 'serif', classifications: [] },
    'IM Fell English SC': { category: 'serif', classifications: [] },
    'IM Fell French Canon': { category: 'serif', classifications: [] },
    'IM Fell French Canon SC': { category: 'serif', classifications: [] },
    'IM Fell Great Primer': { category: 'serif', classifications: [] },
    'IM Fell Great Primer SC': { category: 'serif', classifications: [] },
    'Imbue': { category: 'serif', classifications: ['display'] },
    'Imperial Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Imprima': { category: 'sans-serif', classifications: [] },
    'Inclusive Sans': { category: 'sans-serif', classifications: [] },
    'Inconsolata': { category: 'monospace', classifications: ['monospace'] },
    'Inder': { category: 'sans-serif', classifications: [] },
    'Indie Flower': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Ingrid Darling': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Inika': { category: 'serif', classifications: [] },
    'Inknut Antiqua': { category: 'serif', classifications: [] },
    'Inria Sans': { category: 'sans-serif', classifications: [] },
    'Inria Serif': { category: 'serif', classifications: ['display'] },
    'Inspiration': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Instrument Sans': { category: 'sans-serif', classifications: [] },
    'Instrument Serif': { category: 'serif', classifications: [] },
    'Intel One Mono': { category: 'monospace', classifications: ['monospace'] },
    'Inter': { category: 'sans-serif', classifications: [] },
    'Inter Tight': { category: 'sans-serif', classifications: ['display'] },
    'Irish Grover': { category: 'display', classifications: ['display'] },
    'Island Moments': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Istok Web': { category: 'sans-serif', classifications: ['display'] },
    'Italiana': { category: 'sans-serif', classifications: ['display'] },
    'Italianno': { category: 'handwriting', classifications: ['handwriting'] },
    'Itim': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Jacquard 12': { category: 'display', classifications: ['display'] },
    'Jacquard 12 Charted': { category: 'display', classifications: ['display'] },
    'Jacquard 24': { category: 'display', classifications: ['display'] },
    'Jacquard 24 Charted': { category: 'display', classifications: ['display'] },
    'Jacquarda Bastarda 9': { category: 'display', classifications: ['display'] },
    'Jacquarda Bastarda 9 Charted': { category: 'display', classifications: ['display'] },
    'Jacques Francois': { category: 'serif', classifications: ['display'] },
    'Jacques Francois Shadow': { category: 'display', classifications: ['display'] },
    'Jaini': { category: 'display', classifications: ['display'] },
    'Jaini Purva': { category: 'display', classifications: ['display'] },
    'Jaldi': { category: 'sans-serif', classifications: [] },
    'Jaro': { category: 'sans-serif', classifications: ['display'] },
    'Jersey 10': { category: 'display', classifications: ['display'] },
    'Jersey 10 Charted': { category: 'display', classifications: ['display'] },
    'Jersey 15': { category: 'display', classifications: ['display'] },
    'Jersey 15 Charted': { category: 'display', classifications: ['display'] },
    'Jersey 20': { category: 'display', classifications: ['display'] },
    'Jersey 20 Charted': { category: 'display', classifications: ['display'] },
    'Jersey 25': { category: 'display', classifications: ['display'] },
    'Jersey 25 Charted': { category: 'display', classifications: ['display'] },
    'JetBrains Mono': { category: 'monospace', classifications: ['monospace'] },
    'Jim Nightshade': { category: 'handwriting', classifications: ['handwriting'] },
    'Joan': { category: 'serif', classifications: [] },
    'Jockey One': { category: 'sans-serif', classifications: ['display'] },
    'Jolly Lodger': { category: 'display', classifications: ['display'] },
    'Jomhuria': { category: 'display', classifications: ['display'] },
    'Jomolhari': { category: 'serif', classifications: ['display'] },
    'Josefin Sans': { category: 'sans-serif', classifications: ['display'] },
    'Josefin Slab': { category: 'serif', classifications: ['display'] },
    'Jost': { category: 'sans-serif', classifications: [] },
    'Joti One': { category: 'display', classifications: ['display'] },
    'Jua': { category: 'sans-serif', classifications: ['display'] },
    'Judson': { category: 'serif', classifications: [] },
    'Julee': { category: 'handwriting', classifications: ['handwriting'] },
    'Julius Sans One': { category: 'sans-serif', classifications: ['display'] },
    'Junge': { category: 'serif', classifications: ['handwriting'] },
    'Jura': { category: 'sans-serif', classifications: ['display'] },
    'Just Another Hand': { category: 'handwriting', classifications: ['handwriting'] },
    'Just Me Again Down Here': { category: 'handwriting', classifications: ['handwriting'] },
    'K2D': { category: 'sans-serif', classifications: ['display'] },
    'Kablammo': { category: 'display', classifications: ['display'] },
    'Kadwa': { category: 'serif', classifications: [] },
    'Kaisei Decol': { category: 'serif', classifications: [] },
    'Kaisei HarunoUmi': { category: 'serif', classifications: [] },
    'Kaisei Opti': { category: 'serif', classifications: [] },
    'Kaisei Tokumin': { category: 'serif', classifications: [] },
    'Kalam': { category: 'handwriting', classifications: ['handwriting'] },
    'Kalnia': { category: 'serif', classifications: ['display'] },
    'Kalnia Glaze': { category: 'display', classifications: ['display'] },
    'Kameron': { category: 'serif', classifications: [] },
    'Kanchenjunga': { category: 'sans-serif', classifications: [] },
    'Kanit': { category: 'sans-serif', classifications: [] },
    'Kantumruy Pro': { category: 'sans-serif', classifications: [] },
    'Kapakana': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Karantina': { category: 'display', classifications: ['display'] },
    'Karla': { category: 'sans-serif', classifications: [] },
    'Karla Tamil Inclined': { category: 'sans-serif', classifications: [] },
    'Karla Tamil Upright': { category: 'sans-serif', classifications: [] },
    'Karma': { category: 'serif', classifications: [] },
    'Katibeh': { category: 'display', classifications: ['display'] },
    'Kaushan Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Kavivanar': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Kavoon': { category: 'display', classifications: ['display'] },
    'Kay Pho Du': { category: 'serif', classifications: [] },
    'Kdam Thmor Pro': { category: 'sans-serif', classifications: ['display'] },
    'Keania One': { category: 'display', classifications: ['display'] },
    'Kedebideri': { category: 'sans-serif', classifications: [] },
    'Kelly Slab': { category: 'display', classifications: ['display'] },
    'Kenia': { category: 'display', classifications: ['display'] },
    'Khand': { category: 'sans-serif', classifications: [] },
    'Khmer': { category: 'sans-serif', classifications: [] },
    'Khula': { category: 'sans-serif', classifications: [] },
    'Kings': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Kirang Haerang': { category: 'display', classifications: ['display'] },
    'Kite One': { category: 'sans-serif', classifications: [] },
    'Kiwi Maru': { category: 'serif', classifications: [] },
    'Klee One': { category: 'handwriting', classifications: ['handwriting'] },
    'Knewave': { category: 'display', classifications: ['display'] },
    'Kodchasan': { category: 'sans-serif', classifications: [] },
    'Kode Mono': { category: 'monospace', classifications: ['monospace'] },
    'Koh Santepheap': { category: 'serif', classifications: [] },
    'KoHo': { category: 'sans-serif', classifications: [] },
    'Kolker Brush': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Konkhmer Sleokchher': { category: 'display', classifications: ['display'] },
    'Kosugi': { category: 'sans-serif', classifications: [] },
    'Kosugi Maru': { category: 'sans-serif', classifications: [] },
    'Kotta One': { category: 'serif', classifications: [] },
    'Koulen': { category: 'display', classifications: ['display'] },
    'Kranky': { category: 'display', classifications: ['display'] },
    'Kreon': { category: 'serif', classifications: [] },
    'Kristi': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Krona One': { category: 'sans-serif', classifications: [] },
    'Krub': { category: 'sans-serif', classifications: [] },
    'Kufam': { category: 'sans-serif', classifications: [] },
    'Kulim Park': { category: 'sans-serif', classifications: [] },
    'Kumar One': { category: 'display', classifications: ['display'] },
    'Kumar One Outline': { category: 'display', classifications: ['display'] },
    'Kumbh Sans': { category: 'sans-serif', classifications: [] },
    'Kurale': { category: 'serif', classifications: [] },
    'La Belle Aurore': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Labrada': { category: 'serif', classifications: [] },
    'Lacquer': { category: 'display', classifications: ['display'] },
    'Laila': { category: 'serif', classifications: ['display'] },
    'Lakki Reddy': { category: 'handwriting', classifications: ['display'] },
    'Lalezar': { category: 'sans-serif', classifications: [] },
    'Lancelot': { category: 'display', classifications: ['display'] },
    'Langar': { category: 'display', classifications: ['display'] },
    'Lateef': { category: 'serif', classifications: [] },
    'Lato': { category: 'sans-serif', classifications: [] },
    'Lavishly Yours': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'League Gothic': { category: 'sans-serif', classifications: ['display'] },
    'League Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'League Spartan': { category: 'sans-serif', classifications: [] },
    'Leckerli One': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Ledger': { category: 'serif', classifications: [] },
    'Lekton': { category: 'monospace', classifications: ['monospace'] },
    'Lemon': { category: 'display', classifications: ['display'] },
    'Lemonada': { category: 'display', classifications: ['handwriting'] },
    'Lexend': { category: 'sans-serif', classifications: [] },
    'Lexend Deca': { category: 'sans-serif', classifications: [] },
    'Lexend Exa': { category: 'sans-serif', classifications: [] },
    'Lexend Giga': { category: 'sans-serif', classifications: [] },
    'Lexend Mega': { category: 'sans-serif', classifications: [] },
    'Lexend Peta': { category: 'sans-serif', classifications: [] },
    'Lexend Tera': { category: 'sans-serif', classifications: [] },
    'Lexend Zetta': { category: 'sans-serif', classifications: [] },
    'Libertinus Keyboard': { category: 'display', classifications: ['display'] },
    'Libertinus Math': { category: 'display', classifications: ['display'] },
    'Libertinus Mono': { category: 'monospace', classifications: ['monospace'] },
    'Libertinus Sans': { category: 'sans-serif', classifications: [] },
    'Libertinus Serif': { category: 'serif', classifications: [] },
    'Libertinus Serif Display': { category: 'display', classifications: ['display'] },
    'Libre Barcode 128': { category: 'display', classifications: ['display', 'symbols'] },
    'Libre Barcode 128 Text': { category: 'display', classifications: ['display', 'symbols'] },
    'Libre Barcode 39': { category: 'display', classifications: ['display', 'symbols'] },
    'Libre Barcode 39 Extended': { category: 'display', classifications: ['display', 'symbols'] },
    'Libre Barcode 39 Extended Text': { category: 'display', classifications: ['display', 'symbols'] },
    'Libre Barcode 39 Text': { category: 'display', classifications: ['display', 'symbols'] },
    'Libre Barcode EAN13 Text': { category: 'display', classifications: ['display', 'symbols'] },
    'Libre Baskerville': { category: 'serif', classifications: [] },
    'Libre Bodoni': { category: 'serif', classifications: [] },
    'Libre Caslon Display': { category: 'serif', classifications: ['display'] },
    'Libre Caslon Text': { category: 'serif', classifications: [] },
    'Libre Franklin': { category: 'sans-serif', classifications: [] },
    'Licorice': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Life Savers': { category: 'display', classifications: ['display'] },
    'Lilex': { category: 'monospace', classifications: ['monospace'] },
    'Lilita One': { category: 'display', classifications: ['display'] },
    'Lily Script One': { category: 'display', classifications: ['display'] },
    'Limelight': { category: 'display', classifications: ['display'] },
    'Linden Hill': { category: 'serif', classifications: ['display'] },
    'LINE Seed JP': { category: 'sans-serif', classifications: [] },
    'Linefont': { category: 'display', classifications: ['display', 'symbols'] },
    'Lisu Bosa': { category: 'serif', classifications: [] },
    'Liter': { category: 'sans-serif', classifications: [] },
    'Literata': { category: 'serif', classifications: [] },
    'Liu Jian Mao Cao': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Livvic': { category: 'sans-serif', classifications: [] },
    'Lobster': { category: 'display', classifications: ['display'] },
    'Lobster Two': { category: 'display', classifications: ['display'] },
    'Londrina Outline': { category: 'display', classifications: ['display'] },
    'Londrina Shadow': { category: 'display', classifications: ['display'] },
    'Londrina Sketch': { category: 'display', classifications: ['display'] },
    'Londrina Solid': { category: 'display', classifications: ['display'] },
    'Long Cang': { category: 'handwriting', classifications: ['handwriting'] },
    'Lora': { category: 'serif', classifications: [] },
    'Love Light': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Love Ya Like A Sister': { category: 'display', classifications: ['handwriting', 'display'] },
    'Loved by the King': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Lovers Quarrel': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Luckiest Guy': { category: 'display', classifications: ['handwriting', 'display'] },
    'Lugrasimo': { category: 'handwriting', classifications: ['handwriting'] },
    'Lumanosimo': { category: 'handwriting', classifications: ['handwriting'] },
    'Lunasima': { category: 'sans-serif', classifications: [] },
    'Lusitana': { category: 'serif', classifications: [] },
    'Lustria': { category: 'serif', classifications: [] },
    'Luxurious Roman': { category: 'display', classifications: ['display'] },
    'Luxurious Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'LXGW Marker Gothic': { category: 'sans-serif', classifications: [] },
    'LXGW WenKai Mono TC': { category: 'monospace', classifications: ['monospace'] },
    'LXGW WenKai TC': { category: 'handwriting', classifications: ['handwriting'] },
    'M PLUS 1': { category: 'sans-serif', classifications: [] },
    'M PLUS 1 Code': { category: 'monospace', classifications: ['monospace'] },
    'M PLUS 1p': { category: 'sans-serif', classifications: [] },
    'M PLUS 2': { category: 'sans-serif', classifications: [] },
    'M PLUS Code Latin': { category: 'sans-serif', classifications: ['monospace'] },
    'M PLUS Rounded 1c': { category: 'sans-serif', classifications: [] },
    'Ma Shan Zheng': { category: 'handwriting', classifications: ['handwriting'] },
    'Macondo': { category: 'display', classifications: ['handwriting', 'display'] },
    'Macondo Swash Caps': { category: 'display', classifications: ['handwriting', 'display'] },
    'Mada': { category: 'sans-serif', classifications: [] },
    'Madimi One': { category: 'sans-serif', classifications: ['display'] },
    'Magra': { category: 'sans-serif', classifications: [] },
    'Maiden Orange': { category: 'serif', classifications: ['display'] },
    'Maitree': { category: 'serif', classifications: [] },
    'Major Mono Display': { category: 'monospace', classifications: ['display', 'monospace'] },
    'Mako': { category: 'sans-serif', classifications: [] },
    'Mali': { category: 'handwriting', classifications: ['handwriting'] },
    'Mallanna': { category: 'sans-serif', classifications: [] },
    'Maname': { category: 'serif', classifications: [] },
    'Mandali': { category: 'sans-serif', classifications: [] },
    'Manjari': { category: 'sans-serif', classifications: ['display'] },
    'Manrope': { category: 'sans-serif', classifications: [] },
    'Mansalva': { category: 'handwriting', classifications: ['display'] },
    'Manuale': { category: 'serif', classifications: [] },
    'Manufacturing Consent': { category: 'display', classifications: ['display'] },
    'Marcellus': { category: 'serif', classifications: [] },
    'Marcellus SC': { category: 'serif', classifications: [] },
    'Marck Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Margarine': { category: 'display', classifications: ['display'] },
    'Marhey': { category: 'display', classifications: ['display'] },
    'Markazi Text': { category: 'serif', classifications: [] },
    'Marko One': { category: 'serif', classifications: [] },
    'Marmelad': { category: 'sans-serif', classifications: [] },
    'Martel': { category: 'serif', classifications: [] },
    'Martel Sans': { category: 'sans-serif', classifications: [] },
    'Martian Mono': { category: 'monospace', classifications: ['monospace'] },
    'Marvel': { category: 'sans-serif', classifications: ['display'] },
    'Matangi': { category: 'sans-serif', classifications: [] },
    'Mate': { category: 'serif', classifications: ['display'] },
    'Mate SC': { category: 'serif', classifications: [] },
    'Matemasie': { category: 'sans-serif', classifications: ['display'] },
    'Maven Pro': { category: 'sans-serif', classifications: [] },
    'McLaren': { category: 'display', classifications: ['display'] },
    'Mea Culpa': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Meddon': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'MedievalSharp': { category: 'display', classifications: ['handwriting', 'display'] },
    'Medula One': { category: 'display', classifications: ['display'] },
    'Meera Inimai': { category: 'sans-serif', classifications: [] },
    'Megrim': { category: 'display', classifications: ['display'] },
    'Meie Script': { category: 'handwriting', classifications: ['handwriting'] },
    'Menbere': { category: 'sans-serif', classifications: [] },
    'Meow Script': { category: 'handwriting', classifications: ['handwriting'] },
    'Merienda': { category: 'handwriting', classifications: ['handwriting'] },
    'Merriweather': { category: 'serif', classifications: [] },
    'Merriweather Sans': { category: 'sans-serif', classifications: [] },
    'Metal': { category: 'display', classifications: ['display'] },
    'Metal Mania': { category: 'display', classifications: ['display'] },
    'Metamorphous': { category: 'display', classifications: ['display'] },
    'Metrophobic': { category: 'sans-serif', classifications: [] },
    'Michroma': { category: 'sans-serif', classifications: ['display'] },
    'Micro 5': { category: 'display', classifications: ['display'] },
    'Micro 5 Charted': { category: 'display', classifications: ['display'] },
    'Milonga': { category: 'display', classifications: ['display'] },
    'Miltonian': { category: 'display', classifications: ['display'] },
    'Miltonian Tattoo': { category: 'display', classifications: ['display'] },
    'Mina': { category: 'sans-serif', classifications: [] },
    'Mingzat': { category: 'sans-serif', classifications: [] },
    'Miniver': { category: 'display', classifications: ['handwriting', 'display'] },
    'Miriam Libre': { category: 'sans-serif', classifications: [] },
    'Mirza': { category: 'serif', classifications: [] },
    'Miss Fajardose': { category: 'handwriting', classifications: ['handwriting'] },
    'Mitr': { category: 'sans-serif', classifications: [] },
    'Mochiy Pop One': { category: 'sans-serif', classifications: ['display'] },
    'Mochiy Pop P One': { category: 'sans-serif', classifications: ['display'] },
    'Modak': { category: 'display', classifications: ['display'] },
    'Modern Antiqua': { category: 'display', classifications: ['display'] },
    'Moderustic': { category: 'sans-serif', classifications: [] },
    'Mogra': { category: 'display', classifications: ['display'] },
    'Mohave': { category: 'sans-serif', classifications: [] },
    'Moirai One': { category: 'display', classifications: ['display'] },
    'Molengo': { category: 'sans-serif', classifications: [] },
    'Molle': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Momo Signature': { category: 'sans-serif', classifications: ['handwriting'] },
    'Momo Trust Display': { category: 'sans-serif', classifications: ['display'] },
    'Momo Trust Sans': { category: 'sans-serif', classifications: [] },
    'Mona Sans': { category: 'sans-serif', classifications: [] },
    'Monda': { category: 'sans-serif', classifications: [] },
    'Monofett': { category: 'monospace', classifications: ['monospace'] },
    'Monomakh': { category: 'display', classifications: ['display'] },
    'Monomaniac One': { category: 'sans-serif', classifications: ['display'] },
    'Monoton': { category: 'display', classifications: ['display'] },
    'Monsieur La Doulaise': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Montaga': { category: 'serif', classifications: [] },
    'Montagu Slab': { category: 'serif', classifications: ['display'] },
    'MonteCarlo': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Montez': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Montserrat': { category: 'sans-serif', classifications: [] },
    'Montserrat Alternates': { category: 'sans-serif', classifications: [] },
    'Montserrat Underline': { category: 'sans-serif', classifications: [] },
    'Moo Lah Lah': { category: 'display', classifications: ['display'] },
    'Mooli': { category: 'sans-serif', classifications: [] },
    'Moon Dance': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Moul': { category: 'display', classifications: ['display'] },
    'Moulpali': { category: 'sans-serif', classifications: [] },
    'Mountains of Christmas': { category: 'display', classifications: ['display'] },
    'Mouse Memoirs': { category: 'sans-serif', classifications: ['display'] },
    'Mozilla Headline': { category: 'sans-serif', classifications: [] },
    'Mozilla Text': { category: 'sans-serif', classifications: [] },
    'Mr Bedfort': { category: 'handwriting', classifications: ['handwriting'] },
    'Mr Dafoe': { category: 'handwriting', classifications: ['handwriting'] },
    'Mr De Haviland': { category: 'handwriting', classifications: ['handwriting'] },
    'Mrs Saint Delafield': { category: 'handwriting', classifications: ['handwriting'] },
    'Mrs Sheppards': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Ms Madi': { category: 'handwriting', classifications: ['handwriting'] },
    'Mukta': { category: 'sans-serif', classifications: [] },
    'Mukta Mahee': { category: 'sans-serif', classifications: [] },
    'Mukta Malar': { category: 'sans-serif', classifications: [] },
    'Mukta Vaani': { category: 'sans-serif', classifications: [] },
    'Mulish': { category: 'sans-serif', classifications: [] },
    'Murecho': { category: 'sans-serif', classifications: [] },
    'MuseoModerno': { category: 'display', classifications: ['display'] },
    'My Soul': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Mynerve': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Mystery Quest': { category: 'display', classifications: ['display'] },
    'Nabla': { category: 'display', classifications: ['display'] },
    'Namdhinggo': { category: 'serif', classifications: [] },
    'Nanum Brush Script': { category: 'handwriting', classifications: ['handwriting'] },
    'Nanum Gothic': { category: 'sans-serif', classifications: [] },
    'Nanum Gothic Coding': { category: 'handwriting', classifications: ['monospace'] },
    'Nanum Myeongjo': { category: 'serif', classifications: [] },
    'Nanum Pen Script': { category: 'handwriting', classifications: ['handwriting'] },
    'Narnoor': { category: 'sans-serif', classifications: [] },
    'Nata Sans': { category: 'sans-serif', classifications: [] },
    'National Park': { category: 'sans-serif', classifications: [] },
    'Neonderthaw': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Nerko One': { category: 'handwriting', classifications: ['handwriting'] },
    'Neucha': { category: 'handwriting', classifications: ['handwriting'] },
    'Neuton': { category: 'serif', classifications: ['display'] },
    'New Amsterdam': { category: 'sans-serif', classifications: [] },
    'New Rocker': { category: 'display', classifications: ['display'] },
    'New Tegomin': { category: 'serif', classifications: [] },
    'News Cycle': { category: 'sans-serif', classifications: [] },
    'Newsreader': { category: 'serif', classifications: [] },
    'Niconne': { category: 'handwriting', classifications: ['handwriting'] },
    'Niramit': { category: 'sans-serif', classifications: [] },
    'Nixie One': { category: 'display', classifications: ['display'] },
    'Nobile': { category: 'sans-serif', classifications: [] },
    'Nokora': { category: 'sans-serif', classifications: [] },
    'Norican': { category: 'handwriting', classifications: ['handwriting'] },
    'Nosifer': { category: 'display', classifications: ['display'] },
    'Notable': { category: 'sans-serif', classifications: ['display'] },
    'Nothing You Could Do': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Noticia Text': { category: 'serif', classifications: [] },
    'Noto Color Emoji': { category: 'sans-serif', classifications: [] },
    'Noto Emoji': { category: 'sans-serif', classifications: [] },
    'Noto Kufi Arabic': { category: 'sans-serif', classifications: [] },
    'Noto Music': { category: 'sans-serif', classifications: ['symbols'] },
    'Noto Naskh Arabic': { category: 'serif', classifications: [] },
    'Noto Nastaliq Urdu': { category: 'serif', classifications: [] },
    'Noto Rashi Hebrew': { category: 'serif', classifications: [] },
    'Noto Sans': { category: 'sans-serif', classifications: [] },
    'Noto Sans Adlam': { category: 'sans-serif', classifications: [] },
    'Noto Sans Adlam Unjoined': { category: 'sans-serif', classifications: [] },
    'Noto Sans Anatolian Hieroglyphs': { category: 'sans-serif', classifications: [] },
    'Noto Sans Arabic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Armenian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Avestan': { category: 'sans-serif', classifications: [] },
    'Noto Sans Balinese': { category: 'sans-serif', classifications: [] },
    'Noto Sans Bamum': { category: 'sans-serif', classifications: [] },
    'Noto Sans Bassa Vah': { category: 'sans-serif', classifications: [] },
    'Noto Sans Batak': { category: 'sans-serif', classifications: [] },
    'Noto Sans Bengali': { category: 'sans-serif', classifications: [] },
    'Noto Sans Bhaiksuki': { category: 'sans-serif', classifications: [] },
    'Noto Sans Brahmi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Buginese': { category: 'sans-serif', classifications: [] },
    'Noto Sans Buhid': { category: 'sans-serif', classifications: [] },
    'Noto Sans Canadian Aboriginal': { category: 'sans-serif', classifications: [] },
    'Noto Sans Carian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Caucasian Albanian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Chakma': { category: 'sans-serif', classifications: [] },
    'Noto Sans Cham': { category: 'sans-serif', classifications: [] },
    'Noto Sans Cherokee': { category: 'sans-serif', classifications: [] },
    'Noto Sans Chorasmian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Coptic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Cuneiform': { category: 'sans-serif', classifications: [] },
    'Noto Sans Cypriot': { category: 'sans-serif', classifications: [] },
    'Noto Sans Cypro Minoan': { category: 'sans-serif', classifications: [] },
    'Noto Sans Deseret': { category: 'sans-serif', classifications: [] },
    'Noto Sans Devanagari': { category: 'sans-serif', classifications: [] },
    'Noto Sans Display': { category: 'sans-serif', classifications: ['display'] },
    'Noto Sans Duployan': { category: 'sans-serif', classifications: [] },
    'Noto Sans Egyptian Hieroglyphs': { category: 'sans-serif', classifications: [] },
    'Noto Sans Elbasan': { category: 'sans-serif', classifications: [] },
    'Noto Sans Elymaic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Ethiopic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Georgian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Glagolitic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Gothic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Grantha': { category: 'sans-serif', classifications: [] },
    'Noto Sans Gujarati': { category: 'sans-serif', classifications: [] },
    'Noto Sans Gunjala Gondi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Gurmukhi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Hanifi Rohingya': { category: 'sans-serif', classifications: [] },
    'Noto Sans Hanunoo': { category: 'sans-serif', classifications: [] },
    'Noto Sans Hatran': { category: 'sans-serif', classifications: [] },
    'Noto Sans Hebrew': { category: 'sans-serif', classifications: [] },
    'Noto Sans HK': { category: 'sans-serif', classifications: [] },
    'Noto Sans Imperial Aramaic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Indic Siyaq Numbers': { category: 'sans-serif', classifications: [] },
    'Noto Sans Inscriptional Pahlavi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Inscriptional Parthian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Javanese': { category: 'sans-serif', classifications: [] },
    'Noto Sans JP': { category: 'sans-serif', classifications: [] },
    'Noto Sans Kaithi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Kannada': { category: 'sans-serif', classifications: [] },
    'Noto Sans Kawi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Kayah Li': { category: 'sans-serif', classifications: [] },
    'Noto Sans Kharoshthi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Khmer': { category: 'sans-serif', classifications: [] },
    'Noto Sans Khojki': { category: 'sans-serif', classifications: [] },
    'Noto Sans Khudawadi': { category: 'sans-serif', classifications: [] },
    'Noto Sans KR': { category: 'sans-serif', classifications: [] },
    'Noto Sans Lao': { category: 'sans-serif', classifications: [] },
    'Noto Sans Lao Looped': { category: 'sans-serif', classifications: [] },
    'Noto Sans Lepcha': { category: 'sans-serif', classifications: [] },
    'Noto Sans Limbu': { category: 'sans-serif', classifications: [] },
    'Noto Sans Linear A': { category: 'sans-serif', classifications: [] },
    'Noto Sans Linear B': { category: 'sans-serif', classifications: [] },
    'Noto Sans Lisu': { category: 'sans-serif', classifications: [] },
    'Noto Sans Lycian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Lydian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Mahajani': { category: 'sans-serif', classifications: [] },
    'Noto Sans Malayalam': { category: 'sans-serif', classifications: [] },
    'Noto Sans Mandaic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Manichaean': { category: 'sans-serif', classifications: [] },
    'Noto Sans Marchen': { category: 'sans-serif', classifications: [] },
    'Noto Sans Masaram Gondi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Math': { category: 'sans-serif', classifications: [] },
    'Noto Sans Mayan Numerals': { category: 'sans-serif', classifications: [] },
    'Noto Sans Medefaidrin': { category: 'sans-serif', classifications: [] },
    'Noto Sans Meetei Mayek': { category: 'sans-serif', classifications: [] },
    'Noto Sans Mende Kikakui': { category: 'sans-serif', classifications: [] },
    'Noto Sans Meroitic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Miao': { category: 'sans-serif', classifications: [] },
    'Noto Sans Modi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Mongolian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Mono': { category: 'sans-serif', classifications: ['monospace'] },
    'Noto Sans Mro': { category: 'sans-serif', classifications: [] },
    'Noto Sans Multani': { category: 'sans-serif', classifications: [] },
    'Noto Sans Myanmar': { category: 'sans-serif', classifications: [] },
    'Noto Sans Nabataean': { category: 'sans-serif', classifications: [] },
    'Noto Sans Nag Mundari': { category: 'sans-serif', classifications: [] },
    'Noto Sans Nandinagari': { category: 'sans-serif', classifications: [] },
    'Noto Sans New Tai Lue': { category: 'sans-serif', classifications: [] },
    'Noto Sans Newa': { category: 'sans-serif', classifications: [] },
    'Noto Sans NKo': { category: 'sans-serif', classifications: [] },
    'Noto Sans NKo Unjoined': { category: 'sans-serif', classifications: [] },
    'Noto Sans Nushu': { category: 'sans-serif', classifications: [] },
    'Noto Sans Ogham': { category: 'sans-serif', classifications: [] },
    'Noto Sans Ol Chiki': { category: 'sans-serif', classifications: [] },
    'Noto Sans Old Hungarian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Old Italic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Old North Arabian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Old Permic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Old Persian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Old Sogdian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Old South Arabian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Old Turkic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Oriya': { category: 'sans-serif', classifications: [] },
    'Noto Sans Osage': { category: 'sans-serif', classifications: [] },
    'Noto Sans Osmanya': { category: 'sans-serif', classifications: [] },
    'Noto Sans Pahawh Hmong': { category: 'sans-serif', classifications: [] },
    'Noto Sans Palmyrene': { category: 'sans-serif', classifications: [] },
    'Noto Sans Pau Cin Hau': { category: 'sans-serif', classifications: [] },
    'Noto Sans PhagsPa': { category: 'sans-serif', classifications: [] },
    'Noto Sans Phoenician': { category: 'sans-serif', classifications: [] },
    'Noto Sans Psalter Pahlavi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Rejang': { category: 'sans-serif', classifications: [] },
    'Noto Sans Runic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Samaritan': { category: 'sans-serif', classifications: [] },
    'Noto Sans Saurashtra': { category: 'sans-serif', classifications: [] },
    'Noto Sans SC': { category: 'sans-serif', classifications: [] },
    'Noto Sans Sharada': { category: 'sans-serif', classifications: [] },
    'Noto Sans Shavian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Siddham': { category: 'sans-serif', classifications: [] },
    'Noto Sans SignWriting': { category: 'sans-serif', classifications: [] },
    'Noto Sans Sinhala': { category: 'sans-serif', classifications: [] },
    'Noto Sans Sogdian': { category: 'sans-serif', classifications: [] },
    'Noto Sans Sora Sompeng': { category: 'sans-serif', classifications: [] },
    'Noto Sans Soyombo': { category: 'sans-serif', classifications: [] },
    'Noto Sans Sundanese': { category: 'sans-serif', classifications: [] },
    'Noto Sans Sunuwar': { category: 'sans-serif', classifications: [] },
    'Noto Sans Syloti Nagri': { category: 'sans-serif', classifications: [] },
    'Noto Sans Symbols': { category: 'sans-serif', classifications: ['symbols'] },
    'Noto Sans Symbols 2': { category: 'sans-serif', classifications: ['symbols'] },
    'Noto Sans Syriac': { category: 'sans-serif', classifications: [] },
    'Noto Sans Syriac Eastern': { category: 'sans-serif', classifications: [] },
    'Noto Sans Syriac Western': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tagalog': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tagbanwa': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tai Le': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tai Tham': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tai Viet': { category: 'sans-serif', classifications: [] },
    'Noto Sans Takri': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tamil': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tamil Supplement': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tangsa': { category: 'sans-serif', classifications: [] },
    'Noto Sans TC': { category: 'sans-serif', classifications: [] },
    'Noto Sans Telugu': { category: 'sans-serif', classifications: [] },
    'Noto Sans Thaana': { category: 'sans-serif', classifications: [] },
    'Noto Sans Thai': { category: 'sans-serif', classifications: [] },
    'Noto Sans Thai Looped': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tifinagh': { category: 'sans-serif', classifications: [] },
    'Noto Sans Tirhuta': { category: 'sans-serif', classifications: [] },
    'Noto Sans Ugaritic': { category: 'sans-serif', classifications: [] },
    'Noto Sans Vai': { category: 'sans-serif', classifications: [] },
    'Noto Sans Vithkuqi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Wancho': { category: 'sans-serif', classifications: [] },
    'Noto Sans Warang Citi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Yi': { category: 'sans-serif', classifications: [] },
    'Noto Sans Zanabazar Square': { category: 'sans-serif', classifications: [] },
    'Noto Serif': { category: 'serif', classifications: [] },
    'Noto Serif Ahom': { category: 'serif', classifications: [] },
    'Noto Serif Armenian': { category: 'serif', classifications: [] },
    'Noto Serif Balinese': { category: 'serif', classifications: [] },
    'Noto Serif Bengali': { category: 'serif', classifications: [] },
    'Noto Serif Devanagari': { category: 'serif', classifications: [] },
    'Noto Serif Display': { category: 'serif', classifications: ['display'] },
    'Noto Serif Dives Akuru': { category: 'serif', classifications: [] },
    'Noto Serif Dogra': { category: 'serif', classifications: [] },
    'Noto Serif Ethiopic': { category: 'serif', classifications: [] },
    'Noto Serif Georgian': { category: 'serif', classifications: [] },
    'Noto Serif Grantha': { category: 'serif', classifications: [] },
    'Noto Serif Gujarati': { category: 'serif', classifications: [] },
    'Noto Serif Gurmukhi': { category: 'serif', classifications: [] },
    'Noto Serif Hebrew': { category: 'serif', classifications: [] },
    'Noto Serif Hentaigana': { category: 'serif', classifications: [] },
    'Noto Serif HK': { category: 'serif', classifications: [] },
    'Noto Serif JP': { category: 'serif', classifications: [] },
    'Noto Serif Kannada': { category: 'serif', classifications: [] },
    'Noto Serif Khitan Small Script': { category: 'serif', classifications: [] },
    'Noto Serif Khmer': { category: 'serif', classifications: [] },
    'Noto Serif Khojki': { category: 'serif', classifications: [] },
    'Noto Serif KR': { category: 'serif', classifications: [] },
    'Noto Serif Lao': { category: 'serif', classifications: [] },
    'Noto Serif Makasar': { category: 'serif', classifications: [] },
    'Noto Serif Malayalam': { category: 'serif', classifications: [] },
    'Noto Serif Myanmar': { category: 'serif', classifications: [] },
    'Noto Serif NP Hmong': { category: 'serif', classifications: [] },
    'Noto Serif Old Uyghur': { category: 'serif', classifications: [] },
    'Noto Serif Oriya': { category: 'serif', classifications: [] },
    'Noto Serif Ottoman Siyaq': { category: 'serif', classifications: [] },
    'Noto Serif SC': { category: 'serif', classifications: [] },
    'Noto Serif Sinhala': { category: 'serif', classifications: [] },
    'Noto Serif Tamil': { category: 'serif', classifications: [] },
    'Noto Serif Tangut': { category: 'serif', classifications: [] },
    'Noto Serif TC': { category: 'serif', classifications: [] },
    'Noto Serif Telugu': { category: 'serif', classifications: [] },
    'Noto Serif Thai': { category: 'serif', classifications: [] },
    'Noto Serif Tibetan': { category: 'serif', classifications: [] },
    'Noto Serif Todhri': { category: 'serif', classifications: [] },
    'Noto Serif Toto': { category: 'serif', classifications: [] },
    'Noto Serif Vithkuqi': { category: 'serif', classifications: [] },
    'Noto Serif Yezidi': { category: 'serif', classifications: [] },
    'Noto Traditional Nushu': { category: 'sans-serif', classifications: [] },
    'Noto Znamenny Musical Notation': { category: 'sans-serif', classifications: ['symbols'] },
    'Nova Cut': { category: 'display', classifications: ['display'] },
    'Nova Flat': { category: 'display', classifications: ['display'] },
    'Nova Mono': { category: 'monospace', classifications: ['display', 'monospace'] },
    'Nova Oval': { category: 'display', classifications: ['display'] },
    'Nova Round': { category: 'display', classifications: ['display'] },
    'Nova Script': { category: 'display', classifications: ['display'] },
    'Nova Slim': { category: 'display', classifications: ['display'] },
    'Nova Square': { category: 'display', classifications: ['display'] },
    'NTR': { category: 'sans-serif', classifications: [] },
    'Numans': { category: 'sans-serif', classifications: [] },
    'Nunito': { category: 'sans-serif', classifications: [] },
    'Nunito Sans': { category: 'sans-serif', classifications: [] },
    'Nuosu SIL': { category: 'sans-serif', classifications: [] },
    'Odibee Sans': { category: 'display', classifications: ['display'] },
    'Odor Mean Chey': { category: 'serif', classifications: [] },
    'Offside': { category: 'display', classifications: ['display'] },
    'Oi': { category: 'display', classifications: ['display'] },
    'Ojuju': { category: 'sans-serif', classifications: ['display'] },
    'Old Standard TT': { category: 'serif', classifications: ['display'] },
    'Oldenburg': { category: 'display', classifications: ['display'] },
    'Ole': { category: 'handwriting', classifications: ['handwriting'] },
    'Oleo Script': { category: 'display', classifications: ['display'] },
    'Oleo Script Swash Caps': { category: 'display', classifications: ['display'] },
    'Onest': { category: 'sans-serif', classifications: [] },
    'Oooh Baby': { category: 'handwriting', classifications: ['handwriting'] },
    'Open Sans': { category: 'sans-serif', classifications: [] },
    'Oranienbaum': { category: 'serif', classifications: [] },
    'Orbit': { category: 'sans-serif', classifications: [] },
    'Orbitron': { category: 'sans-serif', classifications: ['display'] },
    'Oregano': { category: 'display', classifications: ['handwriting', 'display'] },
    'Orelega One': { category: 'display', classifications: ['display'] },
    'Orienta': { category: 'sans-serif', classifications: [] },
    'Original Surfer': { category: 'display', classifications: ['display'] },
    'Oswald': { category: 'sans-serif', classifications: [] },
    'Outfit': { category: 'sans-serif', classifications: [] },
    'Over the Rainbow': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Overlock': { category: 'display', classifications: ['display'] },
    'Overlock SC': { category: 'display', classifications: ['display'] },
    'Overpass': { category: 'sans-serif', classifications: [] },
    'Overpass Mono': { category: 'monospace', classifications: ['monospace'] },
    'Ovo': { category: 'serif', classifications: [] },
    'Oxanium': { category: 'display', classifications: ['display'] },
    'Oxygen': { category: 'sans-serif', classifications: [] },
    'Oxygen Mono': { category: 'monospace', classifications: ['monospace'] },
    'Pacifico': { category: 'handwriting', classifications: ['handwriting'] },
    'Padauk': { category: 'sans-serif', classifications: [] },
    'Padyakke Expanded One': { category: 'serif', classifications: ['display'] },
    'Palanquin': { category: 'sans-serif', classifications: [] },
    'Palanquin Dark': { category: 'sans-serif', classifications: ['display'] },
    'Palette Mosaic': { category: 'display', classifications: ['display'] },
    'Pangolin': { category: 'handwriting', classifications: ['handwriting'] },
    'Paprika': { category: 'display', classifications: ['display'] },
    'Parastoo': { category: 'serif', classifications: [] },
    'Parisienne': { category: 'handwriting', classifications: ['handwriting'] },
    'Parkinsans': { category: 'sans-serif', classifications: [] },
    'Passero One': { category: 'display', classifications: ['display'] },
    'Passion One': { category: 'display', classifications: ['display'] },
    'Passions Conflict': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Pathway Extreme': { category: 'sans-serif', classifications: [] },
    'Pathway Gothic One': { category: 'sans-serif', classifications: [] },
    'Patrick Hand': { category: 'handwriting', classifications: ['handwriting'] },
    'Patrick Hand SC': { category: 'handwriting', classifications: ['handwriting'] },
    'Pattaya': { category: 'sans-serif', classifications: ['display'] },
    'Patua One': { category: 'display', classifications: ['display'] },
    'Pavanam': { category: 'sans-serif', classifications: [] },
    'Paytone One': { category: 'sans-serif', classifications: ['display'] },
    'Peddana': { category: 'serif', classifications: [] },
    'Peralta': { category: 'serif', classifications: ['display'] },
    'Permanent Marker': { category: 'handwriting', classifications: ['handwriting'] },
    'Petemoss': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Petit Formal Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Petrona': { category: 'serif', classifications: [] },
    'Phetsarath': { category: 'sans-serif', classifications: [] },
    'Philosopher': { category: 'sans-serif', classifications: [] },
    'Phudu': { category: 'display', classifications: ['display'] },
    'Piazzolla': { category: 'serif', classifications: ['display'] },
    'Piedra': { category: 'display', classifications: ['display'] },
    'Pinyon Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Pirata One': { category: 'display', classifications: ['display'] },
    'Pixelify Sans': { category: 'display', classifications: ['display'] },
    'Plaster': { category: 'display', classifications: ['display'] },
    'Platypi': { category: 'serif', classifications: [] },
    'Play': { category: 'sans-serif', classifications: ['display'] },
    'Playball': { category: 'display', classifications: ['handwriting', 'display'] },
    'Playfair': { category: 'serif', classifications: ['display'] },
    'Playfair Display': { category: 'serif', classifications: ['display'] },
    'Playfair Display SC': { category: 'serif', classifications: [] },
    'Playpen Sans': { category: 'handwriting', classifications: ['handwriting'] },
    'Playpen Sans Arabic': { category: 'handwriting', classifications: ['handwriting'] },
    'Playpen Sans Deva': { category: 'handwriting', classifications: ['handwriting'] },
    'Playpen Sans Hebrew': { category: 'handwriting', classifications: ['handwriting'] },
    'Playpen Sans Thai': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AR': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AR Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AT': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AT Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU NSW': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU NSW Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU QLD': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU QLD Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU SA': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU SA Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU TAS': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU TAS Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU VIC': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite AU VIC Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite BE VLG': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite BE VLG Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite BE WAL': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite BE WAL Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite BR': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite BR Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CA': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CA Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CL': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CL Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CO': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CO Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CU': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CU Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CZ': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite CZ Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DE Grund': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DE Grund Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DE LA': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DE LA Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DE SAS': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DE SAS Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DE VA': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DE VA Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DK Loopet': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DK Loopet Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DK Uloopet': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite DK Uloopet Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite ES': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite ES Deco': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite ES Deco Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite ES Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite FR Moderne': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite FR Moderne Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite FR Trad': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite FR Trad Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite GB J': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite GB J Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite GB S': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite GB S Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite HR': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite HR Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite HR Lijeva': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite HR Lijeva Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite HU': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite HU Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite ID': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite ID Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IE': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IE Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IN': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IN Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IS': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IS Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IT Moderna': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IT Moderna Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IT Trad': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite IT Trad Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite MX': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite MX Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NG Modern': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NG Modern Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NL': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NL Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NO': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NO Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NZ': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NZ Basic': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NZ Basic Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite NZ Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite PE': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite PE Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite PL': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite PL Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite PT': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite PT Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite RO': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite RO Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite SK': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite SK Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite TZ': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite TZ Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite US Modern': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite US Modern Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite US Trad': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite US Trad Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite VN': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite VN Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite ZA': { category: 'handwriting', classifications: ['handwriting'] },
    'Playwrite ZA Guides': { category: 'handwriting', classifications: ['handwriting'] },
    'Plus Jakarta Sans': { category: 'sans-serif', classifications: [] },
    'Pochaevsk': { category: 'display', classifications: ['display'] },
    'Podkova': { category: 'serif', classifications: ['display'] },
    'Poetsen One': { category: 'display', classifications: ['display'] },
    'Poiret One': { category: 'display', classifications: ['display'] },
    'Poller One': { category: 'display', classifications: ['display'] },
    'Poltawski Nowy': { category: 'serif', classifications: [] },
    'Poly': { category: 'serif', classifications: [] },
    'Pompiere': { category: 'display', classifications: ['display'] },
    'Ponnala': { category: 'display', classifications: ['display'] },
    'Ponomar': { category: 'display', classifications: ['display'] },
    'Pontano Sans': { category: 'sans-serif', classifications: [] },
    'Poor Story': { category: 'display', classifications: ['display'] },
    'Poppins': { category: 'sans-serif', classifications: [] },
    'Port Lligat Sans': { category: 'sans-serif', classifications: ['display'] },
    'Port Lligat Slab': { category: 'serif', classifications: ['display'] },
    'Potta One': { category: 'display', classifications: ['display'] },
    'Pragati Narrow': { category: 'sans-serif', classifications: [] },
    'Praise': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Prata': { category: 'serif', classifications: ['display'] },
    'Preahvihear': { category: 'sans-serif', classifications: ['display'] },
    'Press Start 2P': { category: 'display', classifications: ['display'] },
    'Pridi': { category: 'serif', classifications: ['display'] },
    'Princess Sofia': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Prociono': { category: 'serif', classifications: ['display'] },
    'Prompt': { category: 'sans-serif', classifications: [] },
    'Prosto One': { category: 'display', classifications: ['display'] },
    'Protest Guerrilla': { category: 'display', classifications: ['display'] },
    'Protest Revolution': { category: 'display', classifications: ['display'] },
    'Protest Riot': { category: 'display', classifications: ['display'] },
    'Protest Strike': { category: 'display', classifications: ['display'] },
    'Proza Libre': { category: 'sans-serif', classifications: [] },
    'PT Mono': { category: 'monospace', classifications: ['monospace'] },
    'PT Sans': { category: 'sans-serif', classifications: [] },
    'PT Sans Caption': { category: 'sans-serif', classifications: [] },
    'PT Sans Narrow': { category: 'sans-serif', classifications: [] },
    'PT Serif': { category: 'serif', classifications: [] },
    'PT Serif Caption': { category: 'serif', classifications: [] },
    'Public Sans': { category: 'sans-serif', classifications: [] },
    'Puppies Play': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Puritan': { category: 'sans-serif', classifications: [] },
    'Purple Purse': { category: 'display', classifications: ['display'] },
    'Qahiri': { category: 'sans-serif', classifications: [] },
    'Quando': { category: 'serif', classifications: ['display'] },
    'Quantico': { category: 'sans-serif', classifications: ['display'] },
    'Quattrocento': { category: 'serif', classifications: ['display'] },
    'Quattrocento Sans': { category: 'sans-serif', classifications: [] },
    'Questrial': { category: 'sans-serif', classifications: [] },
    'Quicksand': { category: 'sans-serif', classifications: [] },
    'Quintessential': { category: 'handwriting', classifications: ['display'] },
    'Qwigley': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Qwitcher Grypen': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Racing Sans One': { category: 'display', classifications: ['display'] },
    'Radio Canada': { category: 'sans-serif', classifications: [] },
    'Radio Canada Big': { category: 'sans-serif', classifications: [] },
    'Radley': { category: 'serif', classifications: ['display'] },
    'Rajdhani': { category: 'sans-serif', classifications: [] },
    'Rakkas': { category: 'display', classifications: ['display'] },
    'Raleway': { category: 'sans-serif', classifications: [] },
    'Raleway Dots': { category: 'display', classifications: ['display'] },
    'Ramabhadra': { category: 'sans-serif', classifications: [] },
    'Ramaraja': { category: 'serif', classifications: [] },
    'Rambla': { category: 'sans-serif', classifications: [] },
    'Rammetto One': { category: 'display', classifications: ['display'] },
    'Rampart One': { category: 'display', classifications: ['display'] },
    'Ramsina': { category: 'serif', classifications: [] },
    'Ranchers': { category: 'display', classifications: ['display'] },
    'Rancho': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Ranga': { category: 'display', classifications: ['handwriting', 'display'] },
    'Rasa': { category: 'serif', classifications: ['display'] },
    'Rationale': { category: 'sans-serif', classifications: ['display'] },
    'Ravi Prakash': { category: 'display', classifications: ['display'] },
    'Readex Pro': { category: 'sans-serif', classifications: [] },
    'Recursive': { category: 'sans-serif', classifications: [] },
    'Red Hat Display': { category: 'sans-serif', classifications: ['display'] },
    'Red Hat Mono': { category: 'monospace', classifications: ['monospace'] },
    'Red Hat Text': { category: 'sans-serif', classifications: [] },
    'Red Rose': { category: 'display', classifications: ['display'] },
    'Redacted': { category: 'display', classifications: ['display', 'symbols'] },
    'Redacted Script': { category: 'display', classifications: ['handwriting', 'symbols'] },
    'Reddit Mono': { category: 'monospace', classifications: ['monospace'] },
    'Reddit Sans': { category: 'sans-serif', classifications: [] },
    'Reddit Sans Condensed': { category: 'sans-serif', classifications: [] },
    'Redressed': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Reem Kufi': { category: 'sans-serif', classifications: [] },
    'Reem Kufi Fun': { category: 'sans-serif', classifications: [] },
    'Reem Kufi Ink': { category: 'sans-serif', classifications: [] },
    'Reenie Beanie': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Reggae One': { category: 'display', classifications: ['display'] },
    'REM': { category: 'sans-serif', classifications: [] },
    'Rethink Sans': { category: 'sans-serif', classifications: [] },
    'Revalia': { category: 'display', classifications: ['display'] },
    'Rhodium Libre': { category: 'serif', classifications: ['display'] },
    'Ribeye': { category: 'display', classifications: ['display'] },
    'Ribeye Marrow': { category: 'display', classifications: ['display'] },
    'Righteous': { category: 'display', classifications: ['display'] },
    'Risque': { category: 'display', classifications: ['display'] },
    'Road Rage': { category: 'display', classifications: ['display'] },
    'Roboto': { category: 'sans-serif', classifications: [] },
    'Roboto Condensed': { category: 'sans-serif', classifications: [] },
    'Roboto Flex': { category: 'sans-serif', classifications: [] },
    'Roboto Mono': { category: 'monospace', classifications: ['monospace'] },
    'Roboto Serif': { category: 'serif', classifications: [] },
    'Roboto Slab': { category: 'serif', classifications: [] },
    'Rochester': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Rock 3D': { category: 'display', classifications: ['display'] },
    'Rock Salt': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'RocknRoll One': { category: 'sans-serif', classifications: [] },
    'Rokkitt': { category: 'serif', classifications: [] },
    'Romanesco': { category: 'handwriting', classifications: ['handwriting'] },
    'Ropa Sans': { category: 'sans-serif', classifications: [] },
    'Rosario': { category: 'sans-serif', classifications: [] },
    'Rosarivo': { category: 'serif', classifications: ['handwriting'] },
    'Rouge Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Rowdies': { category: 'display', classifications: ['display'] },
    'Rozha One': { category: 'serif', classifications: ['display'] },
    'Rubik': { category: 'sans-serif', classifications: [] },
    'Rubik 80s Fade': { category: 'display', classifications: ['display'] },
    'Rubik Beastly': { category: 'display', classifications: ['display'] },
    'Rubik Broken Fax': { category: 'display', classifications: ['display'] },
    'Rubik Bubbles': { category: 'display', classifications: ['display'] },
    'Rubik Burned': { category: 'display', classifications: ['display'] },
    'Rubik Dirt': { category: 'display', classifications: ['display'] },
    'Rubik Distressed': { category: 'display', classifications: ['display'] },
    'Rubik Doodle Shadow': { category: 'display', classifications: ['display'] },
    'Rubik Doodle Triangles': { category: 'display', classifications: ['display'] },
    'Rubik Gemstones': { category: 'display', classifications: ['display'] },
    'Rubik Glitch': { category: 'display', classifications: ['display'] },
    'Rubik Glitch Pop': { category: 'display', classifications: ['display'] },
    'Rubik Iso': { category: 'display', classifications: ['display'] },
    'Rubik Lines': { category: 'display', classifications: ['display'] },
    'Rubik Maps': { category: 'display', classifications: ['display'] },
    'Rubik Marker Hatch': { category: 'display', classifications: ['display'] },
    'Rubik Maze': { category: 'display', classifications: ['display'] },
    'Rubik Microbe': { category: 'display', classifications: ['display'] },
    'Rubik Mono One': { category: 'sans-serif', classifications: ['monospace'] },
    'Rubik Moonrocks': { category: 'display', classifications: ['display'] },
    'Rubik Pixels': { category: 'display', classifications: ['display'] },
    'Rubik Puddles': { category: 'display', classifications: ['display'] },
    'Rubik Scribble': { category: 'display', classifications: ['display'] },
    'Rubik Spray Paint': { category: 'display', classifications: ['display'] },
    'Rubik Storm': { category: 'display', classifications: ['display'] },
    'Rubik Vinyl': { category: 'display', classifications: ['display'] },
    'Rubik Wet Paint': { category: 'display', classifications: ['display'] },
    'Ruda': { category: 'sans-serif', classifications: ['display'] },
    'Rufina': { category: 'serif', classifications: ['display'] },
    'Ruge Boogie': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Ruluko': { category: 'sans-serif', classifications: [] },
    'Rum Raisin': { category: 'sans-serif', classifications: ['display'] },
    'Ruslan Display': { category: 'display', classifications: ['display'] },
    'Russo One': { category: 'sans-serif', classifications: ['display'] },
    'Ruthie': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Ruwudu': { category: 'serif', classifications: [] },
    'Rye': { category: 'display', classifications: ['display'] },
    'Sacramento': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Sahitya': { category: 'serif', classifications: [] },
    'Sail': { category: 'display', classifications: ['display'] },
    'Saira': { category: 'sans-serif', classifications: ['display'] },
    'Saira Condensed': { category: 'sans-serif', classifications: [] },
    'Saira Extra Condensed': { category: 'sans-serif', classifications: ['display'] },
    'Saira Semi Condensed': { category: 'sans-serif', classifications: ['display'] },
    'Saira Stencil One': { category: 'display', classifications: ['display'] },
    'Salsa': { category: 'display', classifications: ['handwriting'] },
    'Sanchez': { category: 'serif', classifications: [] },
    'Sancreek': { category: 'display', classifications: ['display'] },
    'Sankofa Display': { category: 'sans-serif', classifications: [] },
    'Sansation': { category: 'sans-serif', classifications: [] },
    'Sansita': { category: 'sans-serif', classifications: [] },
    'Sansita Swashed': { category: 'display', classifications: ['display'] },
    'Sarabun': { category: 'sans-serif', classifications: ['display'] },
    'Sarala': { category: 'sans-serif', classifications: ['display'] },
    'Sarina': { category: 'display', classifications: ['handwriting', 'display'] },
    'Sarpanch': { category: 'sans-serif', classifications: ['display'] },
    'Sassy Frass': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Satisfy': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Savate': { category: 'sans-serif', classifications: ['display'] },
    'Sawarabi Gothic': { category: 'sans-serif', classifications: [] },
    'Sawarabi Mincho': { category: 'serif', classifications: [] },
    'Scada': { category: 'sans-serif', classifications: [] },
    'Scheherazade New': { category: 'serif', classifications: [] },
    'Schibsted Grotesk': { category: 'sans-serif', classifications: [] },
    'Schoolbell': { category: 'handwriting', classifications: ['handwriting'] },
    'Science Gothic': { category: 'sans-serif', classifications: [] },
    'Scope One': { category: 'serif', classifications: [] },
    'Seaweed Script': { category: 'display', classifications: ['handwriting', 'display'] },
    'Secular One': { category: 'sans-serif', classifications: [] },
    'Sedan': { category: 'serif', classifications: ['display'] },
    'Sedan SC': { category: 'serif', classifications: ['display'] },
    'Sedgwick Ave': { category: 'handwriting', classifications: ['handwriting'] },
    'Sedgwick Ave Display': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Sekuya': { category: 'display', classifications: ['display'] },
    'Sen': { category: 'sans-serif', classifications: [] },
    'Send Flowers': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Sevillana': { category: 'display', classifications: ['handwriting', 'display'] },
    'Seymour One': { category: 'sans-serif', classifications: ['display'] },
    'Shadows Into Light': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Shadows Into Light Two': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Shafarik': { category: 'display', classifications: ['display'] },
    'Shalimar': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Shantell Sans': { category: 'display', classifications: ['handwriting'] },
    'Shanti': { category: 'sans-serif', classifications: [] },
    'Share': { category: 'sans-serif', classifications: [] },
    'Share Tech': { category: 'sans-serif', classifications: ['display'] },
    'Share Tech Mono': { category: 'monospace', classifications: ['monospace'] },
    'Shippori Antique': { category: 'sans-serif', classifications: [] },
    'Shippori Antique B1': { category: 'sans-serif', classifications: [] },
    'Shippori Mincho': { category: 'serif', classifications: [] },
    'Shippori Mincho B1': { category: 'serif', classifications: [] },
    'Shizuru': { category: 'display', classifications: ['display'] },
    'Shojumaru': { category: 'display', classifications: ['display'] },
    'Short Stack': { category: 'handwriting', classifications: ['handwriting'] },
    'Shrikhand': { category: 'display', classifications: ['display'] },
    'Siemreap': { category: 'sans-serif', classifications: [] },
    'Sigmar': { category: 'display', classifications: ['display'] },
    'Sigmar One': { category: 'display', classifications: ['display'] },
    'Signika': { category: 'sans-serif', classifications: [] },
    'Signika Negative': { category: 'sans-serif', classifications: [] },
    'Silkscreen': { category: 'display', classifications: ['display'] },
    'Simonetta': { category: 'display', classifications: ['display'] },
    'Single Day': { category: 'display', classifications: ['handwriting', 'display'] },
    'Sintony': { category: 'sans-serif', classifications: ['display'] },
    'Sirin Stencil': { category: 'display', classifications: ['display'] },
    'Sirivennela': { category: 'sans-serif', classifications: ['display'] },
    'Six Caps': { category: 'sans-serif', classifications: ['display'] },
    'Sixtyfour': { category: 'monospace', classifications: ['display'] },
    'Sixtyfour Convergence': { category: 'monospace', classifications: ['display'] },
    'Skranji': { category: 'display', classifications: ['display'] },
    'Slabo 13px': { category: 'serif', classifications: [] },
    'Slabo 27px': { category: 'serif', classifications: [] },
    'Slackey': { category: 'display', classifications: ['display'] },
    'Slackside One': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Smokum': { category: 'display', classifications: ['display'] },
    'Smooch': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Smooch Sans': { category: 'sans-serif', classifications: ['display'] },
    'Smythe': { category: 'display', classifications: ['display'] },
    'SN Pro': { category: 'sans-serif', classifications: [] },
    'Sniglet': { category: 'display', classifications: ['display'] },
    'Snippet': { category: 'sans-serif', classifications: [] },
    'Snowburst One': { category: 'display', classifications: ['display'] },
    'Sofadi One': { category: 'display', classifications: ['display'] },
    'Sofia': { category: 'handwriting', classifications: ['handwriting'] },
    'Sofia Sans': { category: 'sans-serif', classifications: [] },
    'Sofia Sans Condensed': { category: 'sans-serif', classifications: [] },
    'Sofia Sans Extra Condensed': { category: 'sans-serif', classifications: [] },
    'Sofia Sans Semi Condensed': { category: 'sans-serif', classifications: [] },
    'Solitreo': { category: 'handwriting', classifications: ['handwriting'] },
    'Solway': { category: 'serif', classifications: [] },
    'Sometype Mono': { category: 'monospace', classifications: ['monospace'] },
    'Song Myung': { category: 'serif', classifications: [] },
    'Sono': { category: 'sans-serif', classifications: ['monospace'] },
    'Sonsie One': { category: 'display', classifications: ['display'] },
    'Sora': { category: 'sans-serif', classifications: [] },
    'Sorts Mill Goudy': { category: 'serif', classifications: [] },
    'Sour Gummy': { category: 'sans-serif', classifications: ['display'] },
    'Source Code Pro': { category: 'monospace', classifications: ['monospace'] },
    'Source Sans 3': { category: 'sans-serif', classifications: [] },
    'Source Serif 4': { category: 'serif', classifications: [] },
    'Space Grotesk': { category: 'sans-serif', classifications: [] },
    'Space Mono': { category: 'monospace', classifications: ['monospace'] },
    'Special Elite': { category: 'display', classifications: ['display'] },
    'Special Gothic': { category: 'sans-serif', classifications: [] },
    'Special Gothic Condensed One': { category: 'sans-serif', classifications: [] },
    'Special Gothic Expanded One': { category: 'sans-serif', classifications: [] },
    'Spectral': { category: 'serif', classifications: [] },
    'Spectral SC': { category: 'serif', classifications: [] },
    'Spicy Rice': { category: 'display', classifications: ['display'] },
    'Spinnaker': { category: 'sans-serif', classifications: ['display'] },
    'Spirax': { category: 'display', classifications: ['display'] },
    'Splash': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Spline Sans': { category: 'sans-serif', classifications: [] },
    'Spline Sans Mono': { category: 'monospace', classifications: ['monospace'] },
    'Squada One': { category: 'display', classifications: ['display'] },
    'Square Peg': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Sree Krushnadevaraya': { category: 'serif', classifications: [] },
    'Sriracha': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Srisakdi': { category: 'display', classifications: ['display'] },
    'Staatliches': { category: 'display', classifications: ['display'] },
    'Stack Sans Headline': { category: 'sans-serif', classifications: [] },
    'Stack Sans Notch': { category: 'sans-serif', classifications: ['display'] },
    'Stack Sans Text': { category: 'sans-serif', classifications: [] },
    'Stalemate': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Stalinist One': { category: 'display', classifications: ['display'] },
    'Stardos Stencil': { category: 'display', classifications: ['display'] },
    'Stick': { category: 'sans-serif', classifications: ['display'] },
    'Stick No Bills': { category: 'sans-serif', classifications: ['display'] },
    'Stint Ultra Condensed': { category: 'serif', classifications: ['display'] },
    'Stint Ultra Expanded': { category: 'serif', classifications: ['display'] },
    'STIX Two Text': { category: 'serif', classifications: [] },
    'Stoke': { category: 'serif', classifications: ['display'] },
    'Story Script': { category: 'sans-serif', classifications: ['display'] },
    'Strait': { category: 'sans-serif', classifications: ['display'] },
    'Style Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Stylish': { category: 'sans-serif', classifications: ['display'] },
    'Sue Ellen Francisco': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Suez One': { category: 'serif', classifications: ['display'] },
    'Sulphur Point': { category: 'sans-serif', classifications: [] },
    'Sumana': { category: 'serif', classifications: [] },
    'Sunflower': { category: 'sans-serif', classifications: [] },
    'Sunshiney': { category: 'handwriting', classifications: ['handwriting'] },
    'Supermercado One': { category: 'display', classifications: ['display'] },
    'Sura': { category: 'serif', classifications: [] },
    'Suranna': { category: 'serif', classifications: [] },
    'Suravaram': { category: 'serif', classifications: [] },
    'SUSE': { category: 'sans-serif', classifications: [] },
    'SUSE Mono': { category: 'sans-serif', classifications: [] },
    'Suwannaphum': { category: 'serif', classifications: [] },
    'Swanky and Moo Moo': { category: 'handwriting', classifications: ['handwriting'] },
    'Syncopate': { category: 'sans-serif', classifications: ['display'] },
    'Syne': { category: 'sans-serif', classifications: ['display'] },
    'Syne Mono': { category: 'monospace', classifications: ['monospace'] },
    'Syne Tactile': { category: 'display', classifications: ['display'] },
    'Tac One': { category: 'sans-serif', classifications: ['display'] },
    'Tagesschrift': { category: 'display', classifications: ['display'] },
    'Tai Heritage Pro': { category: 'serif', classifications: [] },
    'Tajawal': { category: 'sans-serif', classifications: [] },
    'Tangerine': { category: 'handwriting', classifications: ['handwriting'] },
    'Tapestry': { category: 'handwriting', classifications: ['display'] },
    'Taprom': { category: 'display', classifications: ['display'] },
    'TASA Explorer': { category: 'sans-serif', classifications: [] },
    'TASA Orbiter': { category: 'sans-serif', classifications: [] },
    'Tauri': { category: 'sans-serif', classifications: ['display'] },
    'Taviraj': { category: 'serif', classifications: ['display'] },
    'Teachers': { category: 'sans-serif', classifications: [] },
    'Teko': { category: 'sans-serif', classifications: ['display'] },
    'Tektur': { category: 'display', classifications: ['display'] },
    'Telex': { category: 'sans-serif', classifications: [] },
    'Tenali Ramakrishna': { category: 'sans-serif', classifications: [] },
    'Tenor Sans': { category: 'sans-serif', classifications: ['display'] },
    'Text Me One': { category: 'sans-serif', classifications: ['display'] },
    'Texturina': { category: 'serif', classifications: ['display'] },
    'Thasadith': { category: 'sans-serif', classifications: ['display'] },
    'The Girl Next Door': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'The Nautigal': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Tienne': { category: 'serif', classifications: [] },
    'TikTok Sans': { category: 'sans-serif', classifications: [] },
    'Tillana': { category: 'display', classifications: ['display'] },
    'Tilt Neon': { category: 'display', classifications: ['display'] },
    'Tilt Prism': { category: 'display', classifications: ['display'] },
    'Tilt Warp': { category: 'display', classifications: ['display'] },
    'Timmana': { category: 'sans-serif', classifications: [] },
    'Tinos': { category: 'serif', classifications: [] },
    'Tiny5': { category: 'sans-serif', classifications: ['display'] },
    'Tiro Bangla': { category: 'serif', classifications: [] },
    'Tiro Devanagari Hindi': { category: 'serif', classifications: [] },
    'Tiro Devanagari Marathi': { category: 'serif', classifications: [] },
    'Tiro Devanagari Sanskrit': { category: 'serif', classifications: [] },
    'Tiro Gurmukhi': { category: 'serif', classifications: [] },
    'Tiro Kannada': { category: 'serif', classifications: [] },
    'Tiro Tamil': { category: 'serif', classifications: [] },
    'Tiro Telugu': { category: 'serif', classifications: [] },
    'Tirra': { category: 'sans-serif', classifications: ['handwriting'] },
    'Titan One': { category: 'display', classifications: ['display'] },
    'Titillium Web': { category: 'sans-serif', classifications: ['display'] },
    'Tomorrow': { category: 'sans-serif', classifications: ['display'] },
    'Tourney': { category: 'display', classifications: ['display'] },
    'Trade Winds': { category: 'display', classifications: ['display'] },
    'Train One': { category: 'display', classifications: ['display'] },
    'Triodion': { category: 'display', classifications: ['display'] },
    'Trirong': { category: 'serif', classifications: ['display'] },
    'Trispace': { category: 'sans-serif', classifications: [] },
    'Trocchi': { category: 'serif', classifications: ['display'] },
    'Trochut': { category: 'display', classifications: ['display'] },
    'Truculenta': { category: 'sans-serif', classifications: [] },
    'Trykker': { category: 'serif', classifications: [] },
    'Tsukimi Rounded': { category: 'sans-serif', classifications: ['display'] },
    'Tuffy': { category: 'sans-serif', classifications: ['display'] },
    'Tulpen One': { category: 'display', classifications: ['display'] },
    'Turret Road': { category: 'display', classifications: ['display'] },
    'Twinkle Star': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Ubuntu': { category: 'sans-serif', classifications: [] },
    'Ubuntu Condensed': { category: 'sans-serif', classifications: [] },
    'Ubuntu Mono': { category: 'monospace', classifications: ['monospace'] },
    'Ubuntu Sans': { category: 'sans-serif', classifications: [] },
    'Ubuntu Sans Mono': { category: 'monospace', classifications: ['monospace'] },
    'Uchen': { category: 'serif', classifications: ['display'] },
    'Ultra': { category: 'serif', classifications: ['display'] },
    'Unbounded': { category: 'sans-serif', classifications: [] },
    'Uncial Antiqua': { category: 'display', classifications: ['display'] },
    'Underdog': { category: 'display', classifications: ['display'] },
    'Unica One': { category: 'display', classifications: ['display'] },
    'UnifrakturCook': { category: 'display', classifications: ['handwriting', 'display'] },
    'UnifrakturMaguntia': { category: 'display', classifications: ['handwriting', 'display'] },
    'Unkempt': { category: 'display', classifications: ['handwriting', 'display'] },
    'Unlock': { category: 'display', classifications: ['display'] },
    'Unna': { category: 'serif', classifications: ['display'] },
    'UoqMunThenKhung': { category: 'serif', classifications: [] },
    'Updock': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Urbanist': { category: 'sans-serif', classifications: ['display'] },
    'Vampiro One': { category: 'display', classifications: ['display'] },
    'Varela': { category: 'sans-serif', classifications: [] },
    'Varela Round': { category: 'sans-serif', classifications: [] },
    'Varta': { category: 'sans-serif', classifications: [] },
    'Vast Shadow': { category: 'serif', classifications: ['display'] },
    'Vazirmatn': { category: 'sans-serif', classifications: [] },
    'Vend Sans': { category: 'sans-serif', classifications: [] },
    'Vesper Libre': { category: 'serif', classifications: [] },
    'Viaoda Libre': { category: 'display', classifications: ['display'] },
    'Vibes': { category: 'display', classifications: ['display'] },
    'Vibur': { category: 'handwriting', classifications: ['handwriting'] },
    'Victor Mono': { category: 'monospace', classifications: ['monospace'] },
    'Vidaloka': { category: 'serif', classifications: [] },
    'Viga': { category: 'sans-serif', classifications: [] },
    'Vina Sans': { category: 'display', classifications: ['display'] },
    'Voces': { category: 'sans-serif', classifications: [] },
    'Volkhov': { category: 'serif', classifications: [] },
    'Vollkorn': { category: 'serif', classifications: [] },
    'Vollkorn SC': { category: 'serif', classifications: [] },
    'Voltaire': { category: 'sans-serif', classifications: ['display'] },
    'VT323': { category: 'monospace', classifications: ['monospace'] },
    'Vujahday Script': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Waiting for the Sunrise': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Wallpoet': { category: 'display', classifications: ['display'] },
    'Walter Turncoat': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Warnes': { category: 'display', classifications: ['handwriting', 'display'] },
    'Water Brush': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Waterfall': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Wavefont': { category: 'display', classifications: ['display', 'symbols'] },
    'WDXL Lubrifont JP N': { category: 'sans-serif', classifications: [] },
    'WDXL Lubrifont SC': { category: 'sans-serif', classifications: [] },
    'WDXL Lubrifont TC': { category: 'sans-serif', classifications: [] },
    'Wellfleet': { category: 'serif', classifications: [] },
    'Wendy One': { category: 'sans-serif', classifications: ['display'] },
    'Whisper': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'WindSong': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Winky Rough': { category: 'sans-serif', classifications: ['display'] },
    'Winky Sans': { category: 'sans-serif', classifications: ['display'] },
    'Wire One': { category: 'sans-serif', classifications: ['display'] },
    'Wittgenstein': { category: 'serif', classifications: [] },
    'Wix Madefor Display': { category: 'sans-serif', classifications: ['display'] },
    'Wix Madefor Text': { category: 'sans-serif', classifications: [] },
    'Work Sans': { category: 'sans-serif', classifications: [] },
    'Workbench': { category: 'monospace', classifications: ['display'] },
    'Xanh Mono': { category: 'monospace', classifications: ['monospace'] },
    'Yaldevi': { category: 'sans-serif', classifications: [] },
    'Yanone Kaffeesatz': { category: 'sans-serif', classifications: ['display'] },
    'Yantramanav': { category: 'sans-serif', classifications: ['display'] },
    'Yarndings 12': { category: 'display', classifications: ['display', 'symbols'] },
    'Yarndings 12 Charted': { category: 'display', classifications: ['display', 'symbols'] },
    'Yarndings 20': { category: 'display', classifications: ['display', 'symbols'] },
    'Yarndings 20 Charted': { category: 'display', classifications: ['display', 'symbols'] },
    'Yatra One': { category: 'display', classifications: ['display'] },
    'Yellowtail': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Yeon Sung': { category: 'display', classifications: ['display'] },
    'Yeseva One': { category: 'display', classifications: ['display'] },
    'Yesteryear': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Yomogi': { category: 'handwriting', classifications: ['handwriting'] },
    'Young Serif': { category: 'serif', classifications: [] },
    'Yrsa': { category: 'serif', classifications: [] },
    'Ysabeau': { category: 'sans-serif', classifications: [] },
    'Ysabeau Infant': { category: 'sans-serif', classifications: [] },
    'Ysabeau Office': { category: 'sans-serif', classifications: [] },
    'Ysabeau SC': { category: 'sans-serif', classifications: [] },
    'Yuji Boku': { category: 'serif', classifications: [] },
    'Yuji Hentaigana Akari': { category: 'handwriting', classifications: ['handwriting'] },
    'Yuji Hentaigana Akebono': { category: 'handwriting', classifications: ['handwriting'] },
    'Yuji Mai': { category: 'serif', classifications: [] },
    'Yuji Syuku': { category: 'serif', classifications: [] },
    'Yusei Magic': { category: 'sans-serif', classifications: [] },
    'Zain': { category: 'sans-serif', classifications: [] },
    'Zalando Sans': { category: 'sans-serif', classifications: [] },
    'Zalando Sans Expanded': { category: 'sans-serif', classifications: [] },
    'Zalando Sans SemiExpanded': { category: 'sans-serif', classifications: [] },
    'ZCOOL KuaiLe': { category: 'sans-serif', classifications: [] },
    'ZCOOL QingKe HuangYou': { category: 'sans-serif', classifications: [] },
    'ZCOOL XiaoWei': { category: 'sans-serif', classifications: [] },
    'Zen Antique': { category: 'serif', classifications: [] },
    'Zen Antique Soft': { category: 'serif', classifications: [] },
    'Zen Dots': { category: 'display', classifications: ['display'] },
    'Zen Kaku Gothic Antique': { category: 'sans-serif', classifications: [] },
    'Zen Kaku Gothic New': { category: 'sans-serif', classifications: [] },
    'Zen Kurenaido': { category: 'sans-serif', classifications: [] },
    'Zen Loop': { category: 'display', classifications: ['handwriting', 'display'] },
    'Zen Maru Gothic': { category: 'sans-serif', classifications: ['display'] },
    'Zen Old Mincho': { category: 'serif', classifications: [] },
    'Zen Tokyo Zoo': { category: 'display', classifications: ['display'] },
    'Zeyada': { category: 'handwriting', classifications: ['handwriting', 'display'] },
    'Zhi Mang Xing': { category: 'handwriting', classifications: ['handwriting'] },
    'Zilla Slab': { category: 'serif', classifications: [] },
    'Zilla Slab Highlight': { category: 'serif', classifications: [] }
};



// components/01-core-setup.js
// --- Supabase and Auth Integration ---
const supabase = globalThis.__csvlink_supabase;

// --- UTILITIES & SETUP ---
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => Array.from(document.querySelectorAll(sel));
const on = (sel, evt, handler, opts) => { const el = $(sel); if (!el) return null; el.addEventListener(evt, handler, opts); return el; };
const onClick = (sel, handler) => { const el = $(sel); if (!el) return null; el.addEventListener('click', handler); return el; };
const setText = (sel, value) => { const el = $(sel); if (el) el.textContent = value; };

const { jsPDF } = window.jspdf;

// --- STATE ---
const canvasWrapper = $('.canvas-wrap');
const canvasEditorStage = $('.canvas-editor-stage');
const pageActionToolbar = $('#pageActionToolbar');
const canvasPagesPanel = $('#canvasPagesPanel');
const canvasPagesStrip = $('#canvasPagesStrip');
const toggleCanvasPagesPanelBtn = $('#toggleCanvasPagesPanelBtn');
const hideCanvasPagesPanelBtn = $('#hideCanvasPagesPanelBtn');
const canvasPagesHeaderRow = canvasPagesPanel?.querySelector('.canvas-pages-header-row');
// 9. Preserve layer stacking
const canvas = new fabric.Canvas('c', { backgroundColor: 'transparent', selection: true, preserveObjectStacking: true });
// High-quality rendering (avoid blurry output)
canvas.enableRetinaScaling = true;
canvas.imageSmoothingEnabled = true;

function getDefaultSpawnPoint() {
    if (pageRect && typeof pageRect.getCenterPoint === 'function') {
        const center = pageRect.getCenterPoint();
        if (center && Number.isFinite(center.x) && Number.isFinite(center.y)) return center;
    }
    const vpCenter = canvas.getVpCenter();
    return new fabric.Point(vpCenter.x, vpCenter.y);
}
const DEFAULT_PAGE_WIDTH = 768;
const DEFAULT_PAGE_HEIGHT = 1024;
const CAMERA_BOUND_PADDING = 600;
const SERIALIZE_PROPS = ['oid', 'name', 'isTable', 'isSvgGroup', 'rows', 'cols', 'colWidths', 'rowHeights', 'locked', 'pageId', 'headerRows', 'headerFill', 'bodyFill', 'borderColor', 'borderWidth', 'cellData', 'isArtboard', 'curveAmount'];
let pageRect;
let documentPages = [];
let currentPageIndex = 0;
let selectedCanvasIndexes = new Set([0]);
let canvasSelectionAnchorIndex = 0;
let isPageSwitching = false;
let isRenderingCanvasGhosts = false;
let isReassigningPageOwnership = false;
let isPastingFromClipboard = false;
let isObjectInteractionActive = false; // still useful for some logic, but we'll be more careful
let ghostRenderVersion = 0;
let isCanvasPagesPanelCollapsed = false;
let draggedCanvasPageIndex = null;
let generalPageSize = { width: DEFAULT_PAGE_WIDTH, height: DEFAULT_PAGE_HEIGHT };
let bindings = new Map();
let workbook, worksheet, headers = [], dataRows = [];
let identifierColumn = '';
let gridEnabled = false, snapEnabled = true;
let gridCellSize = 32;
let historyStack = [];// history snapshots
let lastHistorySig = null;
let historyIndex = -1;
let historyLocked = false;
let isRestoringHistory = false;
let _clipboard = null;
let _clipboardMeta = null;
const SYSTEM_FONT_LIST = ['Arial', 'Helvetica', 'Times New Roman', 'Georgia', 'Courier New', 'Verdana', 'Impact', 'Comic Sans MS'];
const GOOGLE_FONT_FAMILY_MAP = new Map(GOOGLE_FONT_FAMILIES.map(name => [String(name).toLowerCase(), String(name)]));
const FONT_LIST = Array.from(new Set([...SYSTEM_FONT_LIST, ...GOOGLE_FONT_FAMILIES]))
    .sort((a, b) => a.localeCompare(b));
const FONT_LIST_LOWER_SET = new Set(FONT_LIST.map(name => String(name).toLowerCase()));
const SYSTEM_FONT_METADATA = {
    'Arial': { category: 'sans-serif', classifications: ['modern', 'minimalist'] },
    'Helvetica': { category: 'sans-serif', classifications: ['modern', 'minimalist'] },
    'Times New Roman': { category: 'serif', classifications: ['classic'] },
    'Georgia': { category: 'serif', classifications: ['classic'] },
    'Courier New': { category: 'monospace', classifications: ['retro'] },
    'Verdana': { category: 'sans-serif', classifications: ['modern'] },
    'Impact': { category: 'display', classifications: ['retro'] },
    'Comic Sans MS': { category: 'handwriting', classifications: ['casual'] }
};
const FONT_SERIF_FILTER_OPTIONS = [
    { value: 'all', label: 'All Scripts' },
    { value: 'serif', label: 'Serif' },
    { value: 'non-serif', label: 'Non-Serif' }
];
const FONT_STYLE_FILTER_OPTIONS = [
    { value: 'all', label: 'All Styles' },
    { value: 'modern', label: 'Modern' },
    { value: 'minimalist', label: 'Minimalist' },
    { value: 'retro', label: 'Retro' },
    { value: 'vintage', label: 'Vintage' },
    { value: 'display', label: 'Display' },
    { value: 'handwriting', label: 'Handwriting' },
    { value: 'monospace', label: 'Monospace' }
];
const FONT_RETRO_KEYWORDS = ['retro', 'vintage', 'old', 'classic', 'groovy', 'bubble', 'pixel', 'typewriter', 'western', 'slab', 'deco'];
const FONT_VINTAGE_KEYWORDS = ['vintage', 'oldstyle', 'antique', 'roman', 'gothic', 'medieval', 'victorian'];
const FONT_STYLE_TAG_CACHE = new Map();
const FONT_METADATA_MAP = new Map();
const GOOGLE_FONTS_STYLESHEET_BASE_URL = 'https://fonts.googleapis.com/css2';
const FONT_FAMILY_DATALIST_ID = 'font-family-datalist';
const fontLoadPromiseCache = new Map();
let fontFamilyDatalistInitialized = false;
let editingFillObject = null;
let cropCanvas, croppingImage = null;
let currentUser = null, currentTemplateId = null, userRole = 'free';
let pendingGuestTemplateRestore = false;
const saveStatusEl = $('#saveStatus');
let activeTableCellEditor = null;
const PAGE_STRIP_COLLAPSE_KEY = 'csvlink-canvas-strip-collapsed';
const PAGE_SIDE_GAP = 120;

function normalizeFontFamilyName(fontFamily) {
    if (typeof fontFamily !== 'string') return '';
    const firstFamily = fontFamily.split(',')[0]?.trim();
    if (!firstFamily) return '';
    return firstFamily.replace(/^["']+|["']+$/g, '').trim();
}

function normalizeFontCategory(category) {
    const raw = String(category || '').trim().toLowerCase();
    if (!raw) return 'sans-serif';
    if (raw === 'sans serif' || raw === 'sans-serif' || raw === 'non-serif' || raw === 'non serifs') return 'sans-serif';
    if (raw === 'mono' || raw === 'monospace') return 'monospace';
    if (raw === 'handwriting' || raw === 'script') return 'handwriting';
    if (raw === 'display') return 'display';
    if (raw === 'serif') return 'serif';
    return raw.replace(/\s+/g, '-');
}

function toSearchTokens(value) {
    return String(value || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, ' ')
        .trim()
        .split(/\s+/)
        .filter(Boolean);
}

function buildFontMetadataIndex() {
    if (FONT_METADATA_MAP.size) return;

    Object.entries(GOOGLE_FONT_METADATA || {}).forEach(([family, rawMeta]) => {
        const key = String(family || '').toLowerCase();
        if (!key) return;
        const meta = rawMeta && typeof rawMeta === 'object' ? rawMeta : {};
        const classifications = Array.isArray(meta.classifications)
            ? meta.classifications.map(item => String(item || '').trim().toLowerCase()).filter(Boolean)
            : [];
        FONT_METADATA_MAP.set(key, {
            category: normalizeFontCategory(meta.category),
            classifications
        });
    });

    Object.entries(SYSTEM_FONT_METADATA).forEach(([family, rawMeta]) => {
        const key = String(family || '').toLowerCase();
        if (!key) return;
        const meta = rawMeta && typeof rawMeta === 'object' ? rawMeta : {};
        const classifications = Array.isArray(meta.classifications)
            ? meta.classifications.map(item => String(item || '').trim().toLowerCase()).filter(Boolean)
            : [];
        FONT_METADATA_MAP.set(key, {
            category: normalizeFontCategory(meta.category),
            classifications
        });
    });
}

function getFontMetadata(fontFamily) {
    buildFontMetadataIndex();
    const normalized = normalizeFontFamilyName(fontFamily);
    if (!normalized) return { category: 'sans-serif', classifications: [] };
    const key = normalized.toLowerCase();
    const meta = FONT_METADATA_MAP.get(key);
    if (meta) return meta;
    return { category: 'sans-serif', classifications: [] };
}

function getFontCategory(fontFamily) {
    return getFontMetadata(fontFamily).category || 'sans-serif';
}

function getFontStyleTags(fontFamily) {
    const normalized = normalizeFontFamilyName(fontFamily);
    if (!normalized) return [];
    const cacheKey = normalized.toLowerCase();
    if (FONT_STYLE_TAG_CACHE.has(cacheKey)) return FONT_STYLE_TAG_CACHE.get(cacheKey);

    const tags = new Set();
    const meta = getFontMetadata(normalized);
    const category = normalizeFontCategory(meta.category);
    const classifications = Array.isArray(meta.classifications) ? meta.classifications : [];
    const nameTokens = toSearchTokens(normalized);
    const nameString = nameTokens.join(' ');

    tags.add(category);
    if (category === 'sans-serif') tags.add('non-serif');
    classifications.forEach(tag => tags.add(tag));

    const isRetroName = FONT_RETRO_KEYWORDS.some(keyword => nameString.includes(keyword));
    const isVintageName = FONT_VINTAGE_KEYWORDS.some(keyword => nameString.includes(keyword));

    if (category === 'sans-serif' || category === 'monospace') tags.add('modern');
    if ((category === 'sans-serif' || category === 'monospace') && !isRetroName && !isVintageName) tags.add('minimalist');
    if (isRetroName || classifications.includes('retro') || classifications.includes('slab') || category === 'display') tags.add('retro');
    if (isVintageName || classifications.includes('oldstyle') || classifications.includes('classical') || category === 'serif') tags.add('vintage');

    const result = Array.from(tags);
    FONT_STYLE_TAG_CACHE.set(cacheKey, result);
    return result;
}

function isSerifFontFamily(fontFamily) {
    const meta = getFontMetadata(fontFamily);
    const category = normalizeFontCategory(meta.category);
    const classifications = Array.isArray(meta.classifications) ? meta.classifications : [];
    const tokens = toSearchTokens(fontFamily).join(' ');

    if (category === 'serif') return true;
    if (classifications.includes('serif') || classifications.includes('slab') || classifications.includes('oldstyle') || classifications.includes('classical')) return true;
    if (tokens.includes('serif') || tokens.includes('slab') || tokens.includes('roman')) return true;
    return false;
}

function fontMatchesSerifFilter(fontFamily, serifFilterValue = 'all') {
    const filter = String(serifFilterValue || 'all').trim().toLowerCase();
    if (!filter || filter === 'all') return true;
    const serif = isSerifFontFamily(fontFamily);
    if (filter === 'serif') return serif;
    if (filter === 'non-serif' || filter === 'sans-serif' || filter === 'non serif') return !serif;
    return true;
}

function fontMatchesStyleFilter(fontFamily, styleFilterValue = 'all') {
    const filter = String(styleFilterValue || 'all').trim().toLowerCase();
    if (!filter || filter === 'all') return true;
    const tags = getFontStyleTags(fontFamily);
    return tags.includes(filter);
}

function fontMatchesFilter(fontFamily, filterValue = 'all') {
    return fontMatchesStyleFilter(fontFamily, filterValue);
}

function getFontSerifFilterOptions() {
    return FONT_SERIF_FILTER_OPTIONS.slice();
}

function getFontStyleFilterOptions() {
    return FONT_STYLE_FILTER_OPTIONS.slice();
}

function getFontFilterOptions() {
    return getFontStyleFilterOptions();
}

function toGoogleFontsFamilyParam(fontFamily) {
    return encodeURIComponent(fontFamily).replace(/%20/g, '+');
}

function addFontFamilyToRegistry(fontFamily) {
    const normalized = normalizeFontFamilyName(fontFamily);
    if (!normalized) return '';

    const key = normalized.toLowerCase();
    if (FONT_LIST_LOWER_SET.has(key)) return normalized;

    FONT_LIST_LOWER_SET.add(key);
    FONT_LIST.push(normalized);
    FONT_LIST.sort((a, b) => a.localeCompare(b));
    if (!FONT_METADATA_MAP.has(key)) {
        FONT_METADATA_MAP.set(key, { category: 'sans-serif', classifications: [] });
    }
    FONT_STYLE_TAG_CACHE.delete(key);

    if (fontFamilyDatalistInitialized) {
        const datalist = ensureFontFamilyDatalist();
        if (datalist) {
            const option = document.createElement('option');
            option.value = normalized;
            datalist.appendChild(option);
        }
    }

    return normalized;
}

function ensureFontFamilyDatalist() {
    let datalist = document.getElementById(FONT_FAMILY_DATALIST_ID);
    if (!datalist) {
        datalist = document.createElement('datalist');
        datalist.id = FONT_FAMILY_DATALIST_ID;
        document.body.appendChild(datalist);
    }

    if (!fontFamilyDatalistInitialized) {
        const fragment = document.createDocumentFragment();
        FONT_LIST.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            fragment.appendChild(option);
        });
        datalist.replaceChildren(fragment);
        fontFamilyDatalistInitialized = true;
    }

    return datalist;
}

function refreshCanvasTextObjectsForFont(fontFamily) {
    const target = normalizeFontFamilyName(fontFamily).toLowerCase();
    if (!target || !canvas || typeof canvas.getObjects !== 'function') return;

    let changed = false;
    const visit = (obj) => {
        if (!obj) return;

        const isTextObject = obj.type === 'textbox' || obj.type === 'text' || obj.type === 'i-text';
        if (isTextObject && normalizeFontFamilyName(obj.fontFamily).toLowerCase() === target) {
            if (typeof obj.initDimensions === 'function') obj.initDimensions();
            if (typeof obj.setCoords === 'function') obj.setCoords();
            changed = true;
        }

        if (typeof obj.getObjects === 'function') {
            obj.getObjects().forEach(visit);
        }
    };

    canvas.getObjects().forEach(visit);
    if (changed) canvas.requestRenderAll();
}

function ensureFontFamilyLoaded(fontFamily) {
    const normalized = normalizeFontFamilyName(fontFamily);
    if (!normalized) return Promise.resolve(false);

    const lookupKey = normalized.toLowerCase();
    const canonical = GOOGLE_FONT_FAMILY_MAP.get(lookupKey) || normalized;
    const canonicalKey = canonical.toLowerCase();
    addFontFamilyToRegistry(canonical);
    const isGoogleManaged = GOOGLE_FONT_FAMILY_MAP.has(canonicalKey);

    if (fontLoadPromiseCache.has(canonicalKey)) return fontLoadPromiseCache.get(canonicalKey);

    // For non-Google families (system or uploaded), rely on currently loaded fonts.
    if (!isGoogleManaged) {
        try {
            if (document.fonts && document.fonts.check(`16px "${canonical}"`)) {
                refreshCanvasTextObjectsForFont(canonical);
                return Promise.resolve(true);
            }
        } catch (_) { }
        return Promise.resolve(false);
    }

    const linkId = `gf-${canonicalKey.replace(/[^a-z0-9]+/g, '-')}`;
    const loadPromise = new Promise((resolve) => {
        let settled = false;
        const finish = (ok) => {
            if (settled) return;
            settled = true;
            resolve(!!ok);
        };
        const waitForFontFace = async () => {
            try {
                if (document.fonts && typeof document.fonts.load === 'function') {
                    await Promise.race([
                        document.fonts.load(`16px "${canonical}"`),
                        new Promise(r => setTimeout(r, 2500))
                    ]);
                }
            } catch (_) { }
            finish(true);
        };

        const existingLink = document.getElementById(linkId);
        if (existingLink) {
            if (existingLink.dataset.loaded === '1') {
                waitForFontFace();
                return;
            }
            existingLink.addEventListener('load', () => {
                existingLink.dataset.loaded = '1';
                waitForFontFace();
            }, { once: true });
            existingLink.addEventListener('error', () => {
                console.warn(`Failed to load Google font stylesheet: ${canonical}`);
                finish(false);
            }, { once: true });
            setTimeout(() => finish(existingLink.dataset.loaded === '1'), 4500);
            return;
        }

        const link = document.createElement('link');
        link.id = linkId;
        link.rel = 'stylesheet';
        link.href = `${GOOGLE_FONTS_STYLESHEET_BASE_URL}?family=${toGoogleFontsFamilyParam(canonical)}&display=swap`;
        link.dataset.fontFamily = canonical;
        link.addEventListener('load', () => {
            link.dataset.loaded = '1';
            waitForFontFace();
        }, { once: true });
        link.addEventListener('error', () => {
            console.warn(`Failed to load Google font stylesheet: ${canonical}`);
            finish(false);
        }, { once: true });
        document.head.appendChild(link);
        setTimeout(() => finish(link.dataset.loaded === '1'), 4500);
    }).then((loaded) => {
        if (loaded) refreshCanvasTextObjectsForFont(canonical);
        return loaded;
    }).finally(() => {
        fontLoadPromiseCache.delete(canonicalKey);
    });

    fontLoadPromiseCache.set(canonicalKey, loadPromise);
    return loadPromise;
}

function ensureFontsForCanvasObjects(objects = []) {
    const list = Array.isArray(objects) ? objects : [objects];
    const usedFamilies = new Set();
    const collect = (obj) => {
        if (!obj) return;
        const family = normalizeFontFamilyName(obj.fontFamily);
        if (family) usedFamilies.add(family);
        if (typeof obj.getObjects === 'function') {
            obj.getObjects().forEach(collect);
        }
    };

    list.forEach(collect);
    usedFamilies.forEach(family => { ensureFontFamilyLoaded(family); });
}

const createUid = (prefix = 'id') => `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
const deepClone = (value) => JSON.parse(JSON.stringify(value));

function parsePositiveInt(value, fallback) {
    const n = parseInt(value, 10);
    return Number.isFinite(n) && n > 0 ? n : fallback;
}

function normalizeCanvasPageSelections({ ensureCurrent = true } = {}) {
    const next = new Set();
    selectedCanvasIndexes.forEach(idx => {
        if (Number.isInteger(idx) && idx >= 0 && idx < documentPages.length) next.add(idx);
    });

    if (!next.size && documentPages.length) {
        const safeCurrent = Math.max(0, Math.min(documentPages.length - 1, currentPageIndex));
        next.add(safeCurrent);
    }
    if (ensureCurrent && documentPages.length) {
        const safeCurrent = Math.max(0, Math.min(documentPages.length - 1, currentPageIndex));
        next.add(safeCurrent);
    }
    selectedCanvasIndexes = next;

    if (documentPages.length) {
        const safeCurrent = Math.max(0, Math.min(documentPages.length - 1, currentPageIndex));
        if (!Number.isInteger(canvasSelectionAnchorIndex)
            || canvasSelectionAnchorIndex < 0
            || canvasSelectionAnchorIndex >= documentPages.length) {
            canvasSelectionAnchorIndex = safeCurrent;
        }
    } else {
        canvasSelectionAnchorIndex = 0;
    }
}

function setCanvasPageSelection(indexes = [], { ensureCurrent = true } = {}) {
    const list = Array.isArray(indexes) ? indexes : [indexes];
    selectedCanvasIndexes = new Set(
        list
            .map(v => parseInt(v, 10))
            .filter(idx => Number.isInteger(idx) && idx >= 0 && idx < documentPages.length)
    );
    normalizeCanvasPageSelections({ ensureCurrent });
}

function getSelectedCanvasPageIndexes({ ensureCurrent = true } = {}) {
    normalizeCanvasPageSelections({ ensureCurrent });
    return Array.from(selectedCanvasIndexes).sort((a, b) => a - b);
}

function shiftCanvasPageSelectionForInsert(insertAt) {
    const safeInsertAt = Math.max(0, parseInt(insertAt, 10) || 0);
    const shifted = new Set();
    selectedCanvasIndexes.forEach(idx => shifted.add(idx >= safeInsertAt ? idx + 1 : idx));
    selectedCanvasIndexes = shifted;
    if (canvasSelectionAnchorIndex >= safeInsertAt) canvasSelectionAnchorIndex += 1;
    normalizeCanvasPageSelections({ ensureCurrent: true });
}

function shiftCanvasPageSelectionForDelete(deleteAt) {
    const safeDeleteAt = Math.max(0, parseInt(deleteAt, 10) || 0);
    const shifted = new Set();
    selectedCanvasIndexes.forEach(idx => {
        if (idx === safeDeleteAt) return;
        shifted.add(idx > safeDeleteAt ? idx - 1 : idx);
    });
    selectedCanvasIndexes = shifted;
    if (canvasSelectionAnchorIndex === safeDeleteAt) canvasSelectionAnchorIndex = Math.max(0, safeDeleteAt - 1);
    else if (canvasSelectionAnchorIndex > safeDeleteAt) canvasSelectionAnchorIndex -= 1;
    normalizeCanvasPageSelections({ ensureCurrent: true });
}

function remapCanvasPageIndexForMove(index, fromIndex, toIndex) {
    const idx = parseInt(index, 10);
    const from = parseInt(fromIndex, 10);
    const to = parseInt(toIndex, 10);
    if (!Number.isInteger(idx) || !Number.isInteger(from) || !Number.isInteger(to)) return idx;
    if (idx === from) return to;
    if (from < to) {
        if (idx > from && idx <= to) return idx - 1;
        return idx;
    }
    if (from > to) {
        if (idx >= to && idx < from) return idx + 1;
        return idx;
    }
    return idx;
}

function createPageRectPayload(width = DEFAULT_PAGE_WIDTH, height = DEFAULT_PAGE_HEIGHT) {
    return {
        type: 'rect',
        version: '5.3.0',
        originX: 'left',
        originY: 'top',
        left: 0,
        top: 0,
        width,
        height,
        fill: '#ffffff',
        stroke: 'rgba(0,0,0,0.25)',
        strokeWidth: 1,
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockScalingX: true,
        lockScalingY: true,
        lockRotation: true,
        oid: 'pageRect',
        isArtboard: true
    };
}

function createBlankPageState(index = 0, width = DEFAULT_PAGE_WIDTH, height = DEFAULT_PAGE_HEIGHT) {
    return {
        id: createUid('page'),
        title: `Page ${index + 1}`,
        width,
        height,
        canvas: {
            version: '5.3.0',
            background: 'transparent',
            objects: [createPageRectPayload(width, height)]
        },
        bindings: []
    };
}

const VALID_ORIGIN_X = new Set(['left', 'center', 'right']);
const VALID_ORIGIN_Y = new Set(['top', 'center', 'bottom']);
const VALID_TEXT_BASELINES = new Set(['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom']);
const VALID_TEXT_ALIGNS = new Set(['left', 'center', 'right', 'justify']);
const TEXT_CURVE_MIN = -100;
const TEXT_CURVE_MAX = 100;
const TEXT_CURVE_EPSILON = 0.001;
const TEXT_CURVE_MIN_SPAN_RAD = Math.PI / 36;

function normalizeNumeric(value, fallback) {
    const n = parseFloat(value);
    return Number.isFinite(n) ? n : fallback;
}

function clampTextCurveAmount(value) {
    const parsed = parseFloat(value);
    if (!Number.isFinite(parsed)) return 0;
    return Math.max(TEXT_CURVE_MIN, Math.min(TEXT_CURVE_MAX, parsed));
}

function toSingleLineCurveText(value) {
    return String(value ?? '').replace(/\r?\n+/g, ' ');
}

function measureTextboxSingleLineWidth(textbox, value) {
    if (!textbox || textbox.type !== 'textbox') return 0;
    const text = toSingleLineCurveText(value ?? textbox.text);
    if (!text) return 0;

    try {
        const probe = new fabric.Text(text, {
            fontFamily: textbox.fontFamily,
            fontSize: textbox.fontSize,
            fontWeight: textbox.fontWeight,
            fontStyle: textbox.fontStyle,
            charSpacing: textbox.charSpacing,
            stroke: textbox.stroke,
            strokeWidth: textbox.strokeWidth
        });
        const measured = parseFloat(probe.width);
        if (Number.isFinite(measured) && measured > 0) return measured;
    } catch (_) { }

    return 0;
}

function getTextboxCurveTextLength(textbox, value = null) {
    if (!textbox || textbox.type !== 'textbox') return 0;
    const measuredSingleLine = measureTextboxSingleLineWidth(textbox, value);
    if (measuredSingleLine > 0) return measuredSingleLine;

    if (typeof textbox.calcTextWidth === 'function') {
        const measured = parseFloat(textbox.calcTextWidth());
        if (Number.isFinite(measured) && measured > 0) return measured;
    }

    const lines = Array.isArray(textbox.textLines) ? textbox.textLines : [];
    if (lines.length && typeof textbox.getLineWidth === 'function') {
        const widths = lines
            .map((_, index) => parseFloat(textbox.getLineWidth(index)))
            .filter(width => Number.isFinite(width) && width > 0);
        if (widths.length) return Math.max(...widths);
    }

    const text = String(textbox.text || '');
    const fontSize = Math.max(8, parseFloat(textbox.fontSize) || 24);
    return Math.max(fontSize, text.length * fontSize * 0.58);
}

function buildTextboxCurvePathData(radius, curveAmount) {
    const amount = clampTextCurveAmount(curveAmount);
    const absAmount = Math.abs(amount);
    const sweepFlag = amount >= 0 ? 1 : 0;
    const span = Math.max(
        TEXT_CURVE_MIN_SPAN_RAD,
        Math.min(Math.PI * 2, (absAmount / TEXT_CURVE_MAX) * Math.PI * 2)
    );

    if (span >= (Math.PI * 2 - 0.0001)) {
        return `M 0 ${-radius} A ${radius} ${radius} 0 1 ${sweepFlag} 0 ${radius} A ${radius} ${radius} 0 1 ${sweepFlag} 0 ${-radius}`;
    }

    const midpoint = amount >= 0 ? -Math.PI / 2 : Math.PI / 2;
    const isNegativeCurve = amount < 0;
    const startAngle = isNegativeCurve ? (midpoint + span / 2) : (midpoint - span / 2);
    const endAngle = isNegativeCurve ? (midpoint - span / 2) : (midpoint + span / 2);
    const startX = radius * Math.cos(startAngle);
    const startY = radius * Math.sin(startAngle);
    const endX = radius * Math.cos(endAngle);
    const endY = radius * Math.sin(endAngle);
    const largeArcFlag = span > Math.PI ? 1 : 0;
    return `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
}

function clearTextboxCurvePath(textbox, { skipRender = false } = {}) {
    if (!textbox || textbox.type !== 'textbox') return false;
    const hadPath = !!textbox.path;
    textbox.set({
        path: null,
        pathAlign: 'baseline',
        pathSide: 'left',
        pathStartOffset: 0
    });
    if (typeof textbox.initDimensions === 'function') textbox.initDimensions();
    if (typeof textbox.setCoords === 'function') textbox.setCoords();
    if (!skipRender) (textbox.canvas || canvas)?.requestRenderAll();
    return hadPath;
}

function setTextboxCurve(textbox, curveAmount, { skipRender = false } = {}) {
    if (!textbox || textbox.type !== 'textbox') return false;
    const nextAmount = clampTextCurveAmount(curveAmount);
    textbox.curveAmount = nextAmount;

    const singleLineText = toSingleLineCurveText(textbox.text);
    if (singleLineText !== String(textbox.text || '')) {
        textbox.set({ text: singleLineText });
    }

    const content = String(textbox.text || '').trim();
    if (!content || Math.abs(nextAmount) <= TEXT_CURVE_EPSILON) {
        return clearTextboxCurvePath(textbox, { skipRender });
    }

    const singleLineWidth = measureTextboxSingleLineWidth(textbox, textbox.text);
    if (singleLineWidth > 0) {
        const minNoWrapWidth = Math.max(24, Math.ceil(singleLineWidth + 2));
        if (!Number.isFinite(parseFloat(textbox.width)) || parseFloat(textbox.width) < minNoWrapWidth) {
            textbox.set({ width: minNoWrapWidth });
        }
    }

    const span = Math.max(
        TEXT_CURVE_MIN_SPAN_RAD,
        Math.min(Math.PI * 2, (Math.abs(nextAmount) / TEXT_CURVE_MAX) * Math.PI * 2)
    );
    const textLength = Math.max(10, getTextboxCurveTextLength(textbox, textbox.text));
    const fontSize = Math.max(8, parseFloat(textbox.fontSize) || 24);
    const radius = Math.max(fontSize * 0.9, textLength / span);
    const curvePath = new fabric.Path(buildTextboxCurvePathData(radius, nextAmount), {
        left: 0,
        top: 0,
        originX: 'center',
        originY: 'center',
        visible: false,
        evented: false,
        selectable: false,
        fill: null,
        stroke: null
    });

    textbox.set({
        path: curvePath,
        pathAlign: 'center',
        pathSide: 'left',
        pathStartOffset: 0
    });
    if (typeof textbox.initDimensions === 'function') textbox.initDimensions();
    if (typeof textbox.setCoords === 'function') textbox.setCoords();
    if (!skipRender) (textbox.canvas || canvas)?.requestRenderAll();
    return true;
}

function refreshTextboxCurve(textbox, options = {}) {
    if (!textbox || textbox.type !== 'textbox') return false;
    const current = clampTextCurveAmount(textbox.curveAmount);
    textbox.curveAmount = current;
    return setTextboxCurve(textbox, current, options);
}

function isValidTextboxPathObject(path) {
    return !!path
        && typeof path.toObject === 'function'
        && typeof path.isNotVisible === 'function';
}

function normalizeTextboxCurvePathObject(textbox, { skipRender = true } = {}) {
    if (!textbox || textbox.type !== 'textbox') return false;
    const curveAmount = clampTextCurveAmount(textbox.curveAmount);
    textbox.curveAmount = curveAmount;

    const hasCurve = Math.abs(curveAmount) > TEXT_CURVE_EPSILON;
    const hasPath = !!textbox.path;
    const hasValidPathObject = hasPath && isValidTextboxPathObject(textbox.path);
    const needsCurveRefresh = hasCurve && !hasValidPathObject;
    const needsPathClear = !hasCurve && hasPath;
    if (!needsCurveRefresh && !needsPathClear) return false;

    try {
        if (needsCurveRefresh) return refreshTextboxCurve(textbox, { skipRender });
        return clearTextboxCurvePath(textbox, { skipRender });
    } catch (error) {
        console.warn('Failed to normalize textbox curve path:', error);
        textbox.set({
            path: null,
            pathAlign: 'baseline',
            pathSide: 'left',
            pathStartOffset: 0
        });
        if (typeof textbox.initDimensions === 'function') textbox.initDimensions();
        if (typeof textbox.setCoords === 'function') textbox.setCoords();
        if (!skipRender) (textbox.canvas || canvas)?.requestRenderAll();
        return true;
    }
}

function normalizeTextboxPathsForSerialization(rootObject = null) {
    const initial = rootObject
        ? [rootObject]
        : (typeof canvas?.getObjects === 'function' ? canvas.getObjects() : []);
    if (!initial.length) return false;

    const stack = [...initial];
    const visited = new Set();
    let changed = false;
    while (stack.length) {
        const obj = stack.pop();
        if (!obj || visited.has(obj)) continue;
        visited.add(obj);

        if (obj.type === 'textbox' && normalizeTextboxCurvePathObject(obj, { skipRender: true })) {
            changed = true;
        }

        if (typeof obj.getObjects === 'function') {
            const children = obj.getObjects();
            if (Array.isArray(children) && children.length) {
                children.forEach(child => stack.push(child));
            }
        }
    }

    return changed;
}

function repairLiveCanvasTextObjectsForSerialization(rootObject = null) {
    const initial = rootObject
        ? [rootObject]
        : (typeof canvas?.getObjects === 'function' ? canvas.getObjects() : []);
    if (!initial.length) return false;

    const stack = [...initial];
    const visited = new Set();
    let changed = false;

    while (stack.length) {
        const obj = stack.pop();
        if (!obj || visited.has(obj)) continue;
        visited.add(obj);

        const isTextLike = obj.type === 'textbox' || obj.type === 'text' || obj.type === 'i-text';
        if (isTextLike) {
            const patch = {};
            if (typeof obj.text !== 'string') patch.text = String(obj.text ?? '');
            const currentFontSize = normalizeNumeric(obj.fontSize, 24);
            if (!Number.isFinite(currentFontSize) || currentFontSize <= 0) patch.fontSize = 24;
            const currentWidth = normalizeNumeric(obj.width, 240);
            if (!Number.isFinite(currentWidth) || currentWidth <= 0) patch.width = 240;
            if (!Array.isArray(obj.styles)) patch.styles = [];
            const baseline = typeof obj.textBaseline === 'string'
                ? obj.textBaseline.toLowerCase()
                : 'alphabetic';
            if (obj.textBaseline != null && !VALID_TEXT_BASELINES.has(baseline)) {
                patch.textBaseline = 'alphabetic';
            }
            const sx = normalizeNumeric(obj.scaleX, 1) || 1;
            const sy = normalizeNumeric(obj.scaleY, 1) || 1;
            if (Math.abs(sx - 1) > 0.001 || Math.abs(sy - 1) > 0.001) {
                patch.width = Math.max(120, normalizeNumeric(obj.width, 240) * Math.abs(sx));
                patch.fontSize = Math.max(8, normalizeNumeric(obj.fontSize, 24) * Math.abs(sy));
                patch.scaleX = 1;
                patch.scaleY = 1;
            }
            if (Object.keys(patch).length) {
                obj.set(patch);
                if (typeof obj.initDimensions === 'function') obj.initDimensions();
                if (typeof obj.setCoords === 'function') obj.setCoords();
                changed = true;
            }
        }

        if (typeof obj.getObjects === 'function') {
            const children = obj.getObjects();
            if (Array.isArray(children) && children.length) {
                children.forEach(child => stack.push(child));
            }
        }
    }

    return changed;
}

function sanitizeCanvasObject(rawObject, { pageWidth = DEFAULT_PAGE_WIDTH, pageHeight = DEFAULT_PAGE_HEIGHT, depth = 0 } = {}) {
    if (!rawObject || typeof rawObject !== 'object') return null;
    const obj = { ...rawObject };

    if (!VALID_ORIGIN_X.has(obj.originX)) obj.originX = 'left';
    if (!VALID_ORIGIN_Y.has(obj.originY)) obj.originY = 'top';
    obj.left = normalizeNumeric(obj.left, pageWidth / 2);
    obj.top = normalizeNumeric(obj.top, pageHeight / 2);
    obj.scaleX = normalizeNumeric(obj.scaleX, 1) || 1;
    obj.scaleY = normalizeNumeric(obj.scaleY, 1) || 1;
    obj.angle = normalizeNumeric(obj.angle, 0);

    if (Array.isArray(obj.objects)) {
        obj.objects = obj.objects
            .map(child => sanitizeCanvasObject(child, { pageWidth, pageHeight, depth: depth + 1 }))
            .filter(Boolean);
    }

    if (obj.oid === 'pageRect' || obj.isArtboard) {
        obj.oid = 'pageRect';
        obj.isArtboard = true;
        obj.originX = 'left';
        obj.originY = 'top';
        obj.left = 0;
        obj.top = 0;
        obj.width = parsePositiveInt(Math.round(normalizeNumeric(obj.width, pageWidth)), pageWidth);
        obj.height = parsePositiveInt(Math.round(normalizeNumeric(obj.height, pageHeight)), pageHeight);
        obj.selectable = false;
        obj.evented = false;
        obj.hasControls = false;
        obj.hasBorders = false;
        obj.lockMovementX = true;
        obj.lockMovementY = true;
        obj.lockScalingX = true;
        obj.lockScalingY = true;
        obj.lockRotation = true;
    } else {
        if (depth === 0) {
            const isLocked = !!obj.locked;
            obj.locked = isLocked;
            obj.selectable = !isLocked;
            obj.evented = !isLocked;
            obj.hasControls = !isLocked;
            obj.hasBorders = !isLocked;
            obj.lockMovementX = isLocked;
            obj.lockMovementY = isLocked;
            obj.lockScalingX = isLocked;
            obj.lockScalingY = isLocked;
            obj.lockRotation = isLocked;
        }
    }

    // Prevent accidental clipping/teleporting from AI-generated transforms.
    if (obj.clipPath) delete obj.clipPath;
    if (obj.transformMatrix) delete obj.transformMatrix;

    const isTextLike = obj.type === 'textbox' || obj.type === 'text' || obj.type === 'i-text';
    if (isTextLike) {
        obj.type = 'textbox';
        if (typeof obj.text !== 'string') obj.text = String(obj.text ?? '');
        if (!Number.isFinite(parseFloat(obj.fontSize)) || parseFloat(obj.fontSize) <= 0) obj.fontSize = 24;
        if (!obj.fontFamily || typeof obj.fontFamily !== 'string') obj.fontFamily = 'Arial';
        const align = String(obj.textAlign || 'left').toLowerCase();
        obj.textAlign = VALID_TEXT_ALIGNS.has(align) ? align : 'left';
        if (!Number.isFinite(parseFloat(obj.lineHeight)) || parseFloat(obj.lineHeight) <= 0) obj.lineHeight = 1.16;
        if (!Number.isFinite(parseFloat(obj.charSpacing))) obj.charSpacing = 0;
        obj.splitByGrapheme = !!obj.splitByGrapheme;
        if (obj.minWidth == null || !Number.isFinite(parseFloat(obj.minWidth)) || parseFloat(obj.minWidth) < 20) {
            obj.minWidth = 20;
        }
        if (!Array.isArray(obj.styles)) obj.styles = [];

        if (typeof obj.textBaseline === 'string') {
            const baseline = obj.textBaseline.toLowerCase();
            obj.textBaseline = VALID_TEXT_BASELINES.has(baseline) ? baseline : 'alphabetic';
        } else if (obj.textBaseline != null) {
            obj.textBaseline = 'alphabetic';
        }

        const sx = Math.abs(normalizeNumeric(obj.scaleX, 1) || 1);
        const sy = Math.abs(normalizeNumeric(obj.scaleY, 1) || 1);
        const baseWidth = Math.max(120, normalizeNumeric(obj.width, 260));
        const normalizedWidth = Math.min(pageWidth * 0.95, Math.max(120, baseWidth * sx));
        const normalizedFontSize = Math.max(8, normalizeNumeric(obj.fontSize, 24) * sy);
        obj.width = normalizedWidth;
        obj.fontSize = normalizedFontSize;
        obj.scaleX = 1;
        obj.scaleY = 1;

        obj.curveAmount = clampTextCurveAmount(obj.curveAmount);
        if (obj.path) delete obj.path;
        obj.padding = 0;
        if (obj.lockUniScaling == null) obj.lockUniScaling = true;
    }

    if (obj.type === 'path' || obj.isSvgGroup || obj.type === 'group') {
        obj.objectCaching = false;
    }

    return obj;
}

function sanitizeCanvasStateForEditor(rawCanvas, { pageWidth = DEFAULT_PAGE_WIDTH, pageHeight = DEFAULT_PAGE_HEIGHT } = {}) {
    const canvasState = (rawCanvas && typeof rawCanvas === 'object') ? { ...rawCanvas } : { version: '5.3.0', background: 'transparent', objects: [] };
    if (!Array.isArray(canvasState.objects)) canvasState.objects = [];
    canvasState.version = canvasState.version || '5.3.0';
    canvasState.background = 'transparent';

    const sanitizedObjects = canvasState.objects
        .map(obj => sanitizeCanvasObject(obj, { pageWidth, pageHeight }))
        .filter(Boolean);

    let pageRectObj = sanitizedObjects.find(obj => obj.oid === 'pageRect');
    if (!pageRectObj) {
        pageRectObj = createPageRectPayload(pageWidth, pageHeight);
    } else {
        pageRectObj.width = pageWidth;
        pageRectObj.height = pageHeight;
        pageRectObj.left = 0;
        pageRectObj.top = 0;
        pageRectObj.originX = 'left';
        pageRectObj.originY = 'top';
        pageRectObj.selectable = false;
        pageRectObj.evented = false;
        pageRectObj.hasControls = false;
        pageRectObj.hasBorders = false;
        pageRectObj.lockMovementX = true;
        pageRectObj.lockMovementY = true;
        pageRectObj.lockScalingX = true;
        pageRectObj.lockScalingY = true;
        pageRectObj.lockRotation = true;
        pageRectObj.isArtboard = true;
        pageRectObj.oid = 'pageRect';
    }

    canvasState.objects = [pageRectObj, ...sanitizedObjects.filter(obj => obj.oid !== 'pageRect')];
    return canvasState;
}

function sanitizeBindingsEntries(rawBindings) {
    if (!Array.isArray(rawBindings)) return [];
    return rawBindings
        .filter(entry => Array.isArray(entry) && entry.length === 2)
        .map(([oid, bindingList]) => {
            const safeOid = String(oid || '').trim();
            if (!safeOid) return null;
            const safeBindings = Array.isArray(bindingList)
                ? bindingList
                    .filter(b => b && typeof b === 'object')
                    .map(b => {
                        const property = String(b.property || '').trim();
                        const column = String(b.column || '').trim();
                        if (!property) return null;
                        const next = { ...b, property, column };
                        if (property === 'Cell Text') {
                            next.cellIndex = Number.isFinite(parseInt(next.cellIndex, 10)) ? parseInt(next.cellIndex, 10) : 0;
                        } else {
                            delete next.cellIndex;
                        }
                        return next;
                    })
                    .filter(Boolean)
                : [];
            return [safeOid, safeBindings];
        })
        .filter(Boolean);
}

function lineEndpointPositionHandler(dim, finalMatrix, fabricObject, currentControl) {
    if (!fabricObject || fabricObject.type !== 'line') return new fabric.Point(0, 0);
    const pointKey = currentControl?.pointKey || this?.pointKey || 'end';
    const canvasPoint = getLineCanvasPoint(fabricObject, pointKey);
    if (!canvasPoint) return new fabric.Point(0, 0);
    return fabric.util.transformPoint(
        canvasPoint,
        fabricObject.canvas?.viewportTransform || [1, 0, 0, 1, 0, 0]
    );
}

function getLineLocalPoint(line, pointKey) {
    if (!line || line.type !== 'line') return null;
    if (typeof line.calcLinePoints === 'function') {
        const points = line.calcLinePoints();
        if (
            points &&
            Number.isFinite(points.x1) &&
            Number.isFinite(points.y1) &&
            Number.isFinite(points.x2) &&
            Number.isFinite(points.y2)
        ) {
            return pointKey === 'start'
                ? new fabric.Point(points.x1, points.y1)
                : new fabric.Point(points.x2, points.y2);
        }
    }

    const x1 = Number.isFinite(line.x1) ? line.x1 : 0;
    const y1 = Number.isFinite(line.y1) ? line.y1 : 0;
    const x2 = Number.isFinite(line.x2) ? line.x2 : x1;
    const y2 = Number.isFinite(line.y2) ? line.y2 : y1;
    const pathOffset = line.pathOffset || { x: 0, y: 0 };
    const offsetX = Number.isFinite(pathOffset.x) ? pathOffset.x : 0;
    const offsetY = Number.isFinite(pathOffset.y) ? pathOffset.y : 0;
    return pointKey === 'start'
        ? new fabric.Point(x1 - offsetX, y1 - offsetY)
        : new fabric.Point(x2 - offsetX, y2 - offsetY);
}

function getLineCanvasPoint(line, pointKey) {
    if (!line || line.type !== 'line') return null;
    const localPoint = getLineLocalPoint(line, pointKey);
    if (!localPoint) return null;
    const matrix = line.calcTransformMatrix();
    return fabric.util.transformPoint(localPoint, matrix);
}

function normalizeLineFromCanvasEndpoints(line, startPoint, endPoint) {
    if (!line || line.type !== 'line') return false;
    if (!startPoint || !endPoint) return false;
    if (!Number.isFinite(startPoint.x) || !Number.isFinite(startPoint.y) || !Number.isFinite(endPoint.x) || !Number.isFinite(endPoint.y)) return false;

    const left = Math.min(startPoint.x, endPoint.x);
    const top = Math.min(startPoint.y, endPoint.y);
    const x1 = startPoint.x;
    const y1 = startPoint.y;
    const x2 = endPoint.x;
    const y2 = endPoint.y;

    line.set({
        originX: 'center',
        originY: 'center',
        angle: 0,
        scaleX: 1,
        scaleY: 1,
        x1,
        y1,
        x2,
        y2
    });

    if (typeof line._setWidthHeight === 'function') line._setWidthHeight();
    line.setCoords();
    return true;
}

function snapLineEndpoint(anchorPoint, pointerPoint, enableSnap = false) {
    if (!enableSnap) return pointerPoint;
    if (!anchorPoint || !pointerPoint) return pointerPoint;

    const dx = pointerPoint.x - anchorPoint.x;
    const dy = pointerPoint.y - anchorPoint.y;
    if (!Number.isFinite(dx) || !Number.isFinite(dy)) return pointerPoint;
    if (Math.abs(dx) < 1e-6 && Math.abs(dy) < 1e-6) return pointerPoint;

    const candidates = [
        { x: dx, y: 0 },      // horizontal
        { x: 0, y: dy }       // vertical
    ];

    // slope +1 diagonal
    const t1 = (dx + dy) / 2;
    candidates.push({ x: t1, y: t1 });

    // slope -1 diagonal
    const t2 = (dx - dy) / 2;
    candidates.push({ x: t2, y: -t2 });

    let best = candidates[0];
    let bestDist = Infinity;
    for (const c of candidates) {
        const dist = (c.x - dx) * (c.x - dx) + (c.y - dy) * (c.y - dy);
        if (dist < bestDist) {
            bestDist = dist;
            best = c;
        }
    }

    return new fabric.Point(anchorPoint.x + best.x, anchorPoint.y + best.y);
}

function lineEndpointActionHandler(eventData, transform, x, y) {
    const line = transform?.target;
    if (!line || line.type !== 'line') return false;

    const canvas = line.canvas;
    if (!canvas) return false;

    const control = line.controls?.[transform.corner];
    const pointKey = control?.pointKey === 'start' ? 'start' : 'end';
    const anchorKey = pointKey === 'start' ? 'end' : 'start';
    const anchorPoint = getLineCanvasPoint(line, anchorKey);
    if (!anchorPoint) return false;

    let pointerPoint = null;
    if (Number.isFinite(x) && Number.isFinite(y)) {
        pointerPoint = new fabric.Point(x, y);
    } else {
        const pointer = canvas.getPointer(eventData);
        pointerPoint = new fabric.Point(pointer.x, pointer.y);
    }
    if (!Number.isFinite(pointerPoint.x) || !Number.isFinite(pointerPoint.y)) return false;
    pointerPoint = snapLineEndpoint(anchorPoint, pointerPoint, !!eventData?.shiftKey);

    const startPoint = pointKey === 'start' ? pointerPoint : anchorPoint;
    const endPoint = pointKey === 'start' ? anchorPoint : pointerPoint;
    normalizeLineFromCanvasEndpoints(line, startPoint, endPoint);
    line._endpointDragDirty = true;
    if (typeof requestSaveState === 'function') requestSaveState();
    line.setCoords();
    canvas.requestRenderAll();
    return true;
}

const LINE_ENDPOINT_CONTROLS = {
    start: new fabric.Control({
        pointKey: 'start',
        positionHandler: lineEndpointPositionHandler,
        actionHandler: lineEndpointActionHandler,
        actionName: 'modifyLineEndpoint',
        cursorStyle: 'crosshair'
    }),
    end: new fabric.Control({
        pointKey: 'end',
        positionHandler: lineEndpointPositionHandler,
        actionHandler: lineEndpointActionHandler,
        actionName: 'modifyLineEndpoint',
        cursorStyle: 'crosshair'
    })
};

function applyLineEndpointControls(line) {
    if (!line || line.type !== 'line' || line.excludeFromExport || line.isSnapLine) return;
    let startPoint = getLineCanvasPoint(line, 'start');
    let endPoint = getLineCanvasPoint(line, 'end');
    if (!startPoint || !endPoint) {
        const center = (typeof line.getCenterPoint === 'function')
            ? line.getCenterPoint()
            : new fabric.Point(
                Number.isFinite(line.left) ? line.left : 0,
                Number.isFinite(line.top) ? line.top : 0
            );
        startPoint = new fabric.Point(center.x - 75, center.y);
        endPoint = new fabric.Point(center.x + 75, center.y);
    }
    if (Math.abs(startPoint.x - endPoint.x) < 0.0001 && Math.abs(startPoint.y - endPoint.y) < 0.0001) {
        endPoint = new fabric.Point(startPoint.x + 150, startPoint.y);
    }
    normalizeLineFromCanvasEndpoints(line, startPoint, endPoint);

    line.controls = LINE_ENDPOINT_CONTROLS;
    line.set({
        hasBorders: false,
        padding: 0,
        objectCaching: false,
        perPixelTargetFind: true
    });
    line.setCoords();
}

function applyLockStateToObject(obj) {
    if (!obj || obj.oid === 'pageRect' || obj.isArtboard) return;
    const isLocked = !!obj.locked;
    const isEditableLine = obj.type === 'line' && !obj.excludeFromExport && !obj.isSnapLine;
    obj.set({
        selectable: !isLocked,
        evented: !isLocked,
        hasControls: !isLocked,
        hasBorders: isEditableLine ? false : !isLocked,
        lockMovementX: isLocked,
        lockMovementY: isLocked,
        lockScalingX: isLocked,
        lockScalingY: isLocked,
        lockRotation: isLocked
    });
    if (isEditableLine && !isLocked) applyLineEndpointControls(obj);
}

function stabilizeObjectAfterLoad(obj) {
    if (!obj || obj.oid === 'pageRect' || obj.isArtboard) return;

    if (!Number.isFinite(obj.left) || !Number.isFinite(obj.top)) {
        const fallback = pageRect ? pageRect.getCenterPoint() : new fabric.Point(DEFAULT_PAGE_WIDTH / 2, DEFAULT_PAGE_HEIGHT / 2);
        obj.set({
            left: Number.isFinite(obj.left) ? obj.left : fallback.x,
            top: Number.isFinite(obj.top) ? obj.top : fallback.y
        });
    }
    if (!Number.isFinite(obj.scaleX) || obj.scaleX === 0) obj.scaleX = 1;
    if (!Number.isFinite(obj.scaleY) || obj.scaleY === 0) obj.scaleY = 1;

    if (obj.type === 'path') {
        obj.set({ objectCaching: false });
    }
    if (obj.type === 'line' && !obj.excludeFromExport && !obj.isSnapLine) {
        applyLineEndpointControls(obj);
    }
    if (obj.type === 'textbox') {
        obj.set({ padding: 0 });
        refreshTextboxCurve(obj, { skipRender: true });
    }

    if (obj.type === 'group' && !obj.isTable) {
        const center = obj.getCenterPoint();
        if (typeof obj.addWithUpdate === 'function') obj.addWithUpdate();
        obj.setPositionByOrigin(center, 'center', 'center');
        obj.set({ objectCaching: false });
    }

    if (obj.isSvgGroup && typeof obj.forEachObject === 'function') {
        obj.set({ objectCaching: false });
        obj.forEachObject(child => {
            if (!child) return;
            child.set({ objectCaching: false });
        });
    }

    applyLockStateToObject(obj);
    obj.setCoords();
}

function ensurePageRectInCanvasState(pageState) {
    if (!pageState.canvas || typeof pageState.canvas !== 'object') {
        pageState.canvas = { version: '5.3.0', background: 'transparent', objects: [] };
    }
    if (!Array.isArray(pageState.canvas.objects)) pageState.canvas.objects = [];
    let pr = pageState.canvas.objects.find(o => o && o.oid === 'pageRect');
    if (!pr) {
        pr = createPageRectPayload(pageState.width, pageState.height);
        pageState.canvas.objects.unshift(pr);
    } else {
        pr.width = pageState.width;
        pr.height = pageState.height;
        pr.oid = 'pageRect';
        pr.isArtboard = true;
        pr.selectable = false;
        pr.evented = false;
        pr.hasControls = false;
        pr.hasBorders = false;
        pr.lockMovementX = true;
        pr.lockMovementY = true;
        pr.lockScalingX = true;
        pr.lockScalingY = true;
        pr.lockRotation = true;
        if (pr.stroke == null) pr.stroke = 'rgba(0,0,0,0.25)';
        if (pr.strokeWidth == null) pr.strokeWidth = 1;
    }
    pageState.canvas = sanitizeCanvasStateForEditor(pageState.canvas, {
        pageWidth: pageState.width,
        pageHeight: pageState.height
    });
}

function assignPageIdToCanvasObjects(pageState) {
    if (!pageState || !pageState.id || !pageState.canvas || !Array.isArray(pageState.canvas.objects)) return;
    const pageId = pageState.id;
    const visit = (obj) => {
        if (!obj || typeof obj !== 'object') return;
        if (obj.oid !== 'pageRect' && !obj.isArtboard) obj.pageId = pageId;
        if (Array.isArray(obj.objects)) obj.objects.forEach(visit);
    };
    pageState.canvas.objects.forEach(visit);
}

function ensureDocumentPagesIntegrity() {
    if (!Array.isArray(documentPages) || !documentPages.length) {
        documentPages = [createBlankPageState(0, generalPageSize.width, generalPageSize.height)];
        currentPageIndex = 0;
        setCanvasPageSelection([0], { ensureCurrent: false });
        canvasSelectionAnchorIndex = 0;
        return;
    }

    documentPages = documentPages.map((page, index) => {
        if (!page || typeof page !== 'object') {
            return createBlankPageState(index, generalPageSize.width, generalPageSize.height);
        }
        page.id = page.id || createUid('page');
        page.width = parsePositiveInt(page.width, DEFAULT_PAGE_WIDTH);
        page.height = parsePositiveInt(page.height, DEFAULT_PAGE_HEIGHT);
        ensurePageRectInCanvasState(page);
        assignPageIdToCanvasObjects(page);
        return page;
    });

    currentPageIndex = Math.max(0, Math.min(documentPages.length - 1, parseInt(currentPageIndex, 10) || 0));
    normalizeCanvasPageSelections({ ensureCurrent: true });
}

function normalizePageState(rawPage = {}, index = 0) {
    const width = parsePositiveInt(rawPage.width ?? rawPage.page?.width, DEFAULT_PAGE_WIDTH);
    const height = parsePositiveInt(rawPage.height ?? rawPage.page?.height, DEFAULT_PAGE_HEIGHT);
    const pageState = {
        id: rawPage.id || createUid('page'),
        title: rawPage.title || `Page ${index + 1}`,
        width,
        height,
        canvas: sanitizeCanvasStateForEditor(rawPage.canvas || { version: '5.3.0', background: 'transparent', objects: [] }, { pageWidth: width, pageHeight: height }),
        bindings: sanitizeBindingsEntries(rawPage.bindings)
    };
    ensurePageRectInCanvasState(pageState);
    assignPageIdToCanvasObjects(pageState);
    return pageState;
}

function normalizeTemplatePages(templateData = {}) {
    if (Array.isArray(templateData.pages) && templateData.pages.length > 0) {
        const rootBindings = Array.isArray(templateData.bindings) ? templateData.bindings : [];
        const pages = templateData.pages.map((p, i) => normalizePageState({
            ...p,
            bindings: Array.isArray(p?.bindings) ? p.bindings : (i === 0 ? rootBindings : [])
        }, i));
        const selectedIndex = Math.min(
            pages.length - 1,
            Math.max(0, parseInt(templateData.currentPageIndex, 10) || 0)
        );
        return { pages, selectedIndex };
    }

    const width = parsePositiveInt(templateData.page?.width, DEFAULT_PAGE_WIDTH);
    const height = parsePositiveInt(templateData.page?.height, DEFAULT_PAGE_HEIGHT);
    const page = normalizePageState({
        id: createUid('page'),
        title: templateData.page?.title || 'Page 1',
        width,
        height,
        canvas: templateData.canvas,
        bindings: templateData.bindings
    }, 0);
    return { pages: [page], selectedIndex: 0 };
}

function getMostCommonPageSize() {
    if (!Array.isArray(documentPages) || documentPages.length === 0) {
        return { width: DEFAULT_PAGE_WIDTH, height: DEFAULT_PAGE_HEIGHT };
    }

    const counts = new Map();
    documentPages.forEach(page => {
        const w = parsePositiveInt(page?.width, DEFAULT_PAGE_WIDTH);
        const h = parsePositiveInt(page?.height, DEFAULT_PAGE_HEIGHT);
        const key = `${w}x${h}`;
        counts.set(key, (counts.get(key) || 0) + 1);
    });

    let bestKey = `${DEFAULT_PAGE_WIDTH}x${DEFAULT_PAGE_HEIGHT}`;
    let bestCount = -1;
    counts.forEach((count, key) => {
        if (count > bestCount) {
            bestCount = count;
            bestKey = key;
        }
    });

    const [w, h] = bestKey.split('x').map(v => parseInt(v, 10));
    return {
        width: parsePositiveInt(w, DEFAULT_PAGE_WIDTH),
        height: parsePositiveInt(h, DEFAULT_PAGE_HEIGHT)
    };
}

function syncGeneralPageSizeInputs() {
    const widthInput = $('#pageWidth');
    const heightInput = $('#pageHeight');
    if (widthInput && document.activeElement !== widthInput) {
        widthInput.value = generalPageSize.width;
    }
    if (heightInput && document.activeElement !== heightInput) {
        heightInput.value = generalPageSize.height;
    }
}

function applyCanvasPagesPanelState() {
    if (!canvasPagesPanel || !toggleCanvasPagesPanelBtn) return;
    canvasPagesPanel.classList.toggle('collapsed', isCanvasPagesPanelCollapsed);
    const stateLabel = toggleCanvasPagesPanelBtn.querySelector('.state');
    if (stateLabel) stateLabel.textContent = isCanvasPagesPanelCollapsed ? 'Show' : '';
    toggleCanvasPagesPanelBtn.setAttribute('aria-expanded', String(!isCanvasPagesPanelCollapsed));
    toggleCanvasPagesPanelBtn.setAttribute('aria-disabled', 'false');
    toggleCanvasPagesPanelBtn.setAttribute('title', isCanvasPagesPanelCollapsed ? 'Show pages panel' : 'Hide pages panel');
    if (hideCanvasPagesPanelBtn) {
        hideCanvasPagesPanelBtn.textContent = isCanvasPagesPanelCollapsed ? 'Show' : 'Hide';
        hideCanvasPagesPanelBtn.setAttribute('title', isCanvasPagesPanelCollapsed ? 'Show pages panel' : 'Hide pages panel');
    }
    localStorage.setItem(PAGE_STRIP_COLLAPSE_KEY, isCanvasPagesPanelCollapsed ? '1' : '0');
    refreshCanvasSize();
}

function beginCanvasSwitchTransition() {
    if (!canvasEditorStage) return () => { };
    canvasEditorStage.classList.add('page-switching');
    let ended = false;
    return () => {
        if (ended) return;
        ended = true;
        requestAnimationFrame(() => canvasEditorStage.classList.remove('page-switching'));
    };
}

function iconSvg(kind) {
    const icons = {
        add: '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14"/><path d="M5 12h14"/></svg>',
        duplicate: '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="11" height="11" rx="2"/><rect x="4" y="4" width="11" height="11" rx="2"/></svg>',
        delete: '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18"/><path d="M8 6V4h8v2"/><path d="M19 6l-1 14H6L5 6"/><path d="M10 11v6"/><path d="M14 11v6"/></svg>'
    };
    return icons[kind] || '';
}

function getPageLayoutLeft(pageIndex) {
    let left = 0;
    for (let i = 0; i < pageIndex; i++) {
        const width = parsePositiveInt(documentPages[i]?.width, DEFAULT_PAGE_WIDTH);
        left += width + PAGE_SIDE_GAP;
    }
    return left;
}

function getPageBounds(pageIndex) {
    const page = documentPages[pageIndex];
    if (!page) return null;
    const width = parsePositiveInt(page.width, DEFAULT_PAGE_WIDTH);
    const height = parsePositiveInt(page.height, DEFAULT_PAGE_HEIGHT);
    const left = getPageLayoutLeft(pageIndex);
    const top = 0;
    return {
        pageIndex,
        pageId: page.id,
        left,
        top,
        width,
        height,
        right: left + width,
        bottom: top + height
    };
}

function buildCanvasMaskRect(left, top, width, height) {
    return new fabric.Rect({
        left,
        top,
        originX: 'left',
        originY: 'top',
        width,
        height,
        absolutePositioned: true,
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
        excludeFromExport: true,
        isCanvasMask: true
    });
}

function applyObjectMaskRect(obj, { left, top, width, height }, options = {}) {
    const force = options.force === true;
    if (!obj) return;
    if (!force && (obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine || obj.isArtboard)) return;
    obj.clipPath = buildCanvasMaskRect(left, top, width, height);
    obj.dirty = true;
    if (typeof obj.setCoords === 'function') obj.setCoords();
}

function applyObjectMaskForPage(obj, pageIndex) {
    const bounds = getPageBounds(pageIndex);
    if (!bounds) return;
    applyObjectMaskRect(obj, bounds);
}

function applyCanvasMaskToActivePageObjects() {
    if (!canvas || !pageRect) return;
    canvas.getObjects().forEach(obj => {
        if (!obj || obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine || obj.isCanvasGhost || obj.isArtboard) return;
        applyObjectMaskForPage(obj, currentPageIndex);
    });
}

function getObjectBoundsRect(obj) {
    if (!obj || typeof obj.getBoundingRect !== 'function') return null;
    obj.setCoords();
    const rect = obj.getBoundingRect(true, true);
    const width = normalizeNumeric(rect?.width, 0);
    const height = normalizeNumeric(rect?.height, 0);
    if (width <= 0 || height <= 0) return null;
    const left = normalizeNumeric(rect.left, 0);
    const top = normalizeNumeric(rect.top, 0);
    return {
        left,
        top,
        width,
        height,
        right: left + width,
        bottom: top + height
    };
}

function getRectIntersectionArea(a, b) {
    if (!a || !b) return 0;
    const x = Math.max(0, Math.min(a.right, b.right) - Math.max(a.left, b.left));
    const y = Math.max(0, Math.min(a.bottom, b.bottom) - Math.max(a.top, b.top));
    return x * y;
}

function isRectOverlappingBounds(rect, bounds, tolerance = 0.5) {
    if (!rect || !bounds) return false;
    return !(
        rect.right < (bounds.left - tolerance)
        || rect.left > (bounds.right + tolerance)
        || rect.bottom < (bounds.top - tolerance)
        || rect.top > (bounds.bottom + tolerance)
    );
}

function getObjectCoordsRect(obj) {
    if (!obj) return null;
    if (typeof obj.setCoords === 'function') obj.setCoords();

    // getBoundingRect(true) returns the bounding box in world (canvas) coordinates.
    // This is the most reliable way to check if an object is truly outside the canvas pages,
    // especially when it's part of a group or selection.
    const rect = obj.getBoundingRect(true, true);
    if (rect && rect.width > 0 && rect.height > 0) {
        return {
            left: rect.left,
            top: rect.top,
            right: rect.left + rect.width,
            bottom: rect.top + rect.height,
            width: rect.width,
            height: rect.height
        };
    }

    // Fallback for objects without getBoundingRect but with getCoords
    let xs = [], ys = [];
    if (typeof obj.getCoords === 'function') {
        const points = obj.getCoords(true, true) || [];
        xs = points.map(p => normalizeNumeric(p?.x, NaN)).filter(Number.isFinite);
        ys = points.map(p => normalizeNumeric(p?.y, NaN)).filter(Number.isFinite);
    }

    if (!xs.length || !ys.length) return null;

    const left = Math.min(...xs);
    const right = Math.max(...xs);
    const top = Math.min(...ys);
    const bottom = Math.max(...ys);

    return {
        left,
        right,
        top,
        bottom,
        width: Math.max(0, right - left),
        height: Math.max(0, bottom - top)
    };
}

function isPointInsideBounds(point, bounds, tolerance = 0.5) {
    if (!point || !bounds) return false;
    const x = normalizeNumeric(point.x, NaN);
    const y = normalizeNumeric(point.y, NaN);
    if (!Number.isFinite(x) || !Number.isFinite(y)) return false;
    return x >= (bounds.left - tolerance)
        && x <= (bounds.right + tolerance)
        && y >= (bounds.top - tolerance)
        && y <= (bounds.bottom + tolerance);
}

function isObjectOutsideAllCanvasPages(obj) {
    if (!obj) return false;
    // Never remove core structural objects
    if (obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine || obj.isArtboard || obj.isCanvasMask || obj.isCanvasGhost) return false;

    // If an object is currently part of a group (or ActiveSelection), its individual 
    // coordinates are relative. Skipping these prevents accidental removal during interaction.
    if (obj.group) return false;

    // NEVER remove the currently active object or any object in the active selection
    const active = canvas.getActiveObject();
    if (active === obj) return false;
    if (active && active.type === 'activeSelection' && typeof active.contains === 'function' && active.contains(obj)) return false;

    const objectRect = getObjectCoordsRect(obj);
    if (!objectRect) return false;

    // Check overlap with any page. If it overlaps even slightly, it's NOT "outside all".
    for (let index = 0; index < documentPages.length; index++) {
        const bounds = getPageBounds(index);
        if (!bounds) continue;
        if (isRectOverlappingBounds(objectRect, bounds)) return false;
    }

    // For extra precision (e.g. very thin rotated lines), check individual corners and center
    const center = (typeof obj.getCenterPoint === 'function') ? obj.getCenterPoint() : null;
    if (center) {
        for (let i = 0; i < documentPages.length; i++) {
            const bounds = getPageBounds(i);
            if (bounds && isPointInsideBounds(center, bounds)) return false;
        }
    }

    if (typeof obj.getCoords === 'function') {
        const points = obj.getCoords(true, true) || [];
        for (const point of points) {
            for (let i = 0; i < documentPages.length; i++) {
                const bounds = getPageBounds(i);
                if (bounds && isPointInsideBounds(point, bounds)) return false;
            }
        }
    }

    return true;
}

function getObjectsOutsideAllCanvasPages(target) {
    if (!target) return [];
    const candidates = target.type === 'activeSelection' && typeof target.getObjects === 'function'
        ? target.getObjects()
        : [target];
    return candidates
        .filter(Boolean)
        .filter(obj => isObjectOutsideAllCanvasPages(obj));
}

function removeObjectsOutsideAllCanvasPages(target, checkAll = false) {
    let candidates = [];
    if (checkAll) {
        candidates = canvas.getObjects().filter(o =>
            o && o.oid !== 'pageRect' && !o.excludeFromExport && !o.isArtboard && !o.isCanvasMask && !o.isSnapLine
        );
    } else if (target) {
        candidates = target.type === 'activeSelection' && typeof target.getObjects === 'function'
            ? target.getObjects()
            : [target];
    }

    const outsideObjects = candidates.filter(Boolean).filter(obj => isObjectOutsideAllCanvasPages(obj));
    if (!outsideObjects.length) return false;

    removeCanvasObjects(outsideObjects);
    return true;
}

const scheduleOutsideObjectsCleanup = debounce(() => {
    if (isPastingFromClipboard || isPageSwitching || isRenderingCanvasGhosts || isObjectInteractionActive) return;
    removeObjectsOutsideAllCanvasPages(null, true);
}, 140);

function getDominantPageForObject(obj, threshold = 0.5) {
    const objectRect = getObjectBoundsRect(obj);
    if (!objectRect) return { pageIndex: -1, ratio: 0 };
    const area = Math.max(1, objectRect.width * objectRect.height);

    let bestIndex = -1;
    let bestRatio = 0;
    documentPages.forEach((_, index) => {
        const bounds = getPageBounds(index);
        if (!bounds) return;
        const overlap = getRectIntersectionArea(objectRect, bounds);
        const ratio = overlap / area;
        if (ratio > bestRatio) {
            bestRatio = ratio;
            bestIndex = index;
        }
    });

    if (bestRatio < threshold) return { pageIndex: -1, ratio: bestRatio };
    return { pageIndex: bestIndex, ratio: bestRatio };
}

function getBestOverlapPageForObject(obj, { excludePageIndex = -1 } = {}) {
    const objectRect = getObjectCoordsRect(obj);
    if (!objectRect) return { pageIndex: -1, area: 0, currentArea: 0 };

    let bestIndex = -1;
    let bestArea = 0;
    let currentArea = 0;
    documentPages.forEach((_, index) => {
        const bounds = getPageBounds(index);
        if (!bounds) return;
        const overlap = getRectIntersectionArea(objectRect, bounds);
        if (index === currentPageIndex) currentArea = overlap;
        if (index === excludePageIndex) return;
        if (overlap > bestArea) {
            bestArea = overlap;
            bestIndex = index;
        }
    });

    return {
        pageIndex: bestArea > 0 ? bestIndex : -1,
        area: bestArea,
        currentArea
    };
}

function sanitizeTransferredObjectState(objState) {
    if (!objState || typeof objState !== 'object') return objState;
    const next = { ...objState };
    if (next.clipPath) delete next.clipPath;
    if (next.transformMatrix) delete next.transformMatrix;
    if (Array.isArray(next.objects)) {
        next.objects = next.objects.map(child => sanitizeTransferredObjectState(child));
    }
    return next;
}

async function transferObjectToPage(obj, targetPageIndex) {
    if (!obj || isPageSwitching || isReassigningPageOwnership) return false;
    if (!documentPages[targetPageIndex] || targetPageIndex === currentPageIndex) return false;
    if (obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine || obj.isArtboard || obj.isCanvasGhost) return false;

    const oid = obj.oid;
    const sourcePageIndex = currentPageIndex;
    const sourcePage = documentPages[sourcePageIndex];
    const targetPage = documentPages[targetPageIndex];
    if (!sourcePage || !targetPage) return false;

    syncCurrentPageStateFromCanvas();

    const sourceObjects = sourcePage.canvas?.objects || [];
    const sourceObjectIndex = sourceObjects.findIndex(item => item && item.oid === oid);
    if (sourceObjectIndex < 0) return false;

    const movedStateRaw = sourceObjects[sourceObjectIndex];
    sourceObjects.splice(sourceObjectIndex, 1);

    const movedState = sanitizeTransferredObjectState(deepClone(movedStateRaw));
    const sourcePageLeft = getPageLayoutLeft(sourcePageIndex);
    const targetPageLeft = getPageLayoutLeft(targetPageIndex);

    if (Number.isFinite(parseFloat(movedState.left))) {
        movedState.left = parseFloat(movedState.left) + sourcePageLeft - targetPageLeft;
    }
    if (Number.isFinite(parseFloat(movedState.top))) {
        movedState.top = parseFloat(movedState.top);
    }
    movedState.pageId = targetPage.id;

    if (!targetPage.canvas || !Array.isArray(targetPage.canvas.objects)) {
        targetPage.canvas = { version: '5.3.0', background: 'transparent', objects: [] };
    }
    targetPage.canvas.objects.push(movedState);
    ensurePageRectInCanvasState(sourcePage);
    ensurePageRectInCanvasState(targetPage);

    isReassigningPageOwnership = true;
    try {
        await switchToCanvasPage(targetPageIndex, { fitView: false, skipSave: true, suppressHistory: true });
        const movedObject = canvas.getObjects().find(item => item && item.oid === oid && !item.isCanvasGhost);
        if (movedObject) {
            applyObjectMaskForPage(movedObject, currentPageIndex);
            canvas.setActiveObject(movedObject);
            refreshInspector({ target: movedObject });
            updateFloatingLinker(movedObject);
        } else {
            canvas.discardActiveObject();
            refreshInspector({ target: null });
            updateFloatingLinker(null);
        }
        canvas.requestRenderAll();
        renderLayers();
        refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: true });
        requestSaveState();
    } finally {
        isReassigningPageOwnership = false;
    }
    return true;
}

async function maybeReassignObjectToDominantPage(target) {
    if (!target || isPageSwitching || isReassigningPageOwnership || isRenderingCanvasGhosts) return false;

    if (target.type === 'activeSelection') {
        const members = (typeof target.getObjects === 'function') ? target.getObjects().filter(o => o && o.oid !== 'pageRect') : [];
        if (!members.length) return false;
        if (members.some(member => member?.isCanvasGhost)) return false;

        const dominant = getDominantPageForObject(target, 0.5);
        let targetPageIndex = dominant.pageIndex;
        if (targetPageIndex < 0) {
            const fallback = getBestOverlapPageForObject(target, { excludePageIndex: currentPageIndex });
            if (fallback.pageIndex < 0 || fallback.currentArea > 0) return false;
            targetPageIndex = fallback.pageIndex;
        }
        if (targetPageIndex === currentPageIndex) return false;

        // Bulk transfer
        syncCurrentPageStateFromCanvas();
        const sourcePageIndex = currentPageIndex;
        const sourcePage = documentPages[sourcePageIndex];
        const targetPage = documentPages[targetPageIndex];
        if (!sourcePage || !targetPage) return false;

        const sourcePageLeft = getPageLayoutLeft(sourcePageIndex);
        const targetPageLeft = getPageLayoutLeft(targetPageIndex);

        // Transfer each member in documentPages state
        members.forEach(member => {
            const oid = member.oid;
            const sourceObjects = sourcePage.canvas?.objects || [];
            const idx = sourceObjects.findIndex(item => item && item.oid === oid);
            if (idx >= 0) {
                const raw = sourceObjects.splice(idx, 1)[0];
                const movedState = sanitizeTransferredObjectState(deepClone(raw));
                if (Number.isFinite(parseFloat(movedState.left))) {
                    movedState.left = parseFloat(movedState.left) + sourcePageLeft - targetPageLeft;
                }
                movedState.pageId = targetPage.id;
                if (!targetPage.canvas) targetPage.canvas = { objects: [] };
                if (!Array.isArray(targetPage.canvas.objects)) targetPage.canvas.objects = [];
                targetPage.canvas.objects.push(movedState);
            }
        });

        ensurePageRectInCanvasState(sourcePage);
        ensurePageRectInCanvasState(targetPage);

        isReassigningPageOwnership = true;
        try {
            await switchToCanvasPage(targetPageIndex, { fitView: false, skipSave: true, suppressHistory: true });
            const newMembers = canvas.getObjects().filter(o => members.some(m => m.oid === o.oid));
            if (newMembers.length > 1) {
                const sel = new fabric.ActiveSelection(newMembers, { canvas });
                canvas.setActiveObject(sel);
            } else if (newMembers.length === 1) {
                canvas.setActiveObject(newMembers[0]);
            }
            canvas.requestRenderAll();
            renderLayers();
            refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: true });
            requestSaveState();
        } finally {
            isReassigningPageOwnership = false;
        }
        return true;
    }

    const dominant = getDominantPageForObject(target, 0.5);
    let targetPageIndex = dominant.pageIndex;
    if (targetPageIndex < 0) {
        const fallback = getBestOverlapPageForObject(target, { excludePageIndex: currentPageIndex });
        if (fallback.pageIndex < 0 || fallback.currentArea > 0) return false;
        targetPageIndex = fallback.pageIndex;
    }
    if (targetPageIndex === currentPageIndex) return false;
    return transferObjectToPage(target, targetPageIndex);
}

function getWorkspaceObjectPageContext(target) {
    if (!target) return null;
    const fallbackOid = String(target.oid || '').trim();
    if (target.isCanvasGhost) {
        const byMeta = Number.isInteger(target.ghostSourcePageIndex) ? target.ghostSourcePageIndex : -1;
        const byPageId = pageIndexForPageId(target.pageId);
        const pageIndex = byMeta >= 0 ? byMeta : (byPageId >= 0 ? byPageId : currentPageIndex);
        const sourceOid = String(target.ghostSourceOid || fallbackOid).trim();
        return { pageIndex, sourceOid };
    }
    const byPageId = pageIndexForPageId(target.pageId);
    return {
        pageIndex: byPageId >= 0 ? byPageId : currentPageIndex,
        sourceOid: fallbackOid
    };
}

function serializeWorkspaceObjectForPageState(target, pageIndex, sourceOid) {
    const page = documentPages[pageIndex];
    if (!target || !page) return null;
    const safeSourceOid = String(sourceOid || target.oid || '').trim();
    if (!safeSourceOid) return null;

    normalizeTextboxPathsForSerialization(target);
    const raw = target.toObject(SERIALIZE_PROPS);
    raw.oid = safeSourceOid;
    raw.pageId = page.id;
    if (raw.clipPath) delete raw.clipPath;
    if (raw.excludeFromExport) delete raw.excludeFromExport;
    if (raw.isCanvasGhost) delete raw.isCanvasGhost;
    if (raw.ghostSourceOid) delete raw.ghostSourceOid;
    if (raw.ghostSourcePageIndex !== undefined) delete raw.ghostSourcePageIndex;
    if (raw.isCanvasMask) delete raw.isCanvasMask;

    const pageLeft = getPageLayoutLeft(pageIndex);
    if (Number.isFinite(parseFloat(raw.left))) raw.left = parseFloat(raw.left) - pageLeft;
    if (Number.isFinite(parseFloat(raw.top))) raw.top = parseFloat(raw.top);

    return sanitizeCanvasObject(raw, {
        pageWidth: parsePositiveInt(page.width, DEFAULT_PAGE_WIDTH),
        pageHeight: parsePositiveInt(page.height, DEFAULT_PAGE_HEIGHT)
    });
}

function removeObjectFromPageState(pageIndex, sourceOid) {
    const page = documentPages[pageIndex];
    if (!page || !sourceOid) return false;
    if (!page.canvas || !Array.isArray(page.canvas.objects)) return false;
    const idx = page.canvas.objects.findIndex(obj => obj && obj.oid === sourceOid);
    if (idx < 0) return false;
    page.canvas.objects.splice(idx, 1);
    ensurePageRectInCanvasState(page);
    return true;
}

function upsertObjectInPageState(pageIndex, sourceOid, objectState) {
    const page = documentPages[pageIndex];
    if (!page || !sourceOid || !objectState) return false;
    if (!page.canvas || !Array.isArray(page.canvas.objects)) {
        page.canvas = { version: '5.3.0', background: 'transparent', objects: [] };
    }

    const idx = page.canvas.objects.findIndex(obj => obj && obj.oid === sourceOid);
    if (idx >= 0) page.canvas.objects[idx] = objectState;
    else page.canvas.objects.push(objectState);
    ensurePageRectInCanvasState(page);
    return true;
}

function commitGhostObjectModification(target, options = {}) {
    const context = getWorkspaceObjectPageContext(target);
    if (!context || !context.sourceOid) return { changed: false };
    const lockToSourcePage = options.lockToSourcePage === true;

    const dominant = lockToSourcePage ? { pageIndex: context.pageIndex } : getDominantPageForObject(target, 0.5);
    const targetPageIndex = dominant.pageIndex >= 0 ? dominant.pageIndex : context.pageIndex;
    if (!documentPages[targetPageIndex]) return { changed: false };

    const objectState = serializeWorkspaceObjectForPageState(target, targetPageIndex, context.sourceOid);
    if (!objectState) return { changed: false };

    const updatedTarget = upsertObjectInPageState(targetPageIndex, context.sourceOid, objectState);
    const moved = targetPageIndex !== context.pageIndex;
    const removedSource = moved ? removeObjectFromPageState(context.pageIndex, context.sourceOid) : false;

    if (moved) {
        target.pageId = documentPages[targetPageIndex]?.id || target.pageId;
        target.ghostSourcePageIndex = targetPageIndex;
        target.ghostSourceOid = context.sourceOid;
        applyObjectMaskForPage(target, targetPageIndex);
    }

    return {
        changed: updatedTarget || removedSource,
        moved,
        sourcePageIndex: context.pageIndex,
        targetPageIndex
    };
}

function commitGhostObjectRemoval(target) {
    if (isPageSwitching || isRenderingCanvasGhosts) return false;
    const context = getWorkspaceObjectPageContext(target);
    if (!context || !context.sourceOid) return false;
    return removeObjectFromPageState(context.pageIndex, context.sourceOid);
}

function initPageActionToolbar() {
    if (!pageActionToolbar) return;
    pageActionToolbar.innerHTML = `
                <button class="btn ghost icon-only" type="button" data-role="add" title="Add Page">${iconSvg('add')}</button>
                <button class="btn ghost icon-only" type="button" data-role="duplicate" title="Duplicate Page">${iconSvg('duplicate')}</button>
                <button class="btn ghost icon-only" type="button" data-role="delete" title="Delete Page">${iconSvg('delete')}</button>
            `;
    pageActionToolbar.querySelector('[data-role="add"]')?.addEventListener('click', () => {
        const current = documentPages[currentPageIndex];
        addCanvasPage(currentPageIndex + 1, { width: current?.width, height: current?.height });
    });
    pageActionToolbar.querySelector('[data-role="duplicate"]')?.addEventListener('click', () => {
        duplicateCanvasPage(currentPageIndex);
    });
    pageActionToolbar.querySelector('[data-role="delete"]')?.addEventListener('click', () => {
        deleteCanvasPage(currentPageIndex);
    });
}

function updatePageActionToolbarPosition() {
    if (!pageActionToolbar) return;
    if (!pageRect || !documentPages.length) {
        pageActionToolbar.classList.add('hidden');
        return;
    }

    pageActionToolbar.classList.remove('hidden');
    const vpt = canvas.viewportTransform || [1, 0, 0, 1, 0, 0];
    const stageRect = canvasEditorStage?.getBoundingClientRect();
    if (!stageRect) return;

    const zoomX = vpt[0] || 1;
    const zoomY = vpt[3] || 1;
    const screenLeft = pageRect.left * zoomX + vpt[4];
    const screenTop = pageRect.top * zoomY + vpt[5];
    const screenWidth = pageRect.width * zoomX;

    const toolbarWidth = pageActionToolbar.offsetWidth || 96;
    const toolbarHeight = pageActionToolbar.offsetHeight || 30;
    const x = screenLeft + screenWidth - toolbarWidth;
    const y = screenTop - toolbarHeight - 8;
    const clampedX = Math.max(8, Math.min(stageRect.width - toolbarWidth - 8, x));
    const clampedY = Math.max(8, Math.min(stageRect.height - toolbarHeight - 8, y));
    pageActionToolbar.style.transform = `translate(${Math.round(clampedX)}px, ${Math.round(clampedY)}px)`;
}

function styleActivePageRect() {
    if (!pageRect) return;
    const isLight = document.body.classList.contains('light-mode');
    pageRect.set({
        stroke: isLight ? 'rgba(37,99,235,0.9)' : 'rgba(59,130,246,0.95)',
        strokeWidth: 2
    });
}

function relocateActiveCanvasToLayout() {
    if (!pageRect) return;
    const targetLeft = getPageLayoutLeft(currentPageIndex);
    const targetTop = 0;
    const currentLeft = normalizeNumeric(pageRect.left, 0);
    const currentTop = normalizeNumeric(pageRect.top, 0);
    const dx = targetLeft - currentLeft;
    const dy = targetTop - currentTop;
    if (Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001) return;

    pageRect.set({ left: targetLeft, top: targetTop });
    pageRect.setCoords();
    canvas.getObjects().forEach(obj => {
        if (!obj || obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine || obj.isCanvasGhost) return;
        obj.set({
            left: normalizeNumeric(obj.left, 0) + dx,
            top: normalizeNumeric(obj.top, 0) + dy
        });
        obj.setCoords();
    });
    applyCanvasMaskToActivePageObjects();
}

function clearCanvasGhostPages() {
    const ghosts = canvas.getObjects().filter(obj => obj?.isCanvasGhost);
    if (!ghosts.length) return;
    isRenderingCanvasGhosts = true;
    ghosts.forEach(obj => canvas.remove(obj));
    isRenderingCanvasGhosts = false;
}

function buildGhostHitOverlay(page, index, left, width, height) {
    const overlay = new fabric.Rect({
        left,
        top: 0,
        originX: 'left',
        originY: 'top',
        width,
        height,
        fill: 'rgba(0, 0, 0, 0.001)',
        stroke: 'rgba(100, 116, 139, 0.45)',
        strokeWidth: 1,
        strokeDashArray: [6, 4],
        selectable: false,
        evented: true,
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockScalingX: true,
        lockScalingY: true,
        lockRotation: true,
        excludeFromExport: true,
        isCanvasGhost: true,
        isArtboard: true,
        pageId: page.id,
        hoverCursor: 'pointer'
    });

    overlay.on('mousedown', async () => {
        if (isPageSwitching || index === currentPageIndex) return;
        await focusCanvasObjectFromWorkspace(index);
    });

    return overlay;
}

async function focusCanvasObjectFromWorkspace(pageIndex, sourceOid = null) {
    if (!documentPages[pageIndex]) return false;
    const switched = await switchToCanvasPage(pageIndex, { fitView: false });
    if (!switched) return false;

    let target = null;
    if (sourceOid) {
        target = canvas.getObjects().find(obj =>
            obj
            && !obj.isCanvasGhost
            && !obj.excludeFromExport
            && !obj.isSnapLine
            && !obj.isArtboard
            && obj.oid === sourceOid
        );
    }

    if (target) {
        canvas.setActiveObject(target);
        refreshInspector({ target });
        updateFloatingLinker(target);
    } else {
        canvas.discardActiveObject();
        updateFloatingLinker(null);
    }

    canvas.requestRenderAll();
    return true;
}

function resolveGhostCanvasFill(page) {
    const pageRectState = Array.isArray(page?.canvas?.objects)
        ? page.canvas.objects.find(obj => obj && obj.oid === 'pageRect')
        : null;
    const rawFill = typeof pageRectState?.fill === 'string' ? pageRectState.fill.trim() : '';
    const isTransparent = !rawFill
        || rawFill === 'transparent'
        || rawFill === 'none'
        || /^rgba\(\s*0\s*,\s*0\s*,\s*0\s*,\s*0(\.0+)?\s*\)$/i.test(rawFill);
    if (!isTransparent) return rawFill;
    return document.body.classList.contains('light-mode')
        ? 'rgba(255, 255, 255, 0.92)'
        : 'rgba(248, 250, 252, 0.88)';
}

function buildGhostArtboard(page, left, width, height) {
    return new fabric.Rect({
        left,
        top: 0,
        originX: 'left',
        originY: 'top',
        width,
        height,
        fill: resolveGhostCanvasFill(page),
        stroke: 'rgba(148, 163, 184, 0.55)',
        strokeWidth: 1,
        strokeDashArray: [4, 4],
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockScalingX: true,
        lockScalingY: true,
        lockRotation: true,
        excludeFromExport: true,
        isCanvasGhost: true,
        isArtboard: true,
        pageId: page.id
    });
}

function prepareGhostObject(obj, offsetX, pageId, pageIndex, pageWidth, pageHeight) {
    if (!obj) return null;
    const left = normalizeNumeric(obj.left, 0) + offsetX;
    const top = normalizeNumeric(obj.top, 0);
    const sourceOid = String(obj.oid || obj.name || obj.type || 'obj');
    obj.set({
        left,
        top,
        selectable: true,
        evented: true,
        hasControls: false,
        hasBorders: false,
        lockMovementX: false,
        lockMovementY: false,
        lockScalingX: true,
        lockScalingY: true,
        lockRotation: true,
        excludeFromExport: true,
        isCanvasGhost: true,
        hoverCursor: 'move'
    });
    obj.oid = `ghost_${pageId}_${sourceOid}`;
    obj.pageId = pageId;
    obj.ghostSourceOid = sourceOid;
    obj.ghostSourcePageIndex = pageIndex;
    applyObjectMaskRect(obj, {
        left: offsetX,
        top: 0,
        width: pageWidth,
        height: pageHeight
    }, { force: true });
    let movedSinceMouseDown = false;
    obj.on('mousedown', () => { movedSinceMouseDown = false; });
    obj.on('moving', () => { movedSinceMouseDown = true; });
    obj.on('mouseup', async (evt) => {
        if (isPageSwitching || pageIndex === currentPageIndex) return;
        if (movedSinceMouseDown) return;
        if (evt?.e?.shiftKey || evt?.e?.ctrlKey || evt?.e?.metaKey) return;
        await focusCanvasObjectFromWorkspace(pageIndex, sourceOid);
    });

    if (obj.type === 'line') {
        obj.controls = {};
    }

    if (typeof obj.forEachObject === 'function') {
        obj.forEachObject(child => {
            if (!child) return;
            child.selectable = false;
            child.evented = false;
            child.excludeFromExport = true;
            child.isCanvasGhost = true;
            child.oid = `ghost_${pageId}_${String(child.oid || child.name || child.type || 'child')}`;
            child.pageId = pageId;
        });
    }

    if (obj.isTable) {
        try {
            ensureTableCellData(obj);
            updateTableLayout(obj);
        } catch (error) {
            console.warn('Failed to prepare ghost table:', error);
        }
    }

    if (typeof obj.setCoords === 'function') obj.setCoords();
    return obj;
}

function renderCanvasGhostPages() {
    if (!canvas || !pageRect || !Array.isArray(documentPages)) return;
    const renderToken = ++ghostRenderVersion;
    clearCanvasGhostPages();
    if (documentPages.length <= 1) {
        canvas.sendToBack(pageRect);
        canvas.requestRenderAll();
        return;
    }

    const ghostTasks = documentPages.map((page, index) => {
        if (!page || index === currentPageIndex) return null;
        const width = parsePositiveInt(page.width, DEFAULT_PAGE_WIDTH);
        const height = parsePositiveInt(page.height, DEFAULT_PAGE_HEIGHT);
        const left = getPageLayoutLeft(index);
        const artboard = buildGhostArtboard(page, left, width, height);
        const overlay = buildGhostHitOverlay(page, index, left, width, height);
        const safeCanvas = sanitizeCanvasStateForEditor(page.canvas, { pageWidth: width, pageHeight: height });
        const rawObjects = (safeCanvas.objects || []).filter(obj =>
            obj
            && obj.oid !== 'pageRect'
            && !obj.excludeFromExport
            && !obj.isSnapLine
            && !obj.isCanvasGhost
        );

        if (!rawObjects.length) {
            return Promise.resolve({ index, artboard, objects: [], overlay });
        }

        return new Promise((resolve) => {
            fabric.util.enlivenObjects(rawObjects, (objects) => {
                if (renderToken !== ghostRenderVersion) {
                    resolve({ artboard: null, objects: [], overlay: null });
                    return;
                }
                const prepared = (objects || [])
                    .map(obj => prepareGhostObject(obj, left, page.id, index, width, height))
                    .filter(Boolean);
                resolve({ index, artboard, objects: prepared, overlay });
            }, null);
        });
    }).filter(Boolean);

    Promise.all(ghostTasks)
        .then((results) => {
            if (renderToken !== ghostRenderVersion) return;

            isRenderingCanvasGhosts = true;
            try {
                const newGhostItems = [];
                const sortedResults = results.sort((a, b) => (a.index || 0) - (b.index || 0));

                sortedResults.forEach(({ artboard }) => {
                    if (artboard) {
                        artboard.set({ objectCaching: false, skipOffscreen: false });
                        artboard.setCoords();
                        newGhostItems.push(artboard);
                    }
                });

                sortedResults.forEach(({ overlay }) => {
                    if (overlay) {
                        overlay.set({ skipOffscreen: false });
                        overlay.setCoords();
                        newGhostItems.push(overlay);
                    }
                });

                sortedResults.forEach(({ objects }) => {
                    (objects || []).forEach(obj => {
                        obj.set({ skipOffscreen: false });
                        obj.setCoords();
                        newGhostItems.push(obj);
                    });
                });

                if (newGhostItems.length > 0) {
                    canvas.remove(pageRect);
                    canvas.insertAt(pageRect, 0);
                    let insertIndex = 1;
                    newGhostItems.forEach(item => {
                        canvas.insertAt(item, insertIndex);
                        insertIndex += 1;
                    });
                    canvas.calcOffset();
                } else {
                    canvas.sendToBack(pageRect);
                }
            } finally {
                isRenderingCanvasGhosts = false;
            }

            canvas.requestRenderAll();
        })
        .catch((error) => {
            console.error('Failed to render ghost canvases:', error);
            isRenderingCanvasGhosts = false;
        });
}

function renderCanvasPagePreview(previewEl, pageState) {
    if (!previewEl || !pageState) return;
    previewEl.style.backgroundImage = '';
    previewEl.style.backgroundSize = '16px 16px';
    previewEl.style.backgroundRepeat = 'repeat';
    previewEl.textContent = 'Preview';

    try {
        const off = document.createElement('canvas');
        off.width = 320;
        off.height = 220;
        const staticCanvas = new fabric.StaticCanvas(off, { renderOnAddRemove: false, selection: false });
        const safeCanvas = sanitizeCanvasStateForEditor(pageState.canvas, {
            pageWidth: parsePositiveInt(pageState.width, DEFAULT_PAGE_WIDTH),
            pageHeight: parsePositiveInt(pageState.height, DEFAULT_PAGE_HEIGHT)
        });

        staticCanvas.loadFromJSON(safeCanvas, () => {
            const artboard = staticCanvas.getObjects().find(o => o && (o.oid === 'pageRect' || o.isArtboard));
            if (artboard) {
                artboard.set({ strokeWidth: 1, shadow: null });
                const zoom = Math.min(off.width / artboard.width, off.height / artboard.height) * 0.9;
                staticCanvas.setZoom(zoom);
                staticCanvas.viewportTransform[4] = (off.width - artboard.width * zoom) / 2;
                staticCanvas.viewportTransform[5] = (off.height - artboard.height * zoom) / 2;
            }
            staticCanvas.renderAll();
            if (previewEl.isConnected) {
                previewEl.style.backgroundImage = `url(${off.toDataURL('image/png')})`;
                previewEl.style.backgroundSize = 'contain';
                previewEl.style.backgroundRepeat = 'no-repeat';
                previewEl.textContent = '';
            }
            staticCanvas.dispose();
        });
    } catch (error) {
        console.warn('Canvas preview render failed:', error);
        previewEl.textContent = 'Preview unavailable';
    }
}

function setSingleCanvasDimensions(pageIndex, widthValue, heightValue) {
    const page = documentPages[pageIndex];
    if (!page) return;

    const width = parsePositiveInt(widthValue, page.width || DEFAULT_PAGE_WIDTH);
    const height = parsePositiveInt(heightValue, page.height || DEFAULT_PAGE_HEIGHT);
    if (width === page.width && height === page.height) return;

    if (pageIndex === currentPageIndex) syncCurrentPageStateFromCanvas();

    page.width = width;
    page.height = height;
    ensurePageRectInCanvasState(page);

    const shouldRefreshActiveLayout = !!pageRect && (pageIndex === currentPageIndex || pageIndex < currentPageIndex);
    if (pageIndex === currentPageIndex && pageRect) {
        pageRect.set({ width, height });
        pageRect.setCoords();
    }

    if (shouldRefreshActiveLayout) {
        relocateActiveCanvasToLayout();
        applyCanvasMaskToActivePageObjects();
        drawGrid();
        clampViewportTransform(canvas.viewportTransform);
        canvas.renderAll();
        syncCurrentPageStateFromCanvas();
    }

    renderCanvasGhostPages();
    refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: false });
    requestSaveState();
}

function refreshCanvasPageControls(options = {}) {
    if (!canvasPagesStrip) return;
    ensureDocumentPagesIntegrity();
    const preserveScroll = options.preserveScroll !== false;
    const priorScroll = preserveScroll ? canvasPagesStrip.scrollLeft : 0;
    const previousFocusId = document.activeElement?.id || '';

    normalizeCanvasPageSelections({ ensureCurrent: true });
    syncGeneralPageSizeInputs();
    canvasPagesStrip.innerHTML = '';

    documentPages.forEach((page, index) => {
        const card = document.createElement('div');
        const isActive = index === currentPageIndex;
        const isSelected = selectedCanvasIndexes.has(index);
        card.className = `canvas-page-card${isActive ? ' active' : ''}${isSelected ? ' selected' : ''}`;
        card.dataset.index = String(index);
        card.draggable = documentPages.length > 1;
        card.innerHTML = `
                    <div class="canvas-page-toolbar">
                        <span class="canvas-page-label">Page ${index + 1}</span>
                        <input type="number" min="100" max="10000" value="${parsePositiveInt(page.width, DEFAULT_PAGE_WIDTH)}" title="Width" data-role="width">
                        <span class="muted">×</span>
                        <input type="number" min="100" max="10000" value="${parsePositiveInt(page.height, DEFAULT_PAGE_HEIGHT)}" title="Height" data-role="height">
                        <button class="btn ghost icon-only" type="button" data-role="add" title="Add after this page">${iconSvg('add')}</button>
                        <button class="btn ghost icon-only" type="button" data-role="duplicate" title="Duplicate this page">${iconSvg('duplicate')}</button>
                        <button class="btn ghost icon-only" type="button" data-role="delete" title="Delete this page">${iconSvg('delete')}</button>
                    </div>
                    <div class="canvas-page-preview" data-role="preview"></div>
                `;

        const widthInput = card.querySelector('input[data-role="width"]');
        const heightInput = card.querySelector('input[data-role="height"]');
        const preview = card.querySelector('[data-role="preview"]');
        const addBtn = card.querySelector('button[data-role="add"]');
        const duplicateBtn = card.querySelector('button[data-role="duplicate"]');
        const deleteBtn = card.querySelector('button[data-role="delete"]');

        if (deleteBtn) deleteBtn.disabled = documentPages.length <= 1;

        const handleCanvasCardClick = async (event) => {
            const isRange = !!event?.shiftKey;
            const isToggle = !!(event?.ctrlKey || event?.metaKey);

            if (!isRange && !isToggle) {
                setCanvasPageSelection([index], { ensureCurrent: false });
                canvasSelectionAnchorIndex = index;
            } else {
                const nextSelection = new Set(getSelectedCanvasPageIndexes({ ensureCurrent: false }));
                if (isRange) {
                    const anchor = Math.max(0, Math.min(documentPages.length - 1, parseInt(canvasSelectionAnchorIndex, 10) || currentPageIndex));
                    const start = Math.min(anchor, index);
                    const end = Math.max(anchor, index);
                    if (!isToggle) nextSelection.clear();
                    for (let i = start; i <= end; i++) nextSelection.add(i);
                } else if (isToggle) {
                    if (nextSelection.has(index) && index !== currentPageIndex) nextSelection.delete(index);
                    else nextSelection.add(index);
                }
                setCanvasPageSelection(Array.from(nextSelection), { ensureCurrent: true });
                canvasSelectionAnchorIndex = index;
            }

            if (index !== currentPageIndex) {
                await switchToCanvasPage(index, { fitView: false });
                requestSaveState();
                return;
            }

            renderCanvasGhostPages();
            refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: true });
        };

        if (preview) preview.addEventListener('click', (event) => {
            event.stopPropagation();
            handleCanvasCardClick(event);
        });
        card.addEventListener('click', (event) => {
            const interactive = event.target.closest('input, button');
            if (!interactive) handleCanvasCardClick(event);
        });

        card.addEventListener('dragstart', (event) => {
            const interactive = event.target?.closest?.('input, button');
            if (interactive) {
                event.preventDefault();
                return;
            }
            if (!event.dataTransfer || documentPages.length <= 1) return;
            draggedCanvasPageIndex = index;
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', String(index));
            card.classList.add('dragging');
        });
        card.addEventListener('dragend', () => {
            draggedCanvasPageIndex = null;
            card.classList.remove('dragging');
            card.classList.remove('drag-over');
        });
        card.addEventListener('dragover', (event) => {
            const fromIndex = Number.isInteger(draggedCanvasPageIndex)
                ? draggedCanvasPageIndex
                : parseInt(event.dataTransfer?.getData('text/plain'), 10);
            if (!Number.isInteger(fromIndex) || fromIndex === index) return;
            event.preventDefault();
            if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
            card.classList.add('drag-over');
        });
        card.addEventListener('dragleave', () => {
            card.classList.remove('drag-over');
        });
        card.addEventListener('drop', async (event) => {
            const fromIndex = Number.isInteger(draggedCanvasPageIndex)
                ? draggedCanvasPageIndex
                : parseInt(event.dataTransfer?.getData('text/plain'), 10);
            if (!Number.isInteger(fromIndex) || fromIndex === index) return;
            event.preventDefault();
            card.classList.remove('drag-over');
            const rect = card.getBoundingClientRect();
            const dropAfter = event.clientX > rect.left + rect.width / 2;
            let insertAt = index;
            if (fromIndex < index) insertAt -= 1;
            if (dropAfter) insertAt += 1;
            await reorderCanvasPages(fromIndex, insertAt);
        });

        const applyPageSize = () => {
            setSingleCanvasDimensions(index, widthInput?.value, heightInput?.value);
        };
        if (widthInput) {
            widthInput.addEventListener('change', applyPageSize);
            widthInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') applyPageSize(); });
        }
        if (heightInput) {
            heightInput.addEventListener('change', applyPageSize);
            heightInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') applyPageSize(); });
        }

        if (addBtn) {
            addBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                addCanvasPage(index + 1, { width: page.width, height: page.height });
            });
        }
        if (duplicateBtn) {
            duplicateBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                duplicateCanvasPage(index);
            });
        }
        if (deleteBtn) {
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteCanvasPage(index);
            });
        }

        canvasPagesStrip.appendChild(card);
        renderCanvasPagePreview(preview, page);
    });

    const addCard = document.createElement('button');
    addCard.className = 'canvas-page-add-card';
    addCard.type = 'button';
    addCard.textContent = '+ Add Page';
    addCard.addEventListener('click', () => {
        addCanvasPage(documentPages.length, { width: generalPageSize.width, height: generalPageSize.height });
    });
    addCard.addEventListener('dragover', (event) => {
        const fromIndex = Number.isInteger(draggedCanvasPageIndex)
            ? draggedCanvasPageIndex
            : parseInt(event.dataTransfer?.getData('text/plain'), 10);
        if (!Number.isInteger(fromIndex)) return;
        event.preventDefault();
        if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
    });
    addCard.addEventListener('drop', async (event) => {
        const fromIndex = Number.isInteger(draggedCanvasPageIndex)
            ? draggedCanvasPageIndex
            : parseInt(event.dataTransfer?.getData('text/plain'), 10);
        if (!Number.isInteger(fromIndex)) return;
        event.preventDefault();
        await reorderCanvasPages(fromIndex, documentPages.length);
    });
    canvasPagesStrip.appendChild(addCard);

    if (preserveScroll) canvasPagesStrip.scrollLeft = priorScroll;
    if (options.ensureActiveVisible !== false) {
        const activeCard = canvasPagesStrip.querySelector('.canvas-page-card.active');
        if (activeCard) activeCard.scrollIntoView({ block: 'nearest', inline: 'nearest' });
    }

    if (previousFocusId === 'pageWidth' || previousFocusId === 'pageHeight') {
        syncGeneralPageSizeInputs();
    }
    updatePageActionToolbarPosition();
    if (typeof syncExportPageSelectorUI === 'function') syncExportPageSelectorUI();
}

const refreshCanvasPageControlsDebounced = debounce(() => {
    refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: false });
}, 220);

function syncCurrentPageStateFromCanvas() {
    if (isPageSwitching || !documentPages[currentPageIndex]) return;
    const pageState = documentPages[currentPageIndex];
    pageState.title = pageState.title || `Page ${currentPageIndex + 1}`;
    if (pageRect) {
        pageState.width = parsePositiveInt(Math.round(pageRect.width), pageState.width || DEFAULT_PAGE_WIDTH);
        pageState.height = parsePositiveInt(Math.round(pageRect.height), pageState.height || DEFAULT_PAGE_HEIGHT);
    } else {
        pageState.width = parsePositiveInt(pageState.width, DEFAULT_PAGE_WIDTH);
        pageState.height = parsePositiveInt(pageState.height, DEFAULT_PAGE_HEIGHT);
    }
    const pageLeft = pageRect ? normalizeNumeric(pageRect.left, getPageLayoutLeft(currentPageIndex)) : getPageLayoutLeft(currentPageIndex);
    const pageTop = pageRect ? normalizeNumeric(pageRect.top, 0) : 0;
    normalizeTextboxPathsForSerialization();
    let serializedCanvas = null;
    try {
        serializedCanvas = canvas.toJSON(SERIALIZE_PROPS);
    } catch (error) {
        console.warn('Canvas serialization failed; attempting text object repair.', error);
        try {
            repairLiveCanvasTextObjectsForSerialization();
            normalizeTextboxPathsForSerialization();
            serializedCanvas = canvas.toJSON(SERIALIZE_PROPS);
        } catch (retryError) {
            console.error('Canvas serialization failed after repair attempt.', retryError);
            return;
        }
    }
    if (Array.isArray(serializedCanvas.objects)) {
        serializedCanvas.objects = serializedCanvas.objects
            .filter(obj => {
                if (!obj) return false;
                if (obj.oid === 'pageRect') return true;
                return !obj.excludeFromExport && !obj.isSnapLine && !obj.isCanvasGhost;
            })
            .map(obj => {
                const next = { ...obj };
                if (next.clipPath) delete next.clipPath;
                if (next.oid === 'pageRect') {
                    next.left = 0;
                    next.top = 0;
                    next.width = pageState.width;
                    next.height = pageState.height;
                    return next;
                }
                if (Number.isFinite(parseFloat(next.left))) next.left = parseFloat(next.left) - pageLeft;
                if (Number.isFinite(parseFloat(next.top))) next.top = parseFloat(next.top) - pageTop;
                return sanitizeCanvasObject(next, {
                    pageWidth: pageState.width,
                    pageHeight: pageState.height
                });
            })
            .filter(Boolean);
    }
    pageState.canvas = serializedCanvas;
    pageState.bindings = Array.from(bindings.entries());
    ensurePageRectInCanvasState(pageState);
}

function pageHasRenderableObjects(pageState) {
    const objects = pageState?.canvas?.objects || [];
    return objects.some(o => o && o.oid !== 'pageRect' && !o.excludeFromExport && !o.isSnapLine);
}

function buildTemplatePayload() {
    syncCurrentPageStateFromCanvas();
    if (!documentPages.length) {
        documentPages = [createBlankPageState(0, DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT)];
        currentPageIndex = 0;
        setCanvasPageSelection([0], { ensureCurrent: false });
        canvasSelectionAnchorIndex = 0;
    }

    const clonedPages = deepClone(documentPages);
    const activePage = clonedPages[currentPageIndex] || clonedPages[0];

    return {
        page: {
            title: $('#titleInput').value || 'Untitled_Template',
            width: activePage?.width || DEFAULT_PAGE_WIDTH,
            height: activePage?.height || DEFAULT_PAGE_HEIGHT
        },
        canvas: activePage?.canvas || { version: '5.3.0', background: 'transparent', objects: [] },
        bindings: activePage?.bindings || [],
        pages: clonedPages,
        currentPageIndex,
        data: { headers, rows: dataRows, identifierColumn: identifierColumn || '' }
    };
}

function switchToCanvasPage(index, { fitView = false, skipSave = false, suppressHistory = false } = {}) {
    return new Promise((resolve) => {
        ensureDocumentPagesIntegrity();
        const safeIndex = Math.max(0, Math.min(documentPages.length - 1, parseInt(index, 10) || 0));
        if (!documentPages[safeIndex]) {
            resolve(false);
            return;
        }

        if (!skipSave) syncCurrentPageStateFromCanvas();

        const nextPage = documentPages[safeIndex];
        const priorHistoryLock = historyLocked;
        const priorViewportTransform = Array.isArray(canvas.viewportTransform)
            ? [...canvas.viewportTransform]
            : [1, 0, 0, 1, 0, 0];
        const endSwitchTransition = beginCanvasSwitchTransition();
        currentPageIndex = safeIndex;
        isPageSwitching = true;
        historyLocked = true;
        bindings = new Map(nextPage.bindings || []);

        const finalizeSwitch = (ok) => {
            historyLocked = priorHistoryLock;
            isPageSwitching = false;
            endSwitchTransition();
            resolve(!!ok);
        };

        canvas.discardActiveObject();
        try {
            canvas.loadFromJSON(nextPage.canvas, () => {
                try {
                    restoreCanvasStateAfterLoad(() => {
                        pageRect = canvas.getObjects().find(o => o.oid === 'pageRect');
                        const pageLeft = getPageLayoutLeft(currentPageIndex);
                        if (pageRect) {
                            pageRect.set({
                                left: pageLeft,
                                top: 0,
                                width: nextPage.width,
                                height: nextPage.height,
                                selectable: false,
                                evented: false,
                                hasControls: false,
                                hasBorders: false,
                                lockMovementX: true,
                                lockMovementY: true,
                                lockScalingX: true,
                                lockScalingY: true,
                                lockRotation: true,
                                isArtboard: true
                            });
                            pageRect.setCoords();
                        }
                        canvas.getObjects().forEach(obj => {
                            if (!obj || obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine || obj.isCanvasGhost) return;
                            obj.set({
                                left: normalizeNumeric(obj.left, 0) + pageLeft,
                                top: normalizeNumeric(obj.top, 0)
                            });
                            obj.setCoords();
                        });
                        applyCanvasMaskToActivePageObjects();
                        styleActivePageRect();

                        refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: true });
                        keepPageRectAtBack();
                        drawGrid();
                        renderCanvasGhostPages();
                        renderLayers();
                        renderPageInspector();
                        canvas.discardActiveObject();
                        $('#inspector').style.display = 'none';
                        $('#multiSelectInspector').style.display = 'none';
                        $('#noSelection').style.display = 'block';
                        updateFloatingLinker(null);

                        if (fitView) centerAndFitPage();
                        else {
                            canvas.setViewportTransform(priorViewportTransform);
                            canvas.requestRenderAll();
                        }
                        updatePageActionToolbarPosition();

                        finalizeSwitch(true);
                    });
                } catch (error) {
                    console.error('Failed during page restore:', error);
                    finalizeSwitch(false);
                }
            });
        } catch (error) {
            console.error('Failed to load page JSON:', error);
            finalizeSwitch(false);
        }
    });
}

async function reorderCanvasPages(fromIndex, toIndex) {
    ensureDocumentPagesIntegrity();
    if (!Array.isArray(documentPages) || documentPages.length <= 1) return false;

    const safeFrom = Math.max(0, Math.min(documentPages.length - 1, parseInt(fromIndex, 10) || 0));
    const parsedTo = parseInt(toIndex, 10);
    const safeToRaw = Number.isInteger(parsedTo) ? parsedTo : safeFrom;
    const safeTo = Math.max(0, Math.min(documentPages.length - 1, safeToRaw));
    if (safeFrom === safeTo) return false;

    syncCurrentPageStateFromCanvas();

    const [movedPage] = documentPages.splice(safeFrom, 1);
    const insertAt = Math.max(0, Math.min(documentPages.length, safeToRaw));
    documentPages.splice(insertAt, 0, movedPage);

    const nextCurrent = remapCanvasPageIndexForMove(currentPageIndex, safeFrom, insertAt);
    currentPageIndex = Math.max(0, Math.min(documentPages.length - 1, nextCurrent));

    const remappedSelection = new Set();
    selectedCanvasIndexes.forEach(idx => {
        const remapped = remapCanvasPageIndexForMove(idx, safeFrom, insertAt);
        if (Number.isInteger(remapped) && remapped >= 0 && remapped < documentPages.length) {
            remappedSelection.add(remapped);
        }
    });
    selectedCanvasIndexes = remappedSelection;
    canvasSelectionAnchorIndex = remapCanvasPageIndexForMove(canvasSelectionAnchorIndex, safeFrom, insertAt);
    normalizeCanvasPageSelections({ ensureCurrent: true });

    refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: true });
    await switchToCanvasPage(currentPageIndex, { fitView: false, skipSave: true, suppressHistory: true });
    requestSaveState();
    return true;
}

async function addCanvasPage(insertAt = documentPages.length, sourceSize = null) {
    ensureDocumentPagesIntegrity();
    syncCurrentPageStateFromCanvas();
    const safeInsertAt = Math.max(0, Math.min(documentPages.length, parseInt(insertAt, 10) || 0));
    const seedW = parsePositiveInt(
        sourceSize?.width,
        parsePositiveInt(generalPageSize.width, DEFAULT_PAGE_WIDTH)
    );
    const seedH = parsePositiveInt(
        sourceSize?.height,
        parsePositiveInt(generalPageSize.height, DEFAULT_PAGE_HEIGHT)
    );
    const newPage = createBlankPageState(safeInsertAt, seedW, seedH);
    documentPages.splice(safeInsertAt, 0, newPage);
    if (safeInsertAt <= currentPageIndex) currentPageIndex += 1;
    shiftCanvasPageSelectionForInsert(safeInsertAt);
    setCanvasPageSelection([safeInsertAt], { ensureCurrent: false });
    canvasSelectionAnchorIndex = safeInsertAt;
    refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: true });
    await switchToCanvasPage(safeInsertAt, { fitView: false, skipSave: true, suppressHistory: true });
    requestSaveState();
}

async function duplicateCanvasPage(sourceIndex = currentPageIndex) {
    ensureDocumentPagesIntegrity();
    syncCurrentPageStateFromCanvas();
    const safeSourceIndex = Math.max(0, Math.min(documentPages.length - 1, parseInt(sourceIndex, 10) || 0));
    if (!documentPages[safeSourceIndex]) return;

    const clone = deepClone(documentPages[safeSourceIndex]);
    clone.id = createUid('page');
    clone.title = `${clone.title || `Page ${safeSourceIndex + 1}`} Copy`;
    const insertAt = safeSourceIndex + 1;
    documentPages.splice(insertAt, 0, normalizePageState(clone, insertAt));
    if (insertAt <= currentPageIndex) currentPageIndex += 1;
    shiftCanvasPageSelectionForInsert(insertAt);
    setCanvasPageSelection([insertAt], { ensureCurrent: false });
    canvasSelectionAnchorIndex = insertAt;
    refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: true });
    await switchToCanvasPage(insertAt, { fitView: false, skipSave: true, suppressHistory: true });
    requestSaveState();
}

async function deleteCanvasPage(targetIndex = currentPageIndex) {
    ensureDocumentPagesIntegrity();
    if (documentPages.length <= 1) return;
    const safeTargetIndex = Math.max(0, Math.min(documentPages.length - 1, parseInt(targetIndex, 10) || 0));
    const label = safeTargetIndex + 1;
    if (!confirm(`Delete canvas ${label}?`)) return;

    syncCurrentPageStateFromCanvas();

    documentPages.splice(safeTargetIndex, 1);
    if (!documentPages.length) {
        documentPages = [createBlankPageState(0, generalPageSize.width, generalPageSize.height)];
    }

    if (safeTargetIndex < currentPageIndex) currentPageIndex = Math.max(0, currentPageIndex - 1);
    if (safeTargetIndex === currentPageIndex) currentPageIndex = Math.max(0, currentPageIndex - 1);
    if (currentPageIndex > documentPages.length - 1) currentPageIndex = documentPages.length - 1;
    shiftCanvasPageSelectionForDelete(safeTargetIndex);

    refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: true });
    await switchToCanvasPage(currentPageIndex, { fitView: false, skipSave: true, suppressHistory: true });
    requestSaveState();
}

async function setDocumentPagesFromTemplate(templateData = {}, options = {}) {
    const normalized = normalizeTemplatePages(templateData);
    documentPages = normalized.pages;
    generalPageSize = getMostCommonPageSize();
    syncGeneralPageSizeInputs();
    currentPageIndex = typeof options.selectedIndex === 'number'
        ? Math.min(documentPages.length - 1, Math.max(0, options.selectedIndex))
        : normalized.selectedIndex;
    setCanvasPageSelection([currentPageIndex], { ensureCurrent: false });
    canvasSelectionAnchorIndex = currentPageIndex;
    await switchToCanvasPage(currentPageIndex, {
        fitView: options.fitView !== false,
        skipSave: true,
        suppressHistory: true
    });
}

window.createLemonSqueezy();
LemonSqueezy.Setup({ eventHandler: (event) => { if (event.event === 'Checkout.Success') console.log('Checkout successful!', event.data); } });

// --- DEBOUNCE UTILITY ---
function debounce(func, delay = 1500) {
    let timeout = null;
    let lastArgs = null;
    let lastThis = null;
    const debounced = function (...args) {
        lastArgs = args;
        lastThis = this;
        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(() => {
            timeout = null;
            const argsToUse = lastArgs || [];
            const thisToUse = lastThis;
            lastArgs = null;
            lastThis = null;
            func.apply(thisToUse, argsToUse);
        }, delay);
    };
    debounced.clear = () => {
        if (timeout) clearTimeout(timeout);
        timeout = null;
        lastArgs = null;
        lastThis = null;
    };
    debounced.flush = () => {
        if (!timeout) return false;
        clearTimeout(timeout);
        timeout = null;
        const argsToUse = lastArgs || [];
        const thisToUse = lastThis;
        lastArgs = null;
        lastThis = null;
        func.apply(thisToUse, argsToUse);
        return true;
    };
    debounced.pending = () => !!timeout;
    return debounced;
}

const escapeHtml = (str) => {
    if (typeof str !== 'string') return str;
    return str.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
};

function renderCsvView(filterText = '') {
    const wrap = $('#csvViewContent');
    const dropZone = $('#csvDropZone');
    const meta = $('#csvViewMeta');
    if (!wrap) return;

    if (!headers || headers.length === 0 || !dataRows || dataRows.length === 0) {
        wrap.style.display = 'none';
        if (dropZone) dropZone.style.display = 'flex';
        if (meta) meta.textContent = '';
        return;
    }

    if (dropZone) dropZone.style.display = 'none';
    wrap.style.display = 'block';

    const q = (filterText || '').toLowerCase().trim();
    const visibleIndices = [];
    dataRows.forEach((r, i) => {
        if (!q || headers.some(h => String(r[h] ?? '').toLowerCase().includes(q))) visibleIndices.push(i);
    });

    if (meta) meta.textContent = `${dataRows.length.toLocaleString()} row(s) • ${headers.length} column(s)`;

    const maxRows = Math.min(200, visibleIndices.length);
    let html = `<table style="width:100%; border-collapse:collapse; font-size:12px; border-style: hidden;">`;

    // Headers
    html += '<thead><tr>';
    headers.forEach((h, i) => {
        html += `<th style="position:sticky; top:0; background:var(--panel-2); border-bottom:1px solid var(--border); border-right:1px solid var(--border); padding:0; text-align:left; min-width:140px; z-index: 10;">
        <div style="display:flex; align-items:center; group">
          <div contenteditable="true" onblur="updateHeader(${i}, this.innerText)" style="flex:1; padding:12px; outline:none; font-weight: 600; color: var(--fg); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${escapeHtml(String(h))}</div>
          <button onclick="deleteColumn(${i})" style="background:none; border:none; color:var(--muted); cursor:pointer; padding:8px 12px; font-size:16px; transition: color 0.2s;" onmouseover="this.style.color='var(--danger)'" onmouseout="this.style.color='var(--muted)'" title="Delete Column">&times;</button>
        </div>
      </th>`;
    });
    // Add column button in header
    html += `<th style="position:sticky; top:0; background:var(--panel-2); border-bottom:1px solid var(--border); width:50px; text-align:center; z-index: 10;">
    <button onclick="document.getElementById('addColBtn').click()" class="btn ghost" style="width:32px; height:32px; padding:0; border-radius:50%; border: 1px dashed var(--border); color: var(--muted);" title="Add Column">+</button>
  </th>`;
    html += '</tr></thead>';

    html += '<tbody>';
    for (let i = 0; i < maxRows; i++) {
        const dataIndex = visibleIndices[i];
        const row = dataRows[dataIndex] || {};
        html += `<tr style="transition: background 0.1s;" onmouseover="this.style.background='rgba(59,130,246,0.03)'" onmouseout="this.style.background='transparent'">` + headers.map((h, colIndex) => {
            const val = escapeHtml(String(row[h] ?? ''));
            return `<td contenteditable="true" 
            data-row-index="${dataIndex}" data-col-index="${colIndex}"
            onblur="updateCsvCell(${dataIndex}, '${escapeHtml(h)}', this.innerText)" 
            style="border-bottom:1px solid var(--border); border-right:1px solid var(--border); padding:10px 12px; color:var(--fg); outline:none; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; cursor: text; user-select: text;">${val}</td>`;
        }).join('') + `
      <td style="border-bottom:1px solid var(--border); text-align:center;">
        <button onclick="deleteRow(${dataIndex})" style="background:none; border:none; color:var(--muted); cursor:pointer; font-size:18px; padding: 4px 10px; transition: color 0.2s;" onmouseover="this.style.color='var(--danger)'" onmouseout="this.style.color='var(--muted)'" title="Delete Row">&times;</button>
      </td>
    </tr>`;
    }

    // Last row for "Add Row" button
    html += `<tr>
    <td colspan="${headers.length}" style="padding: 0; border-bottom:1px solid var(--border);">
      <button onclick="document.getElementById('addRowBtn').click()" style="width:100%; height:44px; background:transparent; border:none; color:var(--muted); cursor:pointer; font-size:13px; font-weight:500; transition: all 0.2s; display: flex; align-items:center; justify-content:center; gap: 8px;" onmouseover="this.style.background='rgba(59,130,246,0.05)'; this.style.color='var(--accent)'" onmouseout="this.style.background='transparent'; this.style.color='var(--muted)'"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg> Add Row</button>
    </td>
    <td style="border-bottom:1px solid var(--border);"></td>
  </tr>`;

    html += '</tbody></table>';

    if (visibleIndices.length > maxRows) {
        html += `<div class="muted" style="padding:16px; text-align:center; background: var(--panel); border-top: 1px solid var(--border);">Showing first ${maxRows} rows of ${visibleIndices.length.toLocaleString()}. Use search to refine.</div>`;
    }
    wrap.innerHTML = html;

    // Add paste listener for Excel support
    wrap.querySelectorAll('td[contenteditable="true"]').forEach(cell => {
        cell.addEventListener('paste', handleCsvCellPaste);
    });
}

async function handleCsvCellPaste(e) {
    const text = e.clipboardData.getData('text/plain');
    if (!text || (!text.includes('\t') && !text.includes('\n'))) return;

    e.preventDefault();
    const rows = text.split(/\r?\n/).filter(line => line.length > 0).map(line => line.split('\t'));
    const startCell = e.target;
    const startRowIndex = parseInt(startCell.dataset.rowIndex);
    const startColIndex = parseInt(startCell.dataset.colIndex);

    if (isNaN(startRowIndex) || isNaN(startColIndex)) return;

    rows.forEach((row, rOffset) => {
        const targetRowIndex = startRowIndex + rOffset;
        if (targetRowIndex >= dataRows.length) return;

        row.forEach((value, cOffset) => {
            const targetColIndex = startColIndex + cOffset;
            if (targetColIndex >= headers.length) return;
            const colKey = headers[targetColIndex];
            dataRows[targetRowIndex][colKey] = value.trim();
        });
    });

    renderCsvView($('#csvViewSearch')?.value);
    requestSaveState();
}

window.updateCsvCell = (rowIndex, colKey, newVal) => {
    if (dataRows[rowIndex]) {
        dataRows[rowIndex][colKey] = newVal;
        requestSaveState();
    }
};

window.updateHeader = (index, newVal) => {
    const oldVal = headers[index];
    if (oldVal === newVal || !newVal.trim()) return;
    newVal = newVal.trim();
    headers[index] = newVal;
    dataRows.forEach(row => {
        row[newVal] = row[oldVal];
        delete row[oldVal];
    });
    bindings.forEach((b) => { if (b.column === oldVal) b.column = newVal; });
    renderCsvView();
    requestSaveState();
};

window.deleteRow = (index) => {
    dataRows.splice(index, 1);
    renderCsvView($('#csvViewSearch')?.value);
    requestSaveState();
};

window.deleteColumn = (index) => {
    const colName = headers[index];
    if (confirm(`Delete column "${colName}" and all its data?`)) {
        headers.splice(index, 1);
        dataRows.forEach(row => delete row[colName]);
        // Also remove bindings
        bindings.forEach((bArr, oid) => {
            const filtered = bArr.filter(b => b.column !== colName);
            bindings.set(oid, filtered);
        });
        renderCsvView($('#csvViewSearch')?.value);
        requestSaveState();
    }
};

on('#addRowBtn', 'click', () => {
    if (!headers.length) headers = ['Column 1', 'Column 2', 'Column 3'];
    const newRow = {};
    headers.forEach(h => newRow[h] = '');
    dataRows.push(newRow);
    renderCsvView($('#csvViewSearch')?.value);
    requestSaveState();
});

on('#addColBtn', 'click', () => {
    const newColName = prompt('Enter new column name:', `Column ${headers.length + 1}`);
    if (!newColName) return;
    if (headers.includes(newColName)) { alert('Column already exists.'); return; }
    headers.push(newColName);
    dataRows.forEach(r => r[newColName] = '');
    renderCsvView($('#csvViewSearch')?.value);
    requestSaveState();
});

on('#clearDataBtn', 'click', () => {
    if (confirm('Are you sure you want to clear all data? This will also remove your column headers.')) {
        headers = [];
        dataRows = [];
        renderCsvView();
        requestSaveState();
    }
});

on('#csvViewSearch', 'input', (e) => {
    renderCsvView(e.target.value);
});

// Paste Handler for CSV Modal
window.addEventListener('paste', (e) => {
    if ($('#csvViewModal').style.display !== 'flex') return;
    if (e.target.tagName === 'INPUT' || e.target.contentEditable === 'true') return;

    e.preventDefault();
    const clipboardData = e.clipboardData || window.clipboardData;
    const pastedData = clipboardData.getData('Text');
    if (!pastedData) return;

    const rows = pastedData.trim().split('\n').map(r => r.split('\t'));
    if (rows.length === 0) return;

    if (headers.length === 0) {
        headers = rows[0].map((h, i) => h.trim() || `Col ${i + 1}`);
        const count = {};
        headers = headers.map(h => { count[h] = (count[h] || 0) + 1; return count[h] > 1 ? `${h}_${count[h]}` : h; });
        rows.shift();
    }

    rows.forEach(r => {
        const rowObj = {};
        headers.forEach((h, i) => { rowObj[h] = r[i] ? r[i].trim() : ''; });
        dataRows.push(rowObj);
    });

    renderCsvView($('#csvViewSearch')?.value);
    requestSaveState();
    showNotification(`Imported ${rows.length} rows from clipboard.`);
});

// Drag & Drop Handler for CSV Modal
on('#csvViewModal', 'dragover', (e) => {
    e.preventDefault();
    $('#csvDropZone').style.borderColor = 'var(--accent)';
    $('#csvDropZone').style.background = 'rgba(59, 130, 246, 0.05)';
});
on('#csvViewModal', 'dragleave', (e) => {
    e.preventDefault();
    $('#csvDropZone').style.borderColor = 'var(--border)';
    $('#csvDropZone').style.background = 'rgba(255, 255, 255, 0.02)';
});
on('#csvViewModal', 'drop', async (e) => {
    e.preventDefault();
    $('#csvDropZone').style.borderColor = 'var(--border)';
    $('#csvDropZone').style.background = 'rgba(255, 255, 255, 0.02)';
    const file = e.dataTransfer.files[0];
    if (file && (file.name.endsWith('.csv') || file.name.endsWith('.xlsx') || file.name.endsWith('.xls'))) {
        const data = await file.arrayBuffer();
        processFileData(data, file.name);
        await cacheDataFile(file);
    } else {
        showNotification('Please drop a valid CSV or Excel file.', 'error');
    }
});

function openCsvView() {
    const modal = $('#csvViewModal');
    if (!modal) return;
    modal.style.display = 'flex';
    renderCsvView($('#csvViewSearch')?.value);
}

function closeCsvView() { $('#csvViewModal').style.display = 'none'; }


// components/02-auth-and-session.js
// --- AUTH & DATA LOADING ---
async function initializeEditor() {
    applyTheme(localStorage.getItem('csvlink-theme') || 'light');
    const { data: { session } } = await supabase.auth.getSession();
    currentUser = session?.user;

    const navLinks = $('#nav-links');
    if (currentUser) {
        const { data: profile } = await supabase.from('profiles').select('role').eq('id', currentUser.id).single();
        if (profile) userRole = profile.role || 'free';
        // 6. Add "Become Pro" button
        if (userRole === 'free' && !navLinks.querySelector('a[href="/#pricing"]')) {
            const proButton = document.createElement('a');
            proButton.href = '/#pricing';
            proButton.className = 'btn ghost';
            proButton.innerHTML = '★ Pricing';
            navLinks.insertBefore(proButton, navLinks.firstChild);
        }
    } else {
        if (!navLinks.querySelector('a[href="/#pricing"]')) {
            const proButton = document.createElement('a');
            proButton.href = '/#pricing';
            proButton.className = 'btn ghost';
            proButton.innerHTML = '★ Pricing';
            navLinks.insertBefore(proButton, navLinks.firstChild);
        }
    }
    updateExportUI();

    const urlParams = new URLSearchParams(window.location.search);
    const templateId = urlParams.get('id');

    initializeCanvas();
    updateHistoryButtons();
    initializeVisualCropper();
    renderPageInspector();
    await loadCachedData();

    const guestTemplate = localStorage.getItem('csvlink-guest-template');

    /* 1) PRIORITY: Template ID from URL always wins */
    if (templateId) {
        await loadTemplateFromDB(templateId);
        centerAndFitPage();
    }

    /* 2) User logged in â†’ try restore guest work */
    else if (currentUser && guestTemplate) {
        try {
            const template = JSON.parse(guestTemplate);
            $('#titleInput').value = template.title || template.page?.title || 'Untitled_Template';
            if (template.data) {
                headers = template.data.headers || [];
                dataRows = template.data.rows || [];
            }
            await setDocumentPagesFromTemplate(template, { fitView: true });
            historyStack = [];
            historyIndex = -1;
            lastHistorySig = null;
            renderCsvView();
            updateExportUI();
            pendingGuestTemplateRestore = true;
            requestSaveState();
            saveStatusEl.textContent = 'Restored from guest session. Saving...';
        } catch (err) {
            console.error('Failed to restore guest template:', err);
        }
    }

    /* 3) Guest user with no templateId â†’ autosave guest mode */
    else if (!currentUser) {
        showGuestWarning();
        centerAndFitPage();
        setInterval(saveGuestTemplate, 10000);
    }

    /* 4) Logged in user, blank editor */
    else {
        centerAndFitPage();
    }

    /* Other UI initialization */
    if (!localStorage.getItem('hasSeenTour')) startTour();
    initializeLeftPanelTabs();

    // Bind Load Template buttons
    const bindLoader = (id) => on(id, 'click', (e) => toggleTemplateLoader(e.currentTarget));
    bindLoader('#loadTemplateBtnPage');
    bindLoader('#openLoaderFromSidebar');
    bindLoader('#toolbarLoadTemplateBtn');
}

function showGuestWarning() { saveStatusEl.textContent = "Log in to save your work."; saveStatusEl.style.color = '#ff9800'; }

function saveGuestTemplate() {
    if (currentUser) return; // Only save if guest
    const payload = buildTemplatePayload();
    const hasAnyContent = payload.pages.some(page => pageHasRenderableObjects(page));
    if (!hasAnyContent) return;

    const guestTemplate = {
        title: $('#titleInput').value,
        ...payload
    };

    try {
        localStorage.setItem('csvlink-guest-template', JSON.stringify(guestTemplate));
        saveStatusEl.textContent = "Guest work auto-saved locally. Log in to save to cloud.";
    } catch (err) {
        console.error('Failed to save guest template:', err);
    }
}
async function loadTemplateFromDB(templateId, options = {}) {
    saveStatusEl.textContent = 'Loading...';
    const isPublic = options.public;
    let data = null;

    if (isPublic) {
        const { data: publicData, error: publicError } = await supabase.from('public_templates').select('id, title, template_data').eq('id', templateId).single();
        if (publicError) { console.error('Error loading public template:', publicError); return; }
        data = publicData;
        currentTemplateId = null;
    } else {
        if (!currentUser) { return; }
        const sourceTable = options.purchased ? 'purchased_templates' : 'templates';
        const query = options.purchased
            ? supabase.from(sourceTable).select('store_templates(id, title, template_data)').eq('user_id', currentUser.id).eq('template_id', templateId).single()
            : supabase.from(sourceTable).select('id, title, template_data').eq('id', templateId).eq('user_id', currentUser.id).single();

        const { data: privateData, error: privateError } = await query;

        if (privateError) { console.error('Error or template not found:', privateError); return; }
        data = options.purchased ? privateData.store_templates : privateData;
        currentTemplateId = options.purchased ? null : data.id;
    }

    if (data && data.template_data) {
        const template = data.template_data;
        if (template.data) {
            headers = template.data.headers || [];
            dataRows = template.data.rows || [];
            identifierColumn = template.data.identifierColumn || '';
            refreshIdentifierDropdown();
        }
        $('#titleInput').value = isPublic || options.purchased
            ? `Copy of ${data.title}`
            : (data.title || template.page?.title || 'Untitled Template');
        await setDocumentPagesFromTemplate(template, { fitView: true, selectedIndex: template.currentPageIndex });
        bindings = new Map(documentPages[currentPageIndex]?.bindings || template.bindings || []);
        historyStack = [];
        historyIndex = -1;
        lastHistorySig = null;
        requestSaveState();
        renderCsvView();
        updateExportUI();
        if (headers.length > 0) {
            $('#fileName').textContent = 'Saved Data';
            $('#unloadDataBtn').style.display = 'inline';
        }
        saveStatusEl.textContent = 'Template loaded.';
    }
}


const debouncedSave = debounce(async () => {
    if (!currentUser || historyLocked) return;
    const fullTemplateData = buildTemplatePayload();
    if (!fullTemplateData.pages.some(page => pageHasRenderableObjects(page))) {
        saveStatusEl.textContent = 'Cannot save empty template.';
        return;
    }

    saveStatusEl.textContent = 'Saving...';

    if (currentTemplateId) {
        const { error } = await supabase.from('templates').update({ title: $('#titleInput').value, template_data: fullTemplateData }).eq('id', currentTemplateId);
        if (error) { saveStatusEl.textContent = 'Error saving.'; } else { saveStatusEl.textContent = 'All changes saved.'; }
    } else {
        if (userRole === 'free') { const { count } = await supabase.from('templates').select('*', { count: 'exact', head: true }).eq('user_id', currentUser.id); if (count >= 5) { saveStatusEl.textContent = 'Free account limit (5 templates) reached.'; return; } }
        const { data, error } = await supabase.from('templates').insert({ user_id: currentUser.id, title: $('#titleInput').value, template_data: fullTemplateData }).select('id').single();
        if (error) { saveStatusEl.textContent = 'Error creating template.'; }
        else {
            currentTemplateId = data.id;
            if (pendingGuestTemplateRestore) {
                localStorage.removeItem('csvlink-guest-template');
                pendingGuestTemplateRestore = false;
            }
            const newUrl = `${window.location.pathname}?id=${currentTemplateId}`;
            window.history.replaceState({ path: newUrl }, '', newUrl);
            saveStatusEl.textContent = 'Template saved to your account.';
        }
    }
});

function flushPendingSaves() {
    if (typeof requestSaveState.flush === 'function') requestSaveState.flush();
    if (currentUser && typeof debouncedSave.flush === 'function') debouncedSave.flush();
}

document.addEventListener('visibilitychange', () => {
    if (document.visibilityState !== 'hidden') return;
    commitPendingLineEndpointEdits();
    flushPendingSaves();
});
window.addEventListener('pagehide', () => {
    commitPendingLineEndpointEdits();
    flushPendingSaves();
});

function updateHistoryButtons() {
    const undoBtn = $('#undoBtn');
    const redoBtn = $('#redoBtn');
    if (undoBtn) undoBtn.disabled = historyIndex <= 0;
    if (redoBtn) redoBtn.disabled = historyIndex >= historyStack.length - 1;
}

function undo() {
    if (historyLocked) return;
    if (typeof requestSaveState.flush === 'function') requestSaveState.flush();
    if (historyIndex <= 0 || historyLocked) return;
    if (typeof requestSaveState.clear === 'function') requestSaveState.clear();
    historyLocked = true;
    isRestoringHistory = true;
    historyIndex--;
    const state = historyStack[historyIndex];

    // Safety timeout to prevent lockup
    const lockTimeout = setTimeout(() => {
        historyLocked = false;
        isRestoringHistory = false;
    }, 3000);

    restoreFullState(state, () => {
        clearTimeout(lockTimeout);
        historyLocked = false;
        setTimeout(() => { isRestoringHistory = false; }, 0);
        updateHistoryButtons();
    });
}

function redo() {
    if (historyLocked) return;
    if (historyIndex >= historyStack.length - 1 || historyLocked) return;
    if (typeof requestSaveState.clear === 'function') requestSaveState.clear();
    historyLocked = true;
    isRestoringHistory = true;
    historyIndex++;
    const state = historyStack[historyIndex];

    // Safety timeout to prevent lockup
    const lockTimeout = setTimeout(() => {
        historyLocked = false;
        isRestoringHistory = false;
    }, 3000);

    restoreFullState(state, () => {
        clearTimeout(lockTimeout);
        historyLocked = false;
        setTimeout(() => { isRestoringHistory = false; }, 0);
        updateHistoryButtons();
    });
}

function restoreFullState(state, callback) {
    if (!state) {
        if (typeof callback === 'function') callback();
        return;
    }
    headers = [...(state.data?.headers || [])];
    dataRows = JSON.parse(JSON.stringify(state.data?.rows || []));
    identifierColumn = state.data?.identifierColumn || '';
    if (state.title !== undefined) $('#titleInput').value = state.title;

    const legacyState = {
        page: {
            title: state.title || $('#titleInput').value,
            width: state.page?.width || DEFAULT_PAGE_WIDTH,
            height: state.page?.height || DEFAULT_PAGE_HEIGHT
        },
        canvas: state.canvas,
        bindings: state.bindings || []
    };

    const payload = state.pages
        ? {
            page: legacyState.page,
            pages: state.pages,
            currentPageIndex: state.currentPageIndex || 0
        }
        : legacyState;

    setDocumentPagesFromTemplate(payload, {
        fitView: false,
        selectedIndex: state.currentPageIndex || 0
    }).then(() => {
        bindings = new Map(documentPages[currentPageIndex]?.bindings || state.bindings || []);
        renderLayers();
        renderCsvView();
        updateExportUI();

        lastHistorySig = JSON.stringify(state);
        if (typeof callback === 'function') callback();
    }).catch((error) => {
        console.error('Failed to restore history state:', error);
        if (typeof callback === 'function') callback();
    });
}

const requestSaveState = debounce(() => {
    if (historyLocked || isRestoringHistory) return;
    syncCurrentPageStateFromCanvas();
    if (!documentPages.length) return;

    const activePage = documentPages[currentPageIndex];
    const snap = {
        canvas: deepClone(activePage.canvas),
        data: {
            headers: [...headers],
            rows: JSON.parse(JSON.stringify(dataRows)),
            identifierColumn: identifierColumn || ''
        },
        bindings: deepClone(activePage.bindings || Array.from(bindings.entries())),
        pages: deepClone(documentPages),
        currentPageIndex,
        title: $('#titleInput').value,
        page: { width: activePage.width, height: activePage.height }
    };

    const sig = JSON.stringify(snap);
    if (sig === lastHistorySig) {
        updateHistoryButtons();
        return;
    }

    if (historyIndex < historyStack.length - 1) {
        historyStack.splice(historyIndex + 1);
    }

    lastHistorySig = sig;
    historyStack.push(snap);
    const MAX_HISTORY = 40;
    if (historyStack.length > MAX_HISTORY) {
        historyStack.shift();
    }
    historyIndex = historyStack.length - 1;
    updateHistoryButtons();

    if (currentUser) {
        saveStatusEl.textContent = 'Unsaved changes...';
        debouncedSave();
    }

    // Persist data edits to localStorage for session persistence
    cacheLocalDataState();
}, 500);

function commitPendingLineEndpointEdits() {
    let hadPendingEndpointEdit = false;
    canvas.getObjects('line').forEach(line => {
        if (line && line._endpointDragDirty) {
            delete line._endpointDragDirty;
            hadPendingEndpointEdit = true;
        }
    });
    if (!hadPendingEndpointEdit) return;
    requestSaveState();
    if (typeof requestSaveState.flush === 'function') requestSaveState.flush();
    if (currentUser && typeof debouncedSave.flush === 'function') debouncedSave.flush();
}

const ROTATION_SNAP_DEGREES = 45;
const SELECTION_HANDLE_LENGTH = 20;
const SELECTION_HANDLE_THICKNESS = 6;
const SELECTION_ROTATE_HANDLE_SIZE = 20;
const SELECTION_BORDER_SCALE = 1;
const ROTATION_ICON_VIEWBOX = 24;
const ROTATION_ICON_STROKE_WIDTH = 1.5;
const ROTATION_ICON_PATH_DATA = 'M20.4898 14.9907C19.8414 16.831 18.6124 18.4108 16.9879 19.492C15.3635 20.5732 13.4316 21.0972 11.4835 20.9851C9.5353 20.873 7.67634 20.1308 6.18668 18.8704C4.69703 17.61 3.65738 15.8996 3.22438 13.997C2.79138 12.0944 2.98849 10.1026 3.78602 8.32177C4.58354 6.54091 5.93827 5.06746 7.64608 4.12343C9.35389 3.17941 11.3223 2.81593 13.2546 3.08779C16.5171 3.54676 18.6725 5.91142 21 8M21 8V2M21 8H15';
const ROTATION_ICON_PATH = typeof Path2D !== 'undefined' ? new Path2D(ROTATION_ICON_PATH_DATA) : null;

function drawRoundedRectPath(ctx, x, y, width, height, radius) {
    const r = Math.max(0, Math.min(radius, width / 2, height / 2));
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + width - r, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + r);
    ctx.lineTo(x + width, y + height - r);
    ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
    ctx.lineTo(x + r, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

function getControlRotationRadians(fabricObject) {
    let angleDeg = 0;
    if (fabricObject && typeof fabricObject.getTotalAngle === 'function') {
        angleDeg = fabricObject.getTotalAngle();
    } else if (fabricObject && Number.isFinite(fabricObject.angle)) {
        angleDeg = fabricObject.angle;
    }
    return fabric.util.degreesToRadians(Number.isFinite(angleDeg) ? angleDeg : 0);
}

function renderSelectionSideHandle(isHorizontal) {
    return function drawControl(ctx, left, top, styleOverride = {}, fabricObject) {
        const width = isHorizontal ? SELECTION_HANDLE_LENGTH : SELECTION_HANDLE_THICKNESS;
        const height = isHorizontal ? SELECTION_HANDLE_THICKNESS : SELECTION_HANDLE_LENGTH;
        const strokeColor = styleOverride.cornerColor || fabricObject?.borderColor || '#000000';

        ctx.save();
        ctx.translate(left, top);
        ctx.rotate(getControlRotationRadians(fabricObject));
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 1.25;
        drawRoundedRectPath(ctx, -width / 2, -height / 2, width, height, Math.min(width, height) / 2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    };
}

function renderSelectionRotateHandle(ctx, left, top, styleOverride = {}, fabricObject) {
    const strokeColor = styleOverride.cornerColor || fabricObject?.borderColor || '#000000';

    ctx.save();
    ctx.translate(left, top);
    ctx.rotate(getControlRotationRadians(fabricObject));
    ctx.strokeStyle = strokeColor;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    if (ROTATION_ICON_PATH) {
        const iconSize = SELECTION_ROTATE_HANDLE_SIZE;
        const scale = iconSize / ROTATION_ICON_VIEWBOX;
        ctx.translate(-iconSize / 2, -iconSize/2);
        ctx.scale(scale, scale);
        ctx.lineWidth = ROTATION_ICON_STROKE_WIDTH;
        ctx.stroke(ROTATION_ICON_PATH);
    } else {
        // Fallback for environments without Path2D support.
        ctx.fillStyle = strokeColor;
        ctx.font = `bold ${Math.round(SELECTION_ROTATE_HANDLE_SIZE * 0.7)}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('\u21bb', 0, 0);
    }
    ctx.restore();
}

function configureSelectionControls() {
    const controlSets = [
        fabric?.Object?.prototype?.controls,
        fabric?.ActiveSelection?.prototype?.controls,
        fabric?.Textbox?.prototype?.controls,
        fabric?.IText?.prototype?.controls,
        fabric?.Text?.prototype?.controls
    ].filter(Boolean).filter((controls, index, list) => list.indexOf(controls) === index);
    if (!controlSets.length) return;

    const setSideHandleStyle = (controls, key, isHorizontal) => {
        const control = controls[key];
        if (!control) return;
        control.render = renderSelectionSideHandle(isHorizontal);
        control.sizeX = isHorizontal ? SELECTION_HANDLE_LENGTH : SELECTION_HANDLE_THICKNESS;
        control.sizeY = isHorizontal ? SELECTION_HANDLE_THICKNESS : SELECTION_HANDLE_LENGTH;
        control.touchSizeX = Math.max(control.sizeX, 18);
        control.touchSizeY = Math.max(control.sizeY, 18);
        control.withConnection = false;
    };

    controlSets.forEach(controls => {
        setSideHandleStyle(controls, 'mt', true);
        setSideHandleStyle(controls, 'mb', true);
        setSideHandleStyle(controls, 'ml', false);
        setSideHandleStyle(controls, 'mr', false);

        const rotateControl = controls.mtr;
        if (!rotateControl) return;
        rotateControl.render = renderSelectionRotateHandle;
        rotateControl.sizeX = SELECTION_ROTATE_HANDLE_SIZE;
        rotateControl.sizeY = SELECTION_ROTATE_HANDLE_SIZE;
        rotateControl.touchSizeX = SELECTION_ROTATE_HANDLE_SIZE + 8;
        rotateControl.touchSizeY = SELECTION_ROTATE_HANDLE_SIZE + 8;
        rotateControl.offsetY = -30;
        rotateControl.withConnection = true;
    });
}

function snapAngleToNearestIncrement(angle, increment = ROTATION_SNAP_DEGREES) {
    if (!Number.isFinite(angle)) return angle;
    if (!Number.isFinite(increment) || increment <= 0) return angle;
    return Math.round(angle / increment) * increment;
}

function applyRotationSnapOnShift(options) {
    if (!options?.e?.shiftKey) return;
    const target = options?.target;
    if (!target || !Number.isFinite(target.angle)) return;
    const snappedAngle = snapAngleToNearestIncrement(target.angle);
    if (!Number.isFinite(snappedAngle) || Math.abs(snappedAngle - target.angle) < 0.0001) return;
    target.set('angle', snappedAngle);
    target.setCoords();
}

// --- CANVAS & PAGE SETUP ---
function initializeCanvas() {
    configureSelectionControls();
    fabric.Object.prototype.set({ transparentCorners: false, cornerStyle: 'circle', cornerColor: '#000000', cornerSize: 10, borderColor: '#000000', borderScaleFactor: SELECTION_BORDER_SCALE, padding: 0, strokeUniform: true });
    fabric.ActiveSelection.prototype.set({ cornerStyle: 'circle', cornerColor: '#000000', borderColor: 'black', borderScaleFactor: SELECTION_BORDER_SCALE, padding: 0 });
    const resizeCanvas = () => {
        const { width, height } = canvasWrapper.getBoundingClientRect();
        canvas.setWidth(width);
        canvas.setHeight(height);
        clampViewportTransform(canvas.viewportTransform);
        canvas.renderAll();
    };
    pageRect = new fabric.Rect({
        left: 0,
        top: 0,
        width: DEFAULT_PAGE_WIDTH,
        height: DEFAULT_PAGE_HEIGHT,
        fill: '#fff',
        stroke: 'rgba(0,0,0,0.25)',
        strokeWidth: 1,
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
        lockMovementX: true,
        lockMovementY: true,
        lockScalingX: true,
        lockScalingY: true,
        lockRotation: true,
        oid: 'pageRect',
        isArtboard: true
    });
    canvas.add(pageRect);
    resizeCanvas();
    drawGrid();
    new ResizeObserver(resizeCanvas).observe(canvasWrapper);

    documentPages = [normalizePageState({
        id: createUid('page'),
        title: 'Page 1',
        width: DEFAULT_PAGE_WIDTH,
        height: DEFAULT_PAGE_HEIGHT,
        canvas: canvas.toJSON(SERIALIZE_PROPS),
        bindings: []
    }, 0)];
    currentPageIndex = 0;
    setCanvasPageSelection([0], { ensureCurrent: false });
    canvasSelectionAnchorIndex = 0;
    generalPageSize = getMostCommonPageSize();
    syncGeneralPageSizeInputs();
    refreshCanvasPageControls({ preserveScroll: false, ensureActiveVisible: true });
    isCanvasPagesPanelCollapsed = false;
    applyCanvasPagesPanelState();
    initPageActionToolbar();
    const toggleCanvasPagesPanel = (event) => {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        isCanvasPagesPanelCollapsed = !isCanvasPagesPanelCollapsed;
        applyCanvasPagesPanelState();
    };
    if (toggleCanvasPagesPanelBtn) {
        toggleCanvasPagesPanelBtn.addEventListener('click', toggleCanvasPagesPanel);
    }
    if (hideCanvasPagesPanelBtn) {
        hideCanvasPagesPanelBtn.addEventListener('click', toggleCanvasPagesPanel);
    }
    if (canvasPagesHeaderRow) {
        canvasPagesHeaderRow.addEventListener('click', (event) => {
            if (event.target instanceof Element && event.target.closest('button')) return;
            toggleCanvasPagesPanel(event);
        });
    }

    const OBJECT_CLICK_DRAG_DEADZONE_PX = 4;
    let pendingObjectClickDrag = null;

    const getPointerClientPoint = (eventData) => {
        if (!eventData) return null;
        if (Number.isFinite(eventData.clientX) && Number.isFinite(eventData.clientY)) {
            return { x: eventData.clientX, y: eventData.clientY };
        }
        const touchPoint = eventData.touches?.[0] || eventData.changedTouches?.[0];
        if (touchPoint && Number.isFinite(touchPoint.clientX) && Number.isFinite(touchPoint.clientY)) {
            return { x: touchPoint.clientX, y: touchPoint.clientY };
        }
        return null;
    };

    const beginObjectClickDragGuard = (options) => {
        const target = options?.target;
        const eventData = options?.e;
        if (!target || target === pageRect || target.selectable === false || target.evented === false) {
            pendingObjectClickDrag = null;
            return;
        }
        if (typeof eventData?.button === 'number' && eventData.button !== 0) {
            pendingObjectClickDrag = null;
            return;
        }
        const clientPoint = getPointerClientPoint(eventData);
        if (!clientPoint) {
            pendingObjectClickDrag = null;
            return;
        }
        pendingObjectClickDrag = {
            target,
            startClientX: clientPoint.x,
            startClientY: clientPoint.y,
            startLeft: normalizeNumeric(target.left, 0),
            startTop: normalizeNumeric(target.top, 0)
        };
    };

    const preventAccidentalObjectNudge = (options) => {
        if (!pendingObjectClickDrag) return false;
        const target = options?.target;
        if (!target || target !== pendingObjectClickDrag.target) {
            pendingObjectClickDrag = null;
            return false;
        }
        const action = options?.transform?.action;
        if (action && action !== 'drag') {
            pendingObjectClickDrag = null;
            return false;
        }
        const clientPoint = getPointerClientPoint(options?.e);
        if (!clientPoint) return false;

        const moveDistance = Math.hypot(
            clientPoint.x - pendingObjectClickDrag.startClientX,
            clientPoint.y - pendingObjectClickDrag.startClientY
        );
        if (moveDistance >= OBJECT_CLICK_DRAG_DEADZONE_PX) {
            pendingObjectClickDrag = null;
            return false;
        }

        target.set({
            left: pendingObjectClickDrag.startLeft,
            top: pendingObjectClickDrag.startTop
        });
        target.setCoords();
        return true;
    };

    canvas.on({
        'mouse:down': (e) => {
            beginObjectClickDragGuard(e);
        },
        'object:added': (e) => {
            if (isRenderingCanvasGhosts || isPageSwitching || !e?.target || e.target.isCanvasGhost) return;
            if (isPastingFromClipboard) return;
            requestSaveState();
            renderLayers();
            refreshCanvasPageControlsDebounced();
        },
        'object:removed': (e) => {
            if (isPageSwitching || isRenderingCanvasGhosts || !e?.target) return;
            if (e.target.isCanvasGhost) {
                // Ghost removals are persisted only on explicit user delete actions.
                return;
            }
            requestSaveState();
            renderLayers();
            refreshCanvasPageControlsDebounced();
        },
        'object:modified': async (e) => {
            pendingObjectClickDrag = null;
            if (isRenderingCanvasGhosts || !e?.target) return;
            isObjectInteractionActive = false;
            if (e.target.type === 'activeSelection' && typeof e.target.getObjects === 'function') {
                const members = e.target.getObjects();
                const hasGhostMembers = members.some(member => member?.isCanvasGhost);
                const hasNonGhostMembers = members.some(member => member && !member.isCanvasGhost);
                const lockGhostToSourcePage = hasGhostMembers && (hasNonGhostMembers || members.length > 1);
                let ghostChanged = false;
                let movedToCurrent = false;

                members.forEach(member => {
                    if (!member) return;
                    if (member.isCanvasGhost) {
                        const result = commitGhostObjectModification(member, { lockToSourcePage: lockGhostToSourcePage });
                        if (result.changed) {
                            ghostChanged = true;
                            if (result.moved && result.targetPageIndex === currentPageIndex) {
                                movedToCurrent = true;
                            }
                        }
                        return;
                    }
                    applyObjectMaskForPage(member, currentPageIndex);
                });

                if (movedToCurrent) {
                    await switchToCanvasPage(currentPageIndex, { fitView: false, skipSave: true, suppressHistory: true });
                    requestSaveState();
                    refreshCanvasPageControlsDebounced();
                    return;
                }
                if (!hasGhostMembers && await maybeReassignObjectToDominantPage(e.target)) return;
                if (ghostChanged) {
                    canvas.discardActiveObject();
                    updateFloatingLinker(null);
                    renderCanvasGhostPages();
                    renderLayers();
                    renderPageInspector();
                }
                scheduleOutsideObjectsCleanup();
                requestSaveState();
                refreshCanvasPageControlsDebounced();
                if (!ghostChanged && e.target) { refreshInspector({ target: e.target }); }
                return;
            }
            if (e.target.isCanvasGhost) {
                const result = commitGhostObjectModification(e.target);
                if (!result.changed) return;
                if (result.moved && result.targetPageIndex === currentPageIndex) {
                    await switchToCanvasPage(currentPageIndex, { fitView: false, skipSave: true, suppressHistory: true });
                    requestSaveState();
                    refreshCanvasPageControlsDebounced();
                    return;
                }
                canvas.discardActiveObject();
                updateFloatingLinker(null);
                renderCanvasGhostPages();
                renderLayers();
                renderPageInspector();
                refreshCanvasPageControlsDebounced();
                requestSaveState();
                return;
            }
            if (await maybeReassignObjectToDominantPage(e?.target)) return;
            applyObjectMaskForPage(e?.target, currentPageIndex);
            scheduleOutsideObjectsCleanup();
            requestSaveState();
            refreshCanvasPageControlsDebounced();
            if (e.target) { refreshInspector({ target: e.target }); }
        },
        'object:moving': (e) => {
            scheduleOutsideObjectsCleanup.clear();
            if (preventAccidentalObjectNudge(e)) {
                clearSnapLines();
                updateFloatingLinkerPosition(e?.target);
                return;
            }
            if (e?.transform?.action !== 'modifyLineEndpoint') handleSmartSnapping(e);
            updateFloatingLinkerPosition(e.target);
        },
        'object:scaling': (e) => {
            scheduleOutsideObjectsCleanup.clear();
            handleResizeSnapping(e);
            const obj = e.target;
            if (obj && obj.type === 'textbox') {
                const newFontSize = Math.round(obj.fontSize * obj.scaleX);
                const newWidth = obj.width * obj.scaleX;
                obj.set({
                    fontSize: newFontSize,
                    width: newWidth,
                    scaleX: 1,
                    scaleY: 1
                });
                refreshTextboxCurve(obj, { skipRender: true });
            }
            updateLiveInspector(e);
            updateFloatingLinkerPosition(e.target);
        },
        'object:rotating': (e) => {
            scheduleOutsideObjectsCleanup.clear();
            applyRotationSnapOnShift(e);
            updateLiveInspector(e);
            updateFloatingLinkerPosition(e.target);
        },
        'text:changed': (e) => {
            const target = e?.target;
            if (target && target.type === 'textbox') {
                refreshTextboxCurve(target, { skipRender: true });
            }
        },
        'mouse:up': () => {
            pendingObjectClickDrag = null;
            clearSnapLines();
            commitPendingLineEndpointEdits();
            scheduleOutsideObjectsCleanup();
        }, // 7. Clear guides on mouse up
        'after:render': () => { updatePageActionToolbarPosition(); }
    });
    styleActivePageRect();
    applyCanvasMaskToActivePageObjects();
    renderCanvasGhostPages();
    updatePageActionToolbarPosition();
    requestSaveState(); renderLayers();
    addWheelPanFix();

    onClick('#undoBtn', undo);
    onClick('#redoBtn', redo);
}

function keepPageRectAtBack() {
    if (!pageRect) return;
    canvas.sendToBack(pageRect);
}

window.addEventListener('paste', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return; const items = e.clipboardData.items; if (!items) return;
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (item.type.indexOf('image') !== -1) { e.preventDefault(); const blob = item.getAsFile(); const reader = new FileReader(); reader.onload = (event) => { const spawn = getDefaultSpawnPoint(); adders.image(spawn.x, spawn.y, event.target.result); }; reader.readAsDataURL(blob); break; }
        if (item.type.indexOf('text/plain') !== -1) { e.preventDefault(); item.getAsString((text) => { const spawn = getDefaultSpawnPoint(); adders.text(spawn.x, spawn.y, text); }); break; }
    }
});
const setPageDimensions = debounce(() => {
    if (!documentPages.length) return;
    const targetWidth = parsePositiveInt($('#pageWidth').value, generalPageSize.width || DEFAULT_PAGE_WIDTH);
    const targetHeight = parsePositiveInt($('#pageHeight').value, generalPageSize.height || DEFAULT_PAGE_HEIGHT);
    const priorWidth = parsePositiveInt(generalPageSize.width, DEFAULT_PAGE_WIDTH);
    const priorHeight = parsePositiveInt(generalPageSize.height, DEFAULT_PAGE_HEIGHT);

    syncCurrentPageStateFromCanvas();

    let changedAny = false;
    let currentChanged = false;
    let layoutAffectsCurrent = false;
    documentPages.forEach((page, index) => {
        if (!page) return;
        if (page.width === priorWidth && page.height === priorHeight) {
            page.width = targetWidth;
            page.height = targetHeight;
            ensurePageRectInCanvasState(page);
            changedAny = true;
            if (index === currentPageIndex) currentChanged = true;
            if (index < currentPageIndex) layoutAffectsCurrent = true;
        }
    });

    generalPageSize = { width: targetWidth, height: targetHeight };
    syncGeneralPageSizeInputs();

    if ((currentChanged || layoutAffectsCurrent) && pageRect) {
        if (currentChanged) {
            pageRect.set({ width: targetWidth, height: targetHeight });
            pageRect.setCoords();
        }
        relocateActiveCanvasToLayout();
        applyCanvasMaskToActivePageObjects();
        drawGrid();
        clampViewportTransform(canvas.viewportTransform);
        canvas.renderAll();
        syncCurrentPageStateFromCanvas();
    }

    if (changedAny) renderCanvasGhostPages();
    refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: false });
    if (changedAny) requestSaveState();
}, 300);
on('#titleInput', 'input', () => { requestSaveState(); }); on('#pageWidth', 'input', setPageDimensions); on('#pageHeight', 'input', setPageDimensions);
function drawGrid() { canvas.remove(...canvas.getObjects('line').filter(o => o.excludeFromExport && !o.isCanvasGhost)); if (!gridEnabled || !pageRect) { canvas.renderAll(); return; } const { width, height, left, top } = pageRect; const gridLines = []; const lineOption = { stroke: 'rgba(0,0,0,0.1)', selectable: false, evented: false, excludeFromExport: true }; const step = gridCellSize; for (let i = 1; i < (width / step); i++) gridLines.push(new fabric.Line([left + i * step, top, left + i * step, top + height], lineOption)); for (let i = 1; i < (height / step); i++) gridLines.push(new fabric.Line([left, top + i * step, left + width, top + i * step], lineOption)); canvas.add(...gridLines); gridLines.forEach(line => canvas.sendToBack(line)); canvas.sendToBack(pageRect); canvas.renderAll(); }
on('#toggleGridBtn', 'click', () => { gridEnabled = !gridEnabled; $('#toggleGridBtn').classList.toggle('active', gridEnabled); drawGrid(); });
on('#toggleSnapBtn', 'click', () => { snapEnabled = !snapEnabled; $('#toggleSnapBtn').classList.toggle('active', snapEnabled); });
const gridSizeInput = $('#gridSizeInput'); gridSizeInput.value = gridCellSize; gridSizeInput.addEventListener('input', (e) => { const newSize = Math.max(12, Math.min(64, parseInt(e.target.value, 10))); if (!isNaN(newSize) && gridCellSize !== newSize) { gridCellSize = newSize; drawGrid(); } });
on('#closeColumnSelectModal', 'click', () => $('#columnSelectModal').style.display = 'none');

// --- CANVAS PANNING & ZOOM ---
function getWorkspaceBounds() {
    const artboards = canvas.getObjects().filter(o => o && (o.isArtboard || o.oid === 'pageRect'));
    if (!artboards.length) {
        return { minX: 0, minY: 0, maxX: DEFAULT_PAGE_WIDTH, maxY: DEFAULT_PAGE_HEIGHT };
    }

    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    artboards.forEach(board => {
        board.setCoords();
        const rect = board.getBoundingRect(true, true);
        minX = Math.min(minX, rect.left);
        minY = Math.min(minY, rect.top);
        maxX = Math.max(maxX, rect.left + rect.width);
        maxY = Math.max(maxY, rect.top + rect.height);
    });

    return { minX, minY, maxX, maxY };
}

function clampViewportTransform(vpt = canvas.viewportTransform) {
    if (!vpt) return;
    const wrapperRect = canvasWrapper.getBoundingClientRect();
    const viewportW = wrapperRect.width || canvas.getWidth() || 1;
    const viewportH = wrapperRect.height || canvas.getHeight() || 1;
    const zoom = canvas.getZoom() || 1;
    const bounds = getWorkspaceBounds();
    const pageCount = Math.max(1, documentPages.length || 1);
    const widestPage = documentPages.reduce(
        (max, page) => Math.max(max, parsePositiveInt(page?.width, DEFAULT_PAGE_WIDTH)),
        DEFAULT_PAGE_WIDTH
    );
    const tallestPage = documentPages.reduce(
        (max, page) => Math.max(max, parsePositiveInt(page?.height, DEFAULT_PAGE_HEIGHT)),
        DEFAULT_PAGE_HEIGHT
    );
    const dynamicPaddingX = CAMERA_BOUND_PADDING + Math.max(0, pageCount - 1) * Math.max(220, Math.round(widestPage * 0.3));
    const dynamicPaddingY = CAMERA_BOUND_PADDING + Math.max(0, pageCount - 1) * Math.max(160, Math.round(tallestPage * 0.2));

    const minTx = viewportW - (bounds.maxX + dynamicPaddingX) * zoom;
    const maxTx = -((bounds.minX - dynamicPaddingX) * zoom);
    const minTy = viewportH - (bounds.maxY + dynamicPaddingY) * zoom;
    const maxTy = -((bounds.minY - dynamicPaddingY) * zoom);

    if (minTx <= maxTx) {
        vpt[4] = Math.min(maxTx, Math.max(minTx, vpt[4]));
    }

    if (minTy <= maxTy) {
        vpt[5] = Math.min(maxTy, Math.max(minTy, vpt[5]));
    }
}

function updateZoomLabel() {
    $('#zoomLevel').textContent = `Zoom: ${Math.round(canvas.getZoom() * 100)}%`;
}

function panViewportBy(dx, dy) {
    const vpt = canvas.viewportTransform;
    vpt[4] += dx;
    vpt[5] += dy;
    clampViewportTransform(vpt);
    canvas.setViewportTransform(vpt);
    canvas.requestRenderAll();
}

// Ensure wheel events are captured and do not scroll the page
try {
    canvas.upperCanvasEl.addEventListener('wheel', (ev) => { ev.preventDefault(); }, { passive: false });
} catch (e) { }

function refreshCanvasPointerOffset() {
    if (!canvas?.upperCanvasEl) return;
    canvas.calcOffset();
}

window.addEventListener('resize', refreshCanvasPointerOffset);
window.addEventListener('scroll', refreshCanvasPointerOffset, true);

let isPanning = false;
let isMiddleMousePanning = false;
let lastPosX = 0;
let lastPosY = 0;
let isSpaceDown = false;

function beginPan(clientX, clientY) {
    isPanning = true;
    canvas.selection = false;
    lastPosX = clientX;
    lastPosY = clientY;
    canvas.setCursor('grabbing');
}

function endPan() {
    if (!isPanning && !isMiddleMousePanning) return;
    isPanning = false;
    isMiddleMousePanning = false;
    canvas.selection = true;
    canvas.setViewportTransform(canvas.viewportTransform);
    if (isSpaceDown) canvas.setCursor('grab');
    else canvas.setCursor('default');
}

function addWheelPanFix() {
    const el = canvas.upperCanvasEl;
    if (!el) return;

    // Prevent browser swipe/back behavior while interacting in-canvas.
    el.style.overscrollBehavior = 'contain';

    el.addEventListener('mousedown', (e) => {
        if (e.button !== 1) return;
        e.preventDefault();
        e.stopPropagation();
        isMiddleMousePanning = true;
        beginPan(e.clientX, e.clientY);
    }, true);

    window.addEventListener('mousemove', (e) => {
        if (!isMiddleMousePanning) return;
        e.preventDefault();
        panViewportBy(e.clientX - lastPosX, e.clientY - lastPosY);
        lastPosX = e.clientX;
        lastPosY = e.clientY;
    }, { passive: false });

    window.addEventListener('mouseup', (e) => {
        if (isMiddleMousePanning && e.button === 1) {
            e.preventDefault();
            endPan();
            return;
        }
        // Space+left drag can end outside the canvas, so recover selection globally.
        if (isPanning && !isMiddleMousePanning && e.button === 0) {
            endPan();
        }
    });
}

window.addEventListener('keydown', e => {
    if (e.code !== 'Space') return;
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    e.preventDefault();
    isSpaceDown = true;
    canvas.defaultCursor = 'grab';
    canvas.setCursor('grab');
});

window.addEventListener('keyup', e => {
    if (e.code !== 'Space') return;
    e.preventDefault();
    isSpaceDown = false;
    canvas.defaultCursor = 'default';
    if (!isPanning && !isMiddleMousePanning) canvas.setCursor('default');
});

window.addEventListener('blur', () => {
    endPan();
});

document.addEventListener('visibilitychange', () => {
    if (document.hidden) endPan();
});

canvas.on('mouse:wheel', function (opt) {
    const e = opt.e;
    e.preventDefault();
    e.stopPropagation();
    refreshCanvasPointerOffset();

    let zoom = canvas.getZoom();
    zoom *= 0.999 ** e.deltaY;
    if (zoom > 20) zoom = 20;
    if (zoom < 0.05) zoom = 0.05;

    const pointer = canvas.getPointer(e);
    canvas.zoomToPoint(new fabric.Point(pointer.x, pointer.y), zoom);
    clampViewportTransform(canvas.viewportTransform);
    canvas.setViewportTransform(canvas.viewportTransform);
    canvas.requestRenderAll();

    updateZoomLabel();
});

canvas.on('mouse:down', function (opt) {
    const e = opt.e;
    refreshCanvasPointerOffset();
    if (!isSpaceDown || e.button !== 0) return;
    beginPan(e.clientX, e.clientY);
    e.preventDefault();
});

canvas.on('mouse:move', function (opt) {
    if (!isPanning || isMiddleMousePanning) return;
    const e = opt.e;
    panViewportBy(e.clientX - lastPosX, e.clientY - lastPosY);
    lastPosX = e.clientX;
    lastPosY = e.clientY;
});

canvas.on('mouse:up', function () {
    if (!isMiddleMousePanning) endPan();
});


// --- DATA HANDLING ---
// 4. In-app notification
// 4. Modern Toast notification
function showNotification(message, type = 'info', duration = 3000) {
    const container = $('#toast-container');
    if (!container) return;

    const toast = document.createElement('div');
    toast.className = `toast ${type}`;

    const icon = type === 'success' ? '✓' : type === 'error' ? '!' : 'i';
    toast.innerHTML = `<span class="toast-icon">${icon}</span><span class="toast-message">${message}</span>`;

    container.appendChild(toast);

    setTimeout(() => {
        toast.classList.add('fade-out');
        setTimeout(() => toast.remove(), 300);
    }, duration);
}

async function cacheDataFile(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        localStorage.setItem('cachedFileName', file.name);
        localStorage.setItem('cachedFileData', e.target.result);
        cacheLocalDataState();
    };
    reader.readAsDataURL(file);
}

function cacheLocalDataState() {
    try {
        if (headers.length > 0) {
            localStorage.setItem('cachedHeaders', JSON.stringify(headers));
            localStorage.setItem('cachedDataRows', JSON.stringify(dataRows));
            if (identifierColumn) localStorage.setItem('cachedIdentifierColumn', identifierColumn);
            else localStorage.removeItem('cachedIdentifierColumn');
        } else {
            localStorage.removeItem('cachedHeaders');
            localStorage.removeItem('cachedDataRows');
            localStorage.removeItem('cachedIdentifierColumn');
        }
    } catch (e) {
        console.warn('Failed to cache data to localStorage:', e);
    }
}

function processFileData(arrayBuffer, fileName, opts = {}) {
    try {
        workbook = XLSX.read(arrayBuffer, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        worksheet = workbook.Sheets[sheetName];
        const json = XLSX.utils.sheet_to_json(worksheet, { defval: '', raw: false });
        if (!json.length) { showNotification('No data found in the sheet.'); return; }
        // Ensure headers are extracted from the first row keys
        headers = Object.keys(json[0]);
        dataRows = json; // Keep the full array of objects
        console.log('Processed Data:', { headers, rowCount: dataRows.length, sample: dataRows[0] });
        $('#fileName').textContent = fileName;
        $('#unloadDataBtn').style.display = 'inline';
        showNotification(`Loaded "${sheetName}" with ${dataRows.length} rows.`);
        refreshInspector({ target: canvas.getActiveObject() });
        updateExportUI();
        updateFloatingLinker(canvas.getActiveObject());
        renderCsvView(); // Update view if open
        refreshIdentifierDropdown();
        requestSaveState(); // Trigger save with new data
        cacheLocalDataState(); // Persist to local storage

        // Show identifier column modal on fresh file load
        if (!opts.skipIdentifierModal) {
            showIdentifierColumnModal();
        }
    } catch (err) {
        showNotification('Error reading file.');
        unloadData();
    }
}
// 5. Unload data function
function unloadData() {
    workbook = null; worksheet = null; headers = []; dataRows = []; identifierColumn = '';
    $('#fileName').textContent = 'No file selected';
    $('#unloadDataBtn').style.display = 'none';
    localStorage.removeItem('cachedFileName');
    localStorage.removeItem('cachedFileData');
    localStorage.removeItem('cachedHeaders');
    localStorage.removeItem('cachedDataRows');
    localStorage.removeItem('cachedIdentifierColumn');
    $('#csvInput').value = '';
    $('#csvViewBtn').style.display = 'none';
    updateExportUI();
    updateFloatingLinker(null);
    showNotification('Data unloaded.');
}
on('#unloadDataBtn', 'click', unloadData);

function base64ToArrayBuffer(base64) {
    const binaryString = window.atob(base64.split(',')[1]);
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}
async function loadCachedData() {
    const cachedHeaders = localStorage.getItem('cachedHeaders');
    const cachedRows = localStorage.getItem('cachedDataRows');
    const cachedIdCol = localStorage.getItem('cachedIdentifierColumn');
    const fileName = localStorage.getItem('cachedFileName');

    if (cachedHeaders && cachedRows) {
        try {
            headers = JSON.parse(cachedHeaders);
            dataRows = JSON.parse(cachedRows);
            identifierColumn = cachedIdCol || '';
            $('#fileName').textContent = fileName || 'Restored Data';
            $('#unloadDataBtn').style.display = 'inline';
            $('#csvViewBtn').style.display = 'inline-flex';
            refreshIdentifierDropdown();
            renderCsvView();
            updateExportUI();
            updateFloatingLinker(canvas.getActiveObject());
            return;
        } catch (e) {
            console.error('Failed to parse cached data:', e);
        }
    }

    const fileData = localStorage.getItem('cachedFileData');
    if (fileName && fileData) {
        const arrayBuffer = base64ToArrayBuffer(fileData);
        processFileData(arrayBuffer, fileName, { skipIdentifierModal: true });
    }
}
on('#csvInput', 'change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) { unloadData(); return; }
    await cacheDataFile(file);
    const data = await file.arrayBuffer();
    processFileData(data, file.name);
});

// Font Loading
async function loadFont(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const fontName = file.name.split('.')[0];
            const fontFace = new FontFace(fontName, e.target.result);
            await fontFace.load();
            document.fonts.add(fontFace);
            addFontFamilyToRegistry(fontName);
            refreshInspector({ target: canvas.getActiveObject() });
            showNotification(`Font "${fontName}" loaded.`);
        } catch (err) {
            console.error(err);
            showNotification('Error loading font.', 'error');
        }
    };
    reader.readAsArrayBuffer(file);
}
on('#fontUpload', 'change', (e) => loadFont(e.target.files[0]));




// components/03-canvas-and-elements.js
// --- COMPONENT ADDITION ---
function getUniqueName(baseName) {
    const existingNames = canvas.getObjects().map(o => o.name).filter(Boolean);
    if (!existingNames.includes(baseName)) { return baseName; }
    let i = 1;
    while (existingNames.includes(`${baseName} ${i}`)) { i++; }
    return `${baseName} ${i}`;
}

function currentCanvasPageId() {
    return documentPages[currentPageIndex]?.id || 'page_1';
}

function pageIndexForPageId(pageId) {
    if (!pageId) return -1;
    return documentPages.findIndex(page => page?.id === pageId);
}

function resolveObjectSourcePageIndex(obj) {
    if (!obj) return currentPageIndex;
    const idx = pageIndexForPageId(obj.pageId);
    return idx >= 0 ? idx : currentPageIndex;
}

function resolveSelectionSourcePageIndex(selection) {
    if (!selection || selection.type !== 'activeSelection' || typeof selection.getObjects !== 'function') {
        return resolveObjectSourcePageIndex(selection);
    }

    const counts = new Map();
    selection.getObjects().forEach(member => {
        if (!member) return;
        const context = getWorkspaceObjectPageContext(member);
        const idxFromContext = Number.isInteger(context?.pageIndex) ? context.pageIndex : -1;
        const fallbackIdx = resolveObjectSourcePageIndex(member);
        const idx = idxFromContext >= 0 ? idxFromContext : fallbackIdx;
        const safeIdx = (idx >= 0 && idx < documentPages.length) ? idx : currentPageIndex;
        counts.set(safeIdx, (counts.get(safeIdx) || 0) + 1);
    });

    if (!counts.size) return currentPageIndex;

    let bestIndex = currentPageIndex;
    let bestCount = -1;
    counts.forEach((count, index) => {
        if (count > bestCount) {
            bestCount = count;
            bestIndex = index;
        }
    });
    return bestIndex;
}

const TABLE_TEXT_PADDING = 6;

function getDefaultTableCellData(table, row, col) {
    const isHeader = row < (table.headerRows || 0);
    return {
        row,
        col,
        text: '',
        fill: isHeader ? (table.headerFill || '#f3f4f6') : (table.bodyFill || '#ffffff'),
        textColor: '#111111',
        fontSize: 14,
        textAlign: 'left',
        textVAlign: 'top',
        borderColor: table.borderColor || '#333333',
        borderWidth: Math.max(0.5, parseFloat(table.borderWidth) || 1),
        borders: { top: true, right: true, bottom: true, left: true }
    };
}

function normalizeTableCellData(raw, table, row, col) {
    const base = getDefaultTableCellData(table, row, col);
    const merged = { ...base, ...(raw || {}) };
    merged.row = row;
    merged.col = col;
    merged.text = typeof merged.text === 'string' ? merged.text : '';
    merged.fill = merged.fill ?? base.fill;
    merged.textColor = merged.textColor || base.textColor;
    merged.fontSize = Math.max(6, parseFloat(merged.fontSize) || base.fontSize);
    merged.textAlign = ['left', 'center', 'right', 'justify'].includes(merged.textAlign) ? merged.textAlign : base.textAlign;
    merged.textVAlign = ['top', 'middle', 'bottom'].includes(merged.textVAlign) ? merged.textVAlign : base.textVAlign;
    merged.borderColor = merged.borderColor || table.borderColor || base.borderColor;
    merged.borderWidth = Math.max(0.5, parseFloat(merged.borderWidth) || table.borderWidth || base.borderWidth);
    const borders = merged.borders || {};
    merged.borders = {
        top: borders.top !== false,
        right: borders.right !== false,
        bottom: borders.bottom !== false,
        left: borders.left !== false
    };
    return merged;
}

function ensureTableCellData(table) {
    if (!table || !table.isTable) return;
    const rows = Math.max(1, parseInt(table.rows, 10) || 1);
    const cols = Math.max(1, parseInt(table.cols, 10) || 1);
    table.rows = rows;
    table.cols = cols;
    table.headerRows = Math.max(0, Math.min(rows, parseInt(table.headerRows, 10) || 0));
    table.borderColor = table.borderColor || '#333333';
    table.borderWidth = Math.max(0.5, parseFloat(table.borderWidth) || 1);
    table.headerFill = table.headerFill || '#f3f4f6';
    table.bodyFill = table.bodyFill || '#ffffff';

    const baseW = Math.max(25, parseFloat(table.colWidths?.[0]) || 120);
    const baseH = Math.max(25, parseFloat(table.rowHeights?.[0]) || 50);
    table.colWidths = Array.from({ length: cols }, (_, i) => Math.max(25, parseFloat(table.colWidths?.[i]) || baseW));
    table.rowHeights = Array.from({ length: rows }, (_, i) => Math.max(25, parseFloat(table.rowHeights?.[i]) || baseH));

    const old = Array.isArray(table.cellData) ? table.cellData : [];
    const next = [];
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const idx = r * cols + c;
            next.push(normalizeTableCellData(old[idx], table, r, c));
        }
    }
    table.cellData = next;
    if (!(table._selectedCells instanceof Set)) {
        table._selectedCells = new Set(Array.isArray(table.selectedCells) ? table.selectedCells : []);
    }
}

function resizeTableCellData(table, nextRows, nextCols) {
    ensureTableCellData(table);
    const prevRows = table.rows;
    const prevCols = table.cols;
    const previous = table.cellData.slice();
    const resized = [];

    for (let r = 0; r < nextRows; r++) {
        for (let c = 0; c < nextCols; c++) {
            if (r < prevRows && c < prevCols) {
                const oldIdx = r * prevCols + c;
                resized.push(normalizeTableCellData(previous[oldIdx], table, r, c));
            } else {
                resized.push(getDefaultTableCellData(table, r, c));
            }
        }
    }

    table.rows = nextRows;
    table.cols = nextCols;
    table.cellData = resized;
    table.headerRows = Math.max(0, Math.min(table.rows, table.headerRows || 0));
}

function getTableCellGroupParts(cellGroup) {
    const objs = cellGroup.getObjects();
    return {
        fillRect: objs[0],
        textObj: objs[1],
        topLine: objs[2],
        rightLine: objs[3],
        bottomLine: objs[4],
        leftLine: objs[5],
        selectionRect: objs[6]
    };
}

function createTableCellGroup({ width, height, cellData, cellIndex, row, col }) {
    const fillRect = new fabric.Rect({
        left: -width / 2,
        top: -height / 2,
        originX: 'left',
        originY: 'top',
        width,
        height,
        fill: cellData.fill,
        stroke: null,
        selectable: false,
        evented: false
    });

    const textObj = new fabric.Textbox(cellData.text || '', {
        left: -width / 2 + TABLE_TEXT_PADDING,
        top: -height / 2 + TABLE_TEXT_PADDING,
        originX: 'left',
        originY: 'top',
        width: Math.max(8, width - TABLE_TEXT_PADDING * 2),
        fontSize: cellData.fontSize || 14,
        fill: cellData.textColor || '#111111',
        textAlign: cellData.textAlign || 'left',
        lineHeight: 1.2,
        selectable: false,
        evented: false,
        editable: false
    });

    const makeBorderRect = (visible = true) => new fabric.Rect({
        left: -width / 2,
        top: -height / 2,
        originX: 'left',
        originY: 'top',
        width: 1,
        height: 1,
        fill: cellData.borderColor || '#333333',
        selectable: false,
        evented: false,
        visible
    });

    const topLine = makeBorderRect(cellData.borders?.top !== false);
    const rightLine = makeBorderRect(cellData.borders?.right !== false);
    const bottomLine = makeBorderRect(cellData.borders?.bottom !== false);
    const leftLine = makeBorderRect(cellData.borders?.left !== false);

    const selectionRect = new fabric.Rect({
        left: -width / 2,
        top: -height / 2,
        originX: 'left',
        originY: 'top',
        width,
        height,
        fill: 'rgba(59,130,246,0.12)',
        stroke: '#3b82f6',
        strokeWidth: 1,
        selectable: false,
        evented: false,
        excludeFromExport: true,
        visible: false
    });

    return new fabric.Group([fillRect, textObj, topLine, rightLine, bottomLine, leftLine, selectionRect], {
        left: 0,
        top: 0,
        originX: 'center',
        originY: 'center',
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
        objectCaching: false,
        isTableCellGroup: true,
        cellIndex,
        row,
        col
    });
}

function updateTableCellGroupVisual(cellGroup, width, height, cellData, selected = false) {
    const { fillRect, textObj, topLine, rightLine, bottomLine, leftLine, selectionRect } = getTableCellGroupParts(cellGroup);
    const clampedWidth = Math.max(1, width);
    const clampedHeight = Math.max(1, height);
    const localLeft = -clampedWidth / 2;
    const localTop = -clampedHeight / 2;

    fillRect.set({
        left: localLeft,
        top: localTop,
        width: clampedWidth,
        height: clampedHeight,
        fill: cellData.fill
    });

    textObj.set({
        left: localLeft + TABLE_TEXT_PADDING,
        top: localTop + TABLE_TEXT_PADDING,
        width: Math.max(8, clampedWidth - TABLE_TEXT_PADDING * 2),
        text: cellData.text || '',
        fill: cellData.textColor || '#111111',
        fontSize: Math.max(6, cellData.fontSize || 14),
        textAlign: cellData.textAlign || 'left'
    });
    textObj.initDimensions();
    const availableTextHeight = Math.max(0, clampedHeight - TABLE_TEXT_PADDING * 2);
    const measuredTextHeight = Math.min(availableTextHeight, textObj.height || 0);
    let textTop = localTop + TABLE_TEXT_PADDING;
    if (cellData.textVAlign === 'middle') {
        textTop = localTop + TABLE_TEXT_PADDING + Math.max(0, (availableTextHeight - measuredTextHeight) / 2);
    } else if (cellData.textVAlign === 'bottom') {
        textTop = localTop + clampedHeight - TABLE_TEXT_PADDING - measuredTextHeight;
    }
    textObj.set({ top: textTop });

    const borderColor = cellData.borderColor || '#333333';
    const borderWidth = Math.max(0.5, cellData.borderWidth || 1);
    const clampedBorder = Math.min(Math.max(0.5, borderWidth), Math.min(clampedWidth, clampedHeight));
    topLine.set({ left: localLeft, top: localTop, width: clampedWidth, height: clampedBorder, fill: borderColor, visible: cellData.borders?.top !== false });
    rightLine.set({ left: localLeft + clampedWidth - clampedBorder, top: localTop, width: clampedBorder, height: clampedHeight, fill: borderColor, visible: cellData.borders?.right !== false });
    bottomLine.set({ left: localLeft, top: localTop + clampedHeight - clampedBorder, width: clampedWidth, height: clampedBorder, fill: borderColor, visible: cellData.borders?.bottom !== false });
    leftLine.set({ left: localLeft, top: localTop, width: clampedBorder, height: clampedHeight, fill: borderColor, visible: cellData.borders?.left !== false });

    selectionRect.set({
        left: localLeft,
        top: localTop,
        width: clampedWidth,
        height: clampedHeight,
        visible: !!selected
    });

    cellGroup.set({ width, height, dirty: true });
    cellGroup.setCoords();
}

function refreshTableSelectionVisual(table) {
    if (!table?.isTable) return;
    const selected = table._selectedCells instanceof Set ? table._selectedCells : new Set();
    const cells = table.getObjects().filter(obj => obj.isTableCellGroup);
    cells.forEach((cellGroup, index) => {
        const parts = getTableCellGroupParts(cellGroup);
        if (parts.selectionRect) parts.selectionRect.set({ visible: selected.has(index) });
    });
    table.selectedCells = Array.from(selected);
}

function clearTableCellSelections(exceptTable = null) {
    canvas.getObjects().forEach(obj => {
        if (!obj?.isTable || obj === exceptTable) return;
        obj._selectedCells = new Set();
        refreshTableSelectionVisual(obj);
    });
    canvas.requestRenderAll();
}

function getTableCellFromPointer(table, pointer) {
    if (!table || !pointer) return null;
    const local = table.toLocalPoint(new fabric.Point(pointer.x, pointer.y), 'center', 'center');
    let currentY = -table.height / 2;

    for (let r = 0; r < table.rows; r++) {
        const h = table.rowHeights[r];
        let currentX = -table.width / 2;
        for (let c = 0; c < table.cols; c++) {
            const w = table.colWidths[c];
            if (local.x >= currentX && local.x <= currentX + w && local.y >= currentY && local.y <= currentY + h) {
                return { row: r, col: c, index: r * table.cols + c };
            }
            currentX += w;
        }
        currentY += h;
    }
    return null;
}

function getTableCellLocalRect(table, cellIndex) {
    if (!table?.isTable) return null;
    const maxIndex = table.rows * table.cols - 1;
    if (!Number.isInteger(cellIndex) || cellIndex < 0 || cellIndex > maxIndex) return null;
    const row = Math.floor(cellIndex / table.cols);
    const col = cellIndex % table.cols;
    const totalWidth = table.colWidths.reduce((sum, w) => sum + w, 0);
    const totalHeight = table.rowHeights.reduce((sum, h) => sum + h, 0);
    let left = -totalWidth / 2;
    let top = -totalHeight / 2;
    for (let c = 0; c < col; c++) left += table.colWidths[c];
    for (let r = 0; r < row; r++) top += table.rowHeights[r];
    return {
        left,
        top,
        width: table.colWidths[col],
        height: table.rowHeights[row],
        row,
        col
    };
}

function getTableCellEditorRect(table, cellIndex) {
    const localRect = getTableCellLocalRect(table, cellIndex);
    if (!localRect) return null;
    const tableMatrix = table.calcTransformMatrix();
    const vpt = canvas.viewportTransform || [1, 0, 0, 1, 0, 0];
    const finalMatrix = fabric.util.multiplyTransformMatrices(vpt, tableMatrix);
    const corners = [
        new fabric.Point(localRect.left, localRect.top),
        new fabric.Point(localRect.left + localRect.width, localRect.top),
        new fabric.Point(localRect.left + localRect.width, localRect.top + localRect.height),
        new fabric.Point(localRect.left, localRect.top + localRect.height)
    ].map(p => fabric.util.transformPoint(p, finalMatrix));
    const xs = corners.map(p => p.x);
    const ys = corners.map(p => p.y);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    const canvasRect = canvas.upperCanvasEl.getBoundingClientRect();
    return {
        left: canvasRect.left + minX,
        top: canvasRect.top + minY,
        width: maxX - minX,
        height: maxY - minY
    };
}

function closeTableCellEditor({ commit = true } = {}) {
    if (!activeTableCellEditor) return;
    activeTableCellEditor.close(commit);
}

function startTableCellEditor(table, cellIndex) {
    if (!table?.isTable) return;
    ensureTableCellData(table);
    const cell = table.cellData[cellIndex];
    if (!cell) return;

    closeTableCellEditor({ commit: true });

    const rect = getTableCellEditorRect(table, cellIndex);
    if (!rect || rect.width < 4 || rect.height < 4) return;

    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'table-cell-editor';
    input.value = cell.text || '';
    input.style.left = `${Math.round(rect.left + 1)}px`;
    input.style.top = `${Math.round(rect.top + 1)}px`;
    input.style.width = `${Math.max(28, Math.round(rect.width - 2))}px`;
    input.style.height = `${Math.max(22, Math.round(rect.height - 2))}px`;
    input.style.fontSize = `${Math.max(10, Math.round(cell.fontSize || 14))}px`;
    input.style.textAlign = cell.textAlign || 'left';
    input.style.fontFamily = 'inherit';

    document.body.appendChild(input);

    let closed = false;
    const previousValue = cell.text || '';
    const closeEditor = (shouldCommit) => {
        if (closed) return;
        closed = true;
        const nextValue = input.value;
        if (shouldCommit && table.isTable && previousValue !== nextValue) {
            ensureTableCellData(table);
            if (table.cellData[cellIndex]) {
                table.cellData[cellIndex].text = nextValue;
                updateTableLayout(table);
                canvas.requestRenderAll();
                requestSaveState();
            }
        }
        input.remove();
        if (activeTableCellEditor && activeTableCellEditor.input === input) {
            activeTableCellEditor = null;
        }
        if (canvas.getActiveObject() === table) refreshInspector({ target: table });
    };

    activeTableCellEditor = { table, cellIndex, input, close: closeEditor };

    input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            closeEditor(true);
        } else if (e.key === 'Escape') {
            e.preventDefault();
            closeEditor(false);
        }
    });
    input.addEventListener('blur', () => closeEditor(true));

    requestAnimationFrame(() => {
        input.focus();
        input.select();
    });
}

function getSelectedTableCellIndices(table, { fallbackAll = false } = {}) {
    ensureTableCellData(table);
    if (!(table._selectedCells instanceof Set)) table._selectedCells = new Set();
    const selected = Array.from(table._selectedCells).filter(i => Number.isInteger(i) && i >= 0 && i < table.rows * table.cols);
    if (selected.length || !fallbackAll) return selected;
    return Array.from({ length: table.rows * table.cols }, (_, i) => i);
}

function getTableCellRowCol(table, cellIndex) {
    ensureTableCellData(table);
    const max = Math.max(0, table.rows * table.cols - 1);
    const idx = Math.max(0, Math.min(max, parseInt(cellIndex, 10) || 0));
    return {
        index: idx,
        row: Math.floor(idx / table.cols),
        col: idx % table.cols
    };
}

function tableCellRefLabel(table, cellIndex) {
    const rc = getTableCellRowCol(table, cellIndex);
    return `R${rc.row + 1} C${rc.col + 1}`;
}

function getSingleSelectedTableCellIndex(table) {
    const selected = getSelectedTableCellIndices(table, { fallbackAll: false });
    return selected.length === 1 ? selected[0] : -1;
}

function setSelectedTableCells(table, indices, { append = false, toggle = false } = {}) {
    if (!table?.isTable) return;
    ensureTableCellData(table);
    const maxIdx = table.rows * table.cols - 1;
    let next = append || toggle ? new Set(table._selectedCells || []) : new Set();
    indices.forEach(idx => {
        if (!Number.isInteger(idx) || idx < 0 || idx > maxIdx) return;
        if (toggle) {
            if (next.has(idx)) next.delete(idx);
            else next.add(idx);
        } else {
            next.add(idx);
        }
    });
    table._selectedCells = next;
    refreshTableSelectionVisual(table);
    canvas.requestRenderAll();
}

function getCommonSelectedTableCellValue(table, key, { fallbackAll = false } = {}) {
    const indices = getSelectedTableCellIndices(table, { fallbackAll });
    if (!indices.length) return '';
    const values = indices.map(i => {
        const cell = table.cellData[i];
        if (!cell) return undefined;
        if (key.includes('.')) {
            const [k1, k2] = key.split('.');
            return cell[k1]?.[k2];
        }
        return cell[key];
    });
    const first = values[0];
    return values.every(v => v === first) ? first : '';
}

function applyToSelectedTableCells(table, updater, { fallbackAll = true } = {}) {
    if (!table?.isTable) return;
    ensureTableCellData(table);
    const indices = getSelectedTableCellIndices(table, { fallbackAll });
    if (!indices.length) return;
    indices.forEach(idx => updater(table.cellData[idx], idx));
    updateTableLayout(table);
    canvas.requestRenderAll();
    requestSaveState();
}

function toggleSelectedTableBorderSide(table, side) {
    if (!['top', 'right', 'bottom', 'left'].includes(side)) return;
    ensureTableCellData(table);
    const indices = getSelectedTableCellIndices(table, { fallbackAll: true });
    if (!indices.length) return;
    const allOn = indices.every(idx => table.cellData[idx]?.borders?.[side] !== false);
    indices.forEach(idx => {
        const cell = table.cellData[idx];
        cell.borders = cell.borders || { top: true, right: true, bottom: true, left: true };
        cell.borders[side] = !allOn;
    });
    updateTableLayout(table);
    canvas.requestRenderAll();
    requestSaveState();
}

function rebuildTableCells(table) {
    if (!table || !table.isTable) return;
    ensureTableCellData(table);
    const existingSelection = new Set(getSelectedTableCellIndices(table));
    const center = table.getCenterPoint();
    table.getObjects().slice().forEach(cell => table.remove(cell));

    for (let r = 0; r < table.rows; r++) {
        for (let c = 0; c < table.cols; c++) {
            const index = r * table.cols + c;
            const cellGroup = createTableCellGroup({
                width: table.colWidths[c],
                height: table.rowHeights[r],
                cellData: table.cellData[index],
                cellIndex: index,
                row: r,
                col: c
            });
            table.add(cellGroup);
        }
    }

    table._selectedCells = existingSelection;
    table.originalColWidths = [...table.colWidths];
    table.originalRowHeights = [...table.rowHeights];
    updateTableLayout(table, center);
}

function createTableObject({
    x,
    y,
    rows,
    cols,
    cellWidth,
    cellHeight,
    headerRows = 1,
    headerFill = '#f3f4f6',
    bodyFill = '#ffffff',
    borderColor = '#333333',
    borderWidth = 1
}) {
    const colWidths = Array(Math.max(1, cols)).fill(Math.max(25, cellWidth));
    const rowHeights = Array(Math.max(1, rows)).fill(Math.max(25, cellHeight));

    const table = new fabric.Group([], {
        left: x,
        top: y,
        originX: 'center',
        originY: 'center',
        isTable: true,
        rows: Math.max(1, rows),
        cols: Math.max(1, cols),
        colWidths,
        rowHeights,
        originalColWidths: [...colWidths],
        originalRowHeights: [...rowHeights],
        headerRows: Math.max(0, Math.min(rows, headerRows)),
        headerFill,
        bodyFill,
        borderColor,
        borderWidth,
        cellData: [],
        hasControls: true,
        hasBorders: true,
        cornerColor: '#4285F4',
        cornerStyle: 'circle',
        transparentCorners: false,
        borderScaleFactor: 1,
        objectCaching: false,
        lockScalingFlip: true,
        name: getUniqueName('table'),
        pageId: currentCanvasPageId()
    });

    table._selectedCells = new Set();
    table.selectedCells = [];
    rebuildTableCells(table);
    return table;
}

function addTableRow(table) {
    const nextRows = Math.max(1, table.rows + 1);
    const nextCols = Math.max(1, table.cols);
    resizeTableCellData(table, nextRows, nextCols);
    table.rowHeights.push(table.rowHeights[table.rowHeights.length - 1] || 50);
    table.headerRows = Math.min(table.headerRows || 0, nextRows);
    rebuildTableCells(table);
    canvas.requestRenderAll();
    requestSaveState();
}

function removeTableRow(table) {
    if (table.rows <= 1) return;
    const nextRows = table.rows - 1;
    const nextCols = table.cols;
    resizeTableCellData(table, nextRows, nextCols);
    table.rowHeights.pop();
    table.headerRows = Math.min(table.headerRows || 0, nextRows);
    rebuildTableCells(table);
    canvas.requestRenderAll();
    requestSaveState();
}

function addTableColumn(table) {
    const nextRows = table.rows;
    const nextCols = table.cols + 1;
    resizeTableCellData(table, nextRows, nextCols);
    table.colWidths.push(table.colWidths[table.colWidths.length - 1] || 120);
    rebuildTableCells(table);
    canvas.requestRenderAll();
    requestSaveState();
}

function removeTableColumn(table) {
    if (table.cols <= 1) return;
    const nextRows = table.rows;
    const nextCols = table.cols - 1;
    resizeTableCellData(table, nextRows, nextCols);
    table.colWidths.pop();
    rebuildTableCells(table);
    canvas.requestRenderAll();
    requestSaveState();
}

const DEFAULT_SHAPE_FILL = '#dbe7f3';

const adders = {
    text: (x, y, content = 'Sample Text') => canvas.add(new fabric.Textbox(content, { left: x, top: y, fontSize: 28, fill: '#000000', fontFamily: 'Arial', originX: 'center', originY: 'center', styles: [], padding: 0, curveAmount: 0, name: getUniqueName('text'), lockUniScaling: true, pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
    rect: ({ x, y, asSquare = true } = {}) => canvas.add(new fabric.Rect({ left: x, top: y, width: asSquare ? 150 : 220, height: 150, fill: DEFAULT_SHAPE_FILL, stroke: null, strokeWidth: 0, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName(asSquare ? 'square' : 'rectangle'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
    circle: (x, y) => canvas.add(new fabric.Circle({ left: x, top: y, radius: 75, fill: DEFAULT_SHAPE_FILL, stroke: null, strokeWidth: 0, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName('circle'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
    triangle: (x, y) => canvas.add(new fabric.Triangle({ left: x, top: y, width: 150, height: 130, fill: DEFAULT_SHAPE_FILL, stroke: null, strokeWidth: 0, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName('triangle'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
    line: (x, y) => {
        const spawnPoint = (Number.isFinite(x) && Number.isFinite(y))
            ? { x, y }
            : getDefaultSpawnPoint();
        const startPoint = new fabric.Point(spawnPoint.x - 75, spawnPoint.y);
        const endPoint = new fabric.Point(spawnPoint.x + 75, spawnPoint.y);

        const line = new fabric.Line([startPoint.x, startPoint.y, endPoint.x, endPoint.y], {
            stroke: DEFAULT_SHAPE_FILL,
            strokeWidth: 4,
            strokeUniform: true,
            originX: 'center',
            originY: 'center',
            padding: 0,
            name: getUniqueName('line'),
            pageId: currentCanvasPageId()
        });

        normalizeLineFromCanvasEndpoints(line, startPoint, endPoint);
        canvas.add(line).setActiveObject(line);
        canvas.renderAll();
    },
    star: (x, y) => { const pts = (n, oR, iR) => { const p = []; let a = -Math.PI / 2; const s = (Math.PI * 2) / n; for (let i = 0; i < n; i++) { p.push({ x: oR * Math.cos(a), y: oR * Math.sin(a) }); a += s / 2; p.push({ x: iR * Math.cos(a), y: iR * Math.sin(a) }); a += s / 2; } return p; }; canvas.add(new fabric.Polygon(pts(5, 75, 35), { left: x, top: y, fill: DEFAULT_SHAPE_FILL, stroke: null, strokeWidth: 0, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName('star'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()); },
    square: (x, y) => adders.rect({ x, y, asSquare: true }),
    arrow: (x, y) => canvas.add(new fabric.Path('M 0 20 L 60 20 L 60 0 L 100 30 L 60 60 L 60 40 L 0 40 Z', { left: x, top: y, fill: DEFAULT_SHAPE_FILL, stroke: null, strokeWidth: 0, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName('arrow'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
    image: (x, y, url, elementData = {}) => { fabric.Image.fromURL(url, (img) => { img.set({ left: x, top: y, scaleX: 0.5, scaleY: 0.5, originX: 'center', originY: 'center', name: getUniqueName('image'), pageId: currentCanvasPageId(), ...elementData }); canvas.add(img).setActiveObject(img); }, { crossOrigin: 'anonymous' }); },
    svg: (x, y, url, elementData = {}) => {
        fabric.loadSVGFromURL(url, (objects, options) => {
            if (!objects || objects.length === 0) return;
            objects.forEach(obj => {
                obj.objectCaching = false;
            });
            const group = new fabric.Group(objects, {
                ...options, ...elementData,
                left: x, top: y, originX: 'center', originY: 'center',
                isSvgGroup: true, name: getUniqueName('svg'), pageId: currentCanvasPageId(), objectCaching: false
            });
            group.scaleToWidth(150);
            group.setCoords();
            canvas.add(group).setActiveObject(canvas.getObjects().pop());
            canvas.renderAll();
        }, null, { crossOrigin: 'anonymous' });
    },
    // 6. Restored Table Code
    table: (x, y) => {
        tableCreatorModal.style.display = 'flex';

        const createHandler = () => {
            const rows = parsePositiveInt($('#tableRows').value, 3);
            const cols = parsePositiveInt($('#tableCols').value, 3);
            const cellWidth = parsePositiveInt($('#tableCellWidth').value, 120);
            const cellHeight = parsePositiveInt($('#tableCellHeight').value, 50);
            const headerRows = Math.max(0, Math.min(rows, parseInt($('#tableHeaderRows').value, 10) || 0));
            if (rows <= 0 || cols <= 0) return;

            const spawnPoint = (Number.isFinite(x) && Number.isFinite(y))
                ? { x, y }
                : getDefaultSpawnPoint();
            const table = createTableObject({
                x: spawnPoint.x,
                y: spawnPoint.y,
                rows,
                cols,
                cellWidth,
                cellHeight,
                headerRows
            });

            table.setPositionByOrigin(new fabric.Point(spawnPoint.x, spawnPoint.y), 'center', 'center');
            canvas.add(table).setActiveObject(table);
            canvas.requestRenderAll();
            closeTableModal();
        };

        const closeTableModal = () => {
            tableCreatorModal.style.display = 'none';
            $('#confirmTableCreate').removeEventListener('click', createHandler);
            $('#cancelTableCreate').removeEventListener('click', closeTableModal);
            $('#closeTableCreator').removeEventListener('click', closeTableModal);
        };

        on('#confirmTableCreate', 'click', createHandler, { once: true });
        on('#cancelTableCreate', 'click', closeTableModal, { once: true });
        on('#closeTableCreator', 'click', closeTableModal, { once: true });
    }
};
// 6. Restored Table Code
function updateTableLayout(table, preservedCenter = null) {
    if (!table || !table.isTable) return;
    ensureTableCellData(table);

    const cellObjects = table.getObjects();
    const allChildrenAreCells = cellObjects.length === table.rows * table.cols
        && cellObjects.every(obj => obj?.isTableCellGroup);
    if (!allChildrenAreCells) {
        rebuildTableCells(table);
        return;
    }

    const totalWidth = table.colWidths.reduce((sum, w) => sum + w, 0);
    const totalHeight = table.rowHeights.reduce((sum, h) => sum + h, 0);
    const center = preservedCenter || table.getCenterPoint();
    const selected = table._selectedCells instanceof Set ? table._selectedCells : new Set();

    let currentY = -totalHeight / 2;
    for (let r = 0; r < table.rows; r++) {
        let currentX = -totalWidth / 2;
        for (let c = 0; c < table.cols; c++) {
            const cellIndex = r * table.cols + c;
            const cellGroup = table.item(cellIndex);
            if (!cellGroup) continue;
            const width = table.colWidths[c];
            const height = table.rowHeights[r];
            const cellData = table.cellData[cellIndex] || getDefaultTableCellData(table, r, c);
            updateTableCellGroupVisual(cellGroup, width, height, cellData, selected.has(cellIndex));
            cellGroup.set({
                left: currentX + width / 2,
                top: currentY + height / 2,
                originX: 'center',
                originY: 'center',
                row: r,
                col: c,
                cellIndex
            });
            cellGroup.setCoords();
            currentX += width;
        }
        currentY += table.rowHeights[r];
    }

    table.width = totalWidth;
    table.height = totalHeight;
    table.setPositionByOrigin(center, 'center', 'center');
    table.dirty = true;
    table.setCoords();
    table.selectedCells = Array.from(selected);
}
// 6. Restored Table Code
class TableResizer {

    constructor(canvas) {
        this.canvas = canvas;
        this.state = {};
        this.resetState();

        this.RESIZE_HANDLE_AREA = 12;
        this.MIN_CELL_SIZE = 25;
    }

    resetState() {
        if (this.state.target) {
            this.state.target.lockMovementX = false;
            this.state.target.lockMovementY = false;
        }
        this.state = {
            isResizing: false,
            target: null,
            type: null,
            index: -1,
            startX: 0,
            startY: 0,
            originalPos: { x: 0, y: 0 },
            originalWidths: [],
            originalHeights: [],
        };
        this.canvas.defaultCursor = 'default';
    }

    init() {
        this.canvas.on('mouse:down', this.handleMouseDown.bind(this));
        this.canvas.on('mouse:move', this.handleMouseMove.bind(this));
        this.canvas.on('mouse:up', this.handleMouseUp.bind(this));
        this.canvas.on('object:modified', this.handleObjectScaling.bind(this));
    }

    handleObjectScaling(options) {
        const table = options.target;
        if (!table || !table.isTable) return;

        const { scaleX, scaleY } = table;

        let totalWidth = 0;
        for (let i = 0; i < table.colWidths.length; i++) {
            const newWidth = table.originalColWidths[i] * scaleX;
            table.colWidths[i] = Math.max(this.MIN_CELL_SIZE, newWidth);
            totalWidth += table.colWidths[i];
        }

        let totalHeight = 0;
        for (let i = 0; i < table.rowHeights.length; i++) {
            const newHeight = table.originalRowHeights[i] * scaleY;
            table.rowHeights[i] = Math.max(this.MIN_CELL_SIZE, newHeight);
            totalHeight += table.rowHeights[i];
        }

        table.width = totalWidth;
        table.height = totalHeight;
        table.scaleX = 1;
        table.scaleY = 1;

        updateTableLayout(table);
    }

    handleMouseDown(options) {
        if (options.target && options.target.isTable) {
            options.target.originalColWidths = [...options.target.colWidths];
            options.target.originalRowHeights = [...options.target.rowHeights];
        }

        if (!this.canvas.defaultCursor.includes('resize') || !options.target || !options.target.isTable) {
            return;
        }

        const pointer = this.canvas.getPointer(options.e);
        const table = options.target;

        this.state.isResizing = true;
        this.state.target = table;
        this.state.startX = pointer.x;
        this.state.startY = pointer.y;
        this.state.originalPos = { x: table.left, y: table.top };
        this.state.originalWidths = [...table.colWidths];
        this.state.originalHeights = [...table.rowHeights];

        table.lockMovementX = true;
        table.lockMovementY = true;
    }

    handleMouseMove(options) {
        if (this.state.isResizing) {
            this.performResize(options);
        } else {
            this.detectHover(options);
        }
    }

    performResize(options) {
        const pointer = this.canvas.getPointer(options.e);
        const { target, type, index, startX, startY, originalPos } = this.state;
        const dx = pointer.x - startX;
        const dy = pointer.y - startY;

        switch (type) {
            // --- INTERNAL RESIZING (PUSH/PULL) ---
            case 'col': {
                const newWidth = this.state.originalWidths[index] + dx;
                const adjacentNewWidth = this.state.originalWidths[index + 1] - dx;
                if (newWidth >= this.MIN_CELL_SIZE && adjacentNewWidth >= this.MIN_CELL_SIZE) {
                    target.colWidths[index] = newWidth;
                    target.colWidths[index + 1] = adjacentNewWidth;
                }
                break;
            }
            case 'row': {
                const newHeight = this.state.originalHeights[index] + dy;
                const adjacentNewHeight = this.state.originalHeights[index + 1] - dy;
                if (newHeight >= this.MIN_CELL_SIZE && adjacentNewHeight >= this.MIN_CELL_SIZE) {
                    target.rowHeights[index] = newHeight;
                    target.rowHeights[index + 1] = adjacentNewHeight;
                }
                break;
            }
            // --- EDGE RESIZING (PIVOT LOGIC) ---
            case 'edge-right': {
                const newWidth = this.state.originalWidths[index] + dx;
                if (newWidth >= this.MIN_CELL_SIZE) {
                    target.colWidths[index] = newWidth;
                    // [FIX] Move the table's center by HALF the delta to keep the left edge anchored.
                    target.left = originalPos.x + dx / 2;
                }
                break;
            }
            case 'edge-left': {
                const newWidth = this.state.originalWidths[index] - dx;
                if (newWidth >= this.MIN_CELL_SIZE) {
                    target.colWidths[index] = newWidth;
                    // Move the table's center by HALF the delta to keep the right edge anchored.
                    target.left = originalPos.x + dx / 2;
                }
                break;
            }
            case 'edge-bottom': {
                const newHeight = this.state.originalHeights[index] + dy;
                if (newHeight >= this.MIN_CELL_SIZE) {
                    target.rowHeights[index] = newHeight;
                    // [FIX] Move the table's center by HALF the delta to keep the top edge anchored.
                    target.top = originalPos.y + dy / 2;
                }
                break;
            }
            case 'edge-top': {
                const newHeight = this.state.originalHeights[index] - dy;
                if (newHeight >= this.MIN_CELL_SIZE) {
                    target.rowHeights[index] = newHeight;
                    // Move the table's center by HALF the delta to keep the bottom edge anchored.
                    target.top = originalPos.y + dy / 2;
                }
                break;
            }
        }

        // This function recalculates total dimensions and repositions internal cells.
        updateTableLayout(target);

        // We must re-render the canvas to see the changes.
        this.canvas.requestRenderAll();
    }

    detectHover(options) {
        const target = this.canvas.findTarget(options.e);
        if (!target || !target.isTable || !target.hasControls) {
            if (this.canvas.defaultCursor !== 'default') this.canvas.defaultCursor = 'default';
            if (this.canvas.hoverCursor !== 'default') this.canvas.hoverCursor = 'default';
            return;
        }

        const pointer = this.canvas.getPointer(options.e);
        const table = target;
        const localPoint = table.toLocalPoint(new fabric.Point(pointer.x, pointer.y), 'center', 'center');

        let onBoundary = false;

        let currentX = -table.width / 2;
        for (let c = 0; c < table.cols; c++) {
            if (c === 0 && Math.abs(localPoint.x - currentX) < this.RESIZE_HANDLE_AREA) {
                this.canvas.defaultCursor = 'ew-resize';
                this.canvas.hoverCursor = 'ew-resize';
                this.state.type = 'edge-left';
                this.state.index = 0;
                onBoundary = true; break;
            }
            currentX += table.colWidths[c];
            if (Math.abs(localPoint.x - currentX) < this.RESIZE_HANDLE_AREA) {
                this.canvas.defaultCursor = 'ew-resize';
                this.canvas.hoverCursor = 'ew-resize';
                this.state.type = (c === table.cols - 1) ? 'edge-right' : 'col';
                this.state.index = c;
                onBoundary = true; break;
            }
        }

        if (!onBoundary) {
            let currentY = -table.height / 2;
            for (let r = 0; r < table.rows; r++) {
                if (r === 0 && Math.abs(localPoint.y - currentY) < this.RESIZE_HANDLE_AREA) {
                    this.canvas.defaultCursor = 'ns-resize';
                    this.canvas.hoverCursor = 'ns-resize';
                    this.state.type = 'edge-top';
                    this.state.index = 0;
                    onBoundary = true; break;
                }
                currentY += table.rowHeights[r];
                if (Math.abs(localPoint.y - currentY) < this.RESIZE_HANDLE_AREA) {
                    this.canvas.defaultCursor = 'ns-resize';
                    this.canvas.hoverCursor = 'ns-resize';
                    this.state.type = (r === table.rows - 1) ? 'edge-bottom' : 'row';
                    this.state.index = r;
                    onBoundary = true; break;
                }
            }
        }

        if (!onBoundary) {
            this.canvas.defaultCursor = 'default';
            this.canvas.hoverCursor = 'default';
        }
    }

    handleMouseUp() {
        if (this.state.isResizing) {
            if (this.state.target) {
                this.state.target.originalColWidths = [...this.state.target.colWidths];
                this.state.target.originalRowHeights = [...this.state.target.rowHeights];
            }
            this.resetState();
            this.canvas.requestRenderAll();
        }
    }
}
const tableResizer = new TableResizer(canvas);
tableResizer.init();

canvas.on('mouse:down', (options) => {
    if (activeTableCellEditor) closeTableCellEditor({ commit: true });
    const table = options.target;
    if (!table || !table.isTable) return;
    if (tableResizer.state.isResizing || canvas.defaultCursor.includes('resize')) return;

    const pointer = canvas.getPointer(options.e);
    const hit = getTableCellFromPointer(table, pointer);
    if (!hit) return;

    const append = !!options.e.shiftKey;
    const toggle = !!(options.e.ctrlKey || options.e.metaKey);
    if (!append && !toggle) clearTableCellSelections(table);

    setSelectedTableCells(table, [hit.index], { append, toggle });
    refreshInspector({ target: table });
    updateFloatingLinker(table);
});

canvas.on('mouse:dblclick', (options) => {
    const table = options.target;
    if (!table || !table.isTable) return;
    if (tableResizer.state.isResizing || canvas.defaultCursor.includes('resize')) return;

    const pointer = canvas.getPointer(options.e);
    const hit = getTableCellFromPointer(table, pointer);
    if (!hit) return;

    clearTableCellSelections(table);
    setSelectedTableCells(table, [hit.index]);
    startTableCellEditor(table, hit.index);
    refreshInspector({ target: table });
    updateFloatingLinker(table);
});

canvas.on('mouse:wheel', () => {
    if (activeTableCellEditor) closeTableCellEditor({ commit: true });
});


document.getElementById('imageUpload').addEventListener('change', e => { if (!e.target.files || !e.target.files[0]) return; const reader = new FileReader(); reader.onload = (ev) => { const spawn = getDefaultSpawnPoint(); adders.image(spawn.x, spawn.y, ev.target.result); e.target.value = ''; }; reader.readAsDataURL(e.target.files[0]); });
document.querySelectorAll('.shape-chip[data-add]').forEach(chip => {
    const type = chip.getAttribute('data-add');
    chip.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', `component:${type}`); });
    chip.addEventListener('click', () => {
        if (!adders[type]) return;
        if (type === 'image') { $('#imageUpload').click(); return; }
        const spawn = getDefaultSpawnPoint();
        adders[type](spawn.x, spawn.y);
    });
});

const componentsMainView = document.getElementById('componentsMainView');
const componentsShapesView = document.getElementById('componentsShapesView');
const openShapesMenuBtn = document.getElementById('openShapesMenuBtn');
const backToComponentsBtn = document.getElementById('backToComponentsBtn');

const showComponentsView = (view = 'main') => {
    if (!componentsMainView || !componentsShapesView) return;
    const showShapes = view === 'shapes';
    componentsMainView.hidden = showShapes;
    componentsShapesView.hidden = !showShapes;
};

if (openShapesMenuBtn && componentsMainView && componentsShapesView) {
    openShapesMenuBtn.addEventListener('click', (e) => {
        e.preventDefault();
        showComponentsView('shapes');
    });
    openShapesMenuBtn.addEventListener('keydown', (e) => {
        if (e.key !== 'Enter' && e.key !== ' ') return;
        e.preventDefault();
        showComponentsView('shapes');
    });
}

if (backToComponentsBtn && componentsMainView && componentsShapesView) {
    backToComponentsBtn.addEventListener('click', () => showComponentsView('main'));
}

document.addEventListener('keydown', (e) => {
    if (e.key !== 'Escape') return;
    if (componentsShapesView && !componentsShapesView.hidden) showComponentsView('main');
});

const dropTarget = canvas.upperCanvasEl; canvas.calcOffset();
dropTarget.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
dropTarget.addEventListener('drop', (e) => {
    e.preventDefault(); const { x, y } = canvas.getPointer(e); const data = e.dataTransfer.getData('text/plain'); const [dataType, value] = data.split(/:(.*)/s);
    if (dataType === 'component' && adders[value]) { if (value === 'image') { const file = e.dataTransfer.files?.[0]; if (file?.type.startsWith('image/')) { const reader = new FileReader(); reader.onload = (ev) => adders.image(x, y, ev.target.result); reader.readAsDataURL(file); } else { $('#imageUpload').click(); } } else { adders[value](x, y); } }
    else if (dataType === 'element') { const elementData = JSON.parse(value); adders.image(x, y, elementData.image_url, { oid: elementData.id }); }
});

// --- SIDEBAR RESIZING & TOGGLING ---
const mainLayout = document.getElementById('main-layout'); const leftResizer = document.getElementById('left-resizer'); const rightResizer = document.getElementById('right-resizer'); let isResizingLeft = false, isResizingRight = false; let lastLeftPanelWidth = '300px', lastRightPanelWidth = '300px'; mainLayout.style.gridTemplateColumns = `${lastLeftPanelWidth} 5px 1fr 5px ${lastRightPanelWidth}`;
function initResizer(resizer, resizeFlagSetter, panelSide) { resizer.addEventListener('mousedown', (e) => { e.preventDefault(); resizeFlagSetter(true); document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none'; }); document.addEventListener('mousemove', (e) => { if (!resizeFlagSetter()) return; const mainRect = mainLayout.getBoundingClientRect(); if (panelSide === 'left') { const newWidth = e.clientX - mainRect.left; if (newWidth > 150 && newWidth < mainRect.width / 2) { mainLayout.style.gridTemplateColumns = `${newWidth}px 5px 1fr 5px ${mainLayout.style.gridTemplateColumns.split(' ')[4]}`; lastLeftPanelWidth = `${newWidth}px`; } } else { const newWidth = mainRect.right - e.clientX; if (newWidth > 200 && newWidth < mainRect.width / 2) { mainLayout.style.gridTemplateColumns = `${mainLayout.style.gridTemplateColumns.split(' ')[0]} 5px 1fr 5px ${newWidth}px`; lastRightPanelWidth = `${newWidth}px`; } } const { width, height } = canvasWrapper.getBoundingClientRect(); canvas.setDimensions({ width, height }); canvas.calcOffset(); canvas.renderAll(); }); document.addEventListener('mouseup', () => { if (resizeFlagSetter()) { resizeFlagSetter(false); document.body.style.cursor = 'default'; document.body.style.userSelect = 'auto'; } }); }
initResizer(leftResizer, (v) => { if (v !== undefined) isResizingLeft = v; return isResizingLeft; }, 'left'); initResizer(rightResizer, (v) => { if (v !== undefined) isResizingRight = v; return isResizingRight; }, 'right');
function refreshCanvasSize() {
    setTimeout(() => {
        const { width, height } = canvasWrapper.getBoundingClientRect();
        const currentVpt = Array.isArray(canvas.viewportTransform) ? [...canvas.viewportTransform] : [1, 0, 0, 1, 0, 0];
        canvas.setDimensions({ width, height });
        canvas.calcOffset();
        clampViewportTransform(currentVpt);
        canvas.setViewportTransform(currentVpt);
        canvas.requestRenderAll();
        updatePageActionToolbarPosition();
    }, 50);
}
document.getElementById('left-panel-toggle').addEventListener('click', () => {
    const btn = document.getElementById('left-panel-toggle'); const cols = mainLayout.style.gridTemplateColumns.split(' '); if (cols[0] !== '0px') {
        lastLeftPanelWidth = cols[0]; mainLayout.style.gridTemplateColumns = `0px 0px 1fr 5px ${cols[4]}`;
        document.querySelector('.panel.left')?.classList.add('collapsed'); btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
    } else {
        mainLayout.style.gridTemplateColumns = `${lastLeftPanelWidth} 5px 1fr 5px ${cols[4]}`;
        document.querySelector('.panel.left')?.classList.remove('collapsed'); btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`;
    } refreshCanvasSize();
});
document.getElementById('right-panel-toggle').addEventListener('click', () => {
    const btn = document.getElementById('right-panel-toggle'); const cols = mainLayout.style.gridTemplateColumns.split(' '); if (cols[4] !== '0px') {
        lastRightPanelWidth = cols[4]; mainLayout.style.gridTemplateColumns = `${cols[0]} 5px 1fr 0px 0px`;
        document.querySelector('.panel.right')?.classList.add('collapsed'); btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`;
    } else {
        mainLayout.style.gridTemplateColumns = `${cols[0]} 5px 1fr 5px ${lastRightPanelWidth}`;
        document.querySelector('.panel.right')?.classList.remove('collapsed'); btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
    } refreshCanvasSize();
});
// --- REBUILT: SNAPPING GUIDES ---
const snapThreshold = 10, snapColor = '#ed7062';
const SNAP_MIN_DIMENSION = 8;
let snapLines = [], snapHighlightBox = null;

function getSnapEdges(obj) {
    obj.setCoords();
    const rect = obj.getBoundingRect(true, true);
    return {
        left: rect.left,
        right: rect.left + rect.width,
        top: rect.top,
        bottom: rect.top + rect.height,
        width: rect.width,
        height: rect.height,
        centerX: rect.left + rect.width / 2,
        centerY: rect.top + rect.height / 2
    };
}

function getSnapReferencePoints(target) {
    const selectedMembers = target.type === 'activeSelection'
        ? new Set(target.getObjects())
        : new Set([target]);

    const references = [];
    if (pageRect) references.push(pageRect);

    canvas.getObjects().forEach(obj => {
        if (!obj || !obj.visible || !obj.evented) return;
        if (selectedMembers.has(obj)) return;
        if (obj.excludeFromExport || obj.isSnapLine || obj.isArtboard) return;
        references.push(obj);
    });

    const x = [];
    const y = [];
    references.forEach(obj => {
        const edges = getSnapEdges(obj);
        x.push(
            { value: edges.left, object: obj },
            { value: edges.centerX, object: obj },
            { value: edges.right, object: obj }
        );
        y.push(
            { value: edges.top, object: obj },
            { value: edges.centerY, object: obj },
            { value: edges.bottom, object: obj }
        );
    });

    return { x, y };
}

function findClosestSnap(targetPoints = [], referencePoints = [], zoom = 1) {
    const threshold = snapThreshold / zoom;
    let best = null;

    targetPoints.forEach(targetPoint => {
        referencePoints.forEach(referencePoint => {
            const distance = Math.abs(targetPoint.value - referencePoint.value);
            if (distance >= threshold) return;
            if (!best || distance < best.distance) {
                best = {
                    targetKey: targetPoint.key,
                    targetPoint: targetPoint.value,
                    guidePoint: referencePoint.value,
                    distance,
                    object: referencePoint.object
                };
            }
        });
    });

    return best;
}

function resolveResizeAxisMode(options, axis) {
    const corner = String(options?.transform?.corner || options?.target?.__corner || '').toLowerCase();
    const action = String(options?.transform?.action || '').toLowerCase();
    const origin = String(axis === 'X' ? options?.transform?.originX : options?.transform?.originY || '').toLowerCase();

    if (!action.includes('scale')) return null;

    if (axis === 'X') {
        if (corner === 'mr' || corner === 'tr' || corner === 'br') return 'right';
        if (corner === 'ml' || corner === 'tl' || corner === 'bl') return 'left';
        if (corner === 'mt' || corner === 'mb') return null;
        if (origin === 'left') return 'right';
        if (origin === 'right') return 'left';
        if (origin === 'center' && action.includes('scalex')) return 'center';
        return null;
    }

    if (corner === 'mb' || corner === 'bl' || corner === 'br') return 'bottom';
    if (corner === 'mt' || corner === 'tl' || corner === 'tr') return 'top';
    if (corner === 'ml' || corner === 'mr') return null;
    if (origin === 'top') return 'bottom';
    if (origin === 'bottom') return 'top';
    if (origin === 'center' && action.includes('scaley')) return 'center';
    return null;
}

function getResizeSnapTargetPoints(edges, axisMode, axis) {
    if (!axisMode) return [];

    if (axis === 'X') {
        if (axisMode === 'right') return [{ key: 'right', value: edges.right }, { key: 'centerX', value: edges.centerX }];
        if (axisMode === 'left') return [{ key: 'left', value: edges.left }, { key: 'centerX', value: edges.centerX }];
        if (axisMode === 'center') return [{ key: 'left', value: edges.left }, { key: 'right', value: edges.right }];
        return [];
    }

    if (axisMode === 'bottom') return [{ key: 'bottom', value: edges.bottom }, { key: 'centerY', value: edges.centerY }];
    if (axisMode === 'top') return [{ key: 'top', value: edges.top }, { key: 'centerY', value: edges.centerY }];
    if (axisMode === 'center') return [{ key: 'top', value: edges.top }, { key: 'bottom', value: edges.bottom }];
    return [];
}

function applyResizeSnapForAxis(target, axis, axisMode, snapData, edgesBefore) {
    if (!snapData || !axisMode) return false;

    const isX = axis === 'X';
    const currentSize = isX ? edgesBefore.width : edgesBefore.height;
    if (!Number.isFinite(currentSize) || currentSize <= 0) return false;

    let anchor = null;
    let nextSize = null;

    if (isX) {
        if (axisMode === 'right') {
            anchor = edgesBefore.left;
            if (snapData.targetKey === 'right') nextSize = snapData.guidePoint - anchor;
            if (snapData.targetKey === 'centerX') nextSize = (snapData.guidePoint - anchor) * 2;
        } else if (axisMode === 'left') {
            anchor = edgesBefore.right;
            if (snapData.targetKey === 'left') nextSize = anchor - snapData.guidePoint;
            if (snapData.targetKey === 'centerX') nextSize = (anchor - snapData.guidePoint) * 2;
        } else if (axisMode === 'center') {
            anchor = edgesBefore.centerX;
            if (snapData.targetKey === 'left' || snapData.targetKey === 'right') {
                nextSize = Math.abs(snapData.guidePoint - anchor) * 2;
            }
        }
    } else {
        if (axisMode === 'bottom') {
            anchor = edgesBefore.top;
            if (snapData.targetKey === 'bottom') nextSize = snapData.guidePoint - anchor;
            if (snapData.targetKey === 'centerY') nextSize = (snapData.guidePoint - anchor) * 2;
        } else if (axisMode === 'top') {
            anchor = edgesBefore.bottom;
            if (snapData.targetKey === 'top') nextSize = anchor - snapData.guidePoint;
            if (snapData.targetKey === 'centerY') nextSize = (anchor - snapData.guidePoint) * 2;
        } else if (axisMode === 'center') {
            anchor = edgesBefore.centerY;
            if (snapData.targetKey === 'top' || snapData.targetKey === 'bottom') {
                nextSize = Math.abs(snapData.guidePoint - anchor) * 2;
            }
        }
    }

    if (!Number.isFinite(nextSize) || nextSize < SNAP_MIN_DIMENSION) return false;

    const ratio = nextSize / currentSize;
    if (!Number.isFinite(ratio) || ratio <= 0) return false;

    if (isX) {
        if (target.lockScalingX) return false;
        target.set('scaleX', target.scaleX * ratio);
    } else {
        if (target.lockScalingY) return false;
        target.set('scaleY', target.scaleY * ratio);
    }

    target.setCoords();
    const edgesAfterScale = getSnapEdges(target);

    if (isX) {
        if (axisMode === 'right') target.left += anchor - edgesAfterScale.left;
        else if (axisMode === 'left') target.left += anchor - edgesAfterScale.right;
        else if (axisMode === 'center') target.left += anchor - edgesAfterScale.centerX;
    } else {
        if (axisMode === 'bottom') target.top += anchor - edgesAfterScale.top;
        else if (axisMode === 'top') target.top += anchor - edgesAfterScale.bottom;
        else if (axisMode === 'center') target.top += anchor - edgesAfterScale.centerY;
    }

    target.setCoords();
    return true;
}

function handleSmartSnapping(options) {
    if (!snapEnabled) return;
    if (options?.transform?.action === 'modifyLineEndpoint') return;

    const target = options.target;
    if (!target || target.locked || target.isArtboard) return;

    clearSnapLines();
    clearSnapHighlight();

    const zoom = canvas.getZoom() || 1;
    const targetEdges = getSnapEdges(target);
    const references = getSnapReferencePoints(target);
    const snapX = findClosestSnap([
        { key: 'left', value: targetEdges.left },
        { key: 'centerX', value: targetEdges.centerX },
        { key: 'right', value: targetEdges.right }
    ], references.x, zoom);
    const snapY = findClosestSnap([
        { key: 'top', value: targetEdges.top },
        { key: 'centerY', value: targetEdges.centerY },
        { key: 'bottom', value: targetEdges.bottom }
    ], references.y, zoom);

    if (snapX) target.left -= (snapX.targetPoint - snapX.guidePoint);
    if (snapY) target.top -= (snapY.targetPoint - snapY.guidePoint);
    target.setCoords();

    if (snapX) drawSnapLine({ x1: snapX.guidePoint, y1: -5000, x2: snapX.guidePoint, y2: 5000 });
    if (snapY) drawSnapLine({ y1: snapY.guidePoint, x1: -5000, y2: snapY.guidePoint, x2: 5000 });

    const highlightTarget = [snapX?.object, snapY?.object].find(obj => obj && obj !== pageRect);
    if (highlightTarget) drawSnapHighlight(highlightTarget);
}

function handleResizeSnapping(options) {
    if (!snapEnabled) return;
    if (options?.transform?.action === 'modifyLineEndpoint') return;

    const target = options?.target;
    if (!target || target.locked || target.isArtboard) return;

    const action = String(options?.transform?.action || '').toLowerCase();
    if (!action.includes('scale')) return;

    const normalizedAngle = ((target.angle || 0) % 360 + 360) % 360;
    if (normalizedAngle > 0.001 && normalizedAngle < 359.999) return;

    clearSnapLines();
    clearSnapHighlight();

    const zoom = canvas.getZoom() || 1;
    const targetEdges = getSnapEdges(target);
    const references = getSnapReferencePoints(target);

    const axisModeX = resolveResizeAxisMode(options, 'X');
    const axisModeY = resolveResizeAxisMode(options, 'Y');

    const snapX = findClosestSnap(
        getResizeSnapTargetPoints(targetEdges, axisModeX, 'X'),
        references.x,
        zoom
    );
    const snapY = findClosestSnap(
        getResizeSnapTargetPoints(targetEdges, axisModeY, 'Y'),
        references.y,
        zoom
    );

    const snappedX = applyResizeSnapForAxis(target, 'X', axisModeX, snapX, targetEdges);
    const snappedY = applyResizeSnapForAxis(target, 'Y', axisModeY, snapY, targetEdges);

    if (!snappedX && !snappedY) return;

    if (snappedX && snapX) drawSnapLine({ x1: snapX.guidePoint, y1: -5000, x2: snapX.guidePoint, y2: 5000 });
    if (snappedY && snapY) drawSnapLine({ y1: snapY.guidePoint, x1: -5000, y2: snapY.guidePoint, x2: 5000 });

    const highlightTarget = [
        snappedX ? snapX?.object : null,
        snappedY ? snapY?.object : null
    ].find(obj => obj && obj !== pageRect);
    if (highlightTarget) drawSnapHighlight(highlightTarget);
}

function drawSnapLine(coords) {
    const line = new fabric.Line([coords.x1, coords.y1, coords.x2, coords.y2], {
        stroke: snapColor,
        strokeWidth: 1,
        selectable: false,
        evented: false,
        isSnapLine: true,
        excludeFromExport: true
    });
    snapLines.push(line);
    canvas.add(line);
    line.bringToFront();
}

function drawSnapHighlight(obj) {
    if (!obj) return;

    obj.setCoords(); // update object coordinates

    // get bounding rect in canvas space
    const rect = obj.getBoundingRect(true); // pass `true` to get absolute coordinates including transformations

    clearSnapHighlight();

    snapHighlightBox = new fabric.Rect({
        left: rect.left,
        top: rect.top,
        width: rect.width,
        height: rect.height,
        originX: 'left',
        originY: 'top',
        selectable: false,
        evented: false,
        fill: 'transparent',
        stroke: snapColor,
        strokeWidth: 1,
        isSnapLine: true,
        excludeFromExport: true,
        strokeDashArray: [4, 4],
    });

    canvas.add(snapHighlightBox);
    snapHighlightBox.bringToFront();
}

function clearSnapLines() {
    snapLines.forEach(line => canvas.remove(line));
    snapLines = [];
    clearSnapHighlight();
}

function clearSnapHighlight() {
    if (snapHighlightBox) {
        canvas.remove(snapHighlightBox);
        snapHighlightBox = null;
    }
}

canvas.on('before:transform', () => {
    scheduleOutsideObjectsCleanup.clear();
    clearSnapLines();
});
canvas.on('selection:cleared', () => {
    clearSnapLines();
    scheduleOutsideObjectsCleanup();
});



// components/04-settings-inspector-binding.js
        // --- SETTINGS & API KEY MODAL ---
        const settingsBtn = $('#settingsBtn'); const settingsModal = $('#settingsModal'); const closeSettingsModalBtn = $('#closeSettingsModal');
        settingsBtn.addEventListener('click', openSettingsModal); closeSettingsModalBtn.addEventListener('click', () => settingsModal.style.display = 'none'); settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) { settingsModal.style.display = 'none'; } });
        const openCustomerPortal = async () => { const btn = $('#manageSubscriptionBtn'); if (btn) { btn.disabled = true; btn.textContent = 'Generating link...'; } try { const { data, error } = await supabase.functions.invoke('lemonsqueezy-sub-manager', { body: { action: 'getPortalLink' } }); if (error) throw error; if (data && data.url) window.open(data.url, '_blank'); else throw new Error('Could not generate portal link.'); } catch (error) { alert(`Error: ${error.message}`); } finally { if (btn) { btn.disabled = false; btn.textContent = 'Manage Subscription'; } } };
        async function openSettingsModal() { const settingsContent = $('#settingsContent'); settingsContent.innerHTML = '<p class="muted">Loading account details...</p>'; settingsModal.style.display = 'flex'; const { data: { user } } = await supabase.auth.getUser(); if (!user) { settingsContent.innerHTML = '<p>Please log in to manage your settings.</p>'; return; } const { data: profile, error } = await supabase.from('profiles').select('role').eq('id', user.id).single(); if (error || !profile) { settingsContent.innerHTML = '<p class="error">Could not load your profile.</p>'; return; } const currentTheme = localStorage.getItem('csvlink-theme') || 'light'; let modalHTML = `<div class="settings-section stack"><h4>Appearance</h4><button id="themeToggleBtn" class="btn ghost" style="width: 100%;">${currentTheme === 'dark' ? 'Switch to Light Mode' : 'Switch to Dark Mode'}</button></div><div class="settings-section stack" style="gap: 16px;"><h4>Account</h4><div class="stack"><label for="newPassword">New Password</label><input type="password" id="newPassword" placeholder="Enter new password"></div><div class="stack"><label for="confirmPassword">Confirm Password</label><input type="password" id="confirmPassword" placeholder="Confirm new password"></div><button id="changePasswordBtn" class="btn">Update Password</button><p id="passwordMessage" class="muted" style="text-align:center; margin-top: 4px;"></p></div>`; if (profile.role === 'pro' || profile.role === 'admin') { modalHTML += `<div class="settings-section stack"><h4>Subscription</h4><p class="muted">You are on the Pro plan.</p><button id="manageSubscriptionBtn" class="btn ghost" style="width: 100%;">Manage Subscription</button></div>`; } else { modalHTML += `<div class="settings-section stack"><h4>Upgrade to Pro</h4><p class="muted">Upgrade for API access and unlimited templates.</p><a href="/#pricing" class="btn" style="text-decoration: none;">View Pricing Plans</a></div>`; } if (profile.role === 'pro' || profile.role === 'admin') { modalHTML += `<div class="settings-section stack" style="gap: 16px;"><h4>Developer API Keys</h4><div id="newKeyContainer" class="stack" style="display:none;"><h5>Your New API Key</h5><p class="muted">Copy this key and store it safely. <strong>You will not see it again.</strong></p><div id="newKeyDisplay"></div></div><div class="stack"><h5>Your Existing Keys</h5><div id="existingKeysList" class="stack">Loading...</div></div><button id="generateKeyBtn" class="btn">Generate New API Key</button><p id="keyMessage" class="muted" style="text-align:center; margin-top: 4px;"></p></div>`; } settingsContent.innerHTML = modalHTML; attachSettingsEventListeners(user.id, profile.role); }
        function attachSettingsEventListeners(userId, role) { on('#themeToggleBtn', 'click', toggleTheme); on('#changePasswordBtn', 'click', async () => { const newPassword = $('#newPassword').value, confirmPassword = $('#confirmPassword').value, msgEl = $('#passwordMessage'); if (!newPassword || newPassword !== confirmPassword) { msgEl.textContent = 'Passwords do not match or are empty.'; return; } msgEl.textContent = 'Updating...'; const { error } = await supabase.auth.updateUser({ password: newPassword }); if (error) { msgEl.textContent = `Error: ${error.message}`; } else { msgEl.textContent = 'Password updated successfully!'; $('#newPassword').value = ''; $('#confirmPassword').value = ''; } }); if (role === 'pro' || role === 'admin') { on('#generateKeyBtn', 'click', handleGenerateKey); loadAndDisplayKeys(userId); if ($('#manageSubscriptionBtn')) on('#manageSubscriptionBtn', 'click', openCustomerPortal); } }
        function applyTheme(theme) {
            document.body.classList.toggle('light-mode', theme === 'light');
            localStorage.setItem('csvlink-theme', theme);
            if (pageRect) {
                styleActivePageRect();
                renderCanvasGhostPages();
                canvas.requestRenderAll();
            }
            const icon = $('#themeIconSvg');
            if (icon) {
                icon.innerHTML = (theme === 'light')
                    ? '<circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="M4.93 4.93l1.41 1.41"/><path d="M17.66 17.66l1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M4.93 19.07l1.41-1.41"/><path d="M17.66 6.34l1.41-1.41"/>'
                    : '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
            }
        }
        function toggleTheme() {
            const newTheme = (localStorage.getItem('csvlink-theme') || 'light') === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
            const themeBtn = $('#themeToggleBtn');
            if (themeBtn) themeBtn.textContent = newTheme === 'dark' ? 'Switch to Light Mode' : 'Switch to Dark Mode';
        }
        // toolbar icon toggle
        $('#themeIconBtn')?.addEventListener('click', toggleTheme);
        async function loadAndDisplayKeys(userId) { const list = $('#existingKeysList'); const { data: keys, error } = await supabase.from('api_keys').select('api_key, created_at').eq('user_id', userId); if (error) { list.innerHTML = '<p class="error">Could not load keys.</p>'; return; } if (keys.length === 0) { list.innerHTML = '<p class="muted">No API keys generated.</p>'; } else { list.innerHTML = keys.map(k => `<div class="api-key-item"><span>${k.api_key.substring(0, 11)}...${k.api_key.substring(k.api_key.length - 4)}</span><span class="muted">Created: ${new Date(k.created_at).toLocaleDateString()}</span></div>`).join(''); } }
        async function handleGenerateKey() { const btn = $('#generateKeyBtn'), msg = $('#keyMessage'), container = $('#newKeyContainer'), display = $('#newKeyDisplay'); btn.disabled = true; btn.textContent = 'Generating...'; msg.textContent = ''; container.style.display = 'none'; try { const { data, error } = await supabase.functions.invoke('generate-api-key'); if (error) throw error; display.textContent = data.apiKey; container.style.display = 'block'; const { data: { user } } = await supabase.auth.getUser(); loadAndDisplayKeys(user.id); } catch (error) { msg.textContent = `Error: ${error.message}`; } finally { btn.disabled = false; btn.textContent = 'Generate New API Key'; } }

        // --- INSPECTOR & HELPERS ---
        const inspector = $('#inspector'); const multiInspector = $('#multiSelectInspector');
        const fontPickerState = { search: '', serif: 'all', style: 'all' };
        const MAX_FONT_PREVIEW_RESULTS = 48;
        const FONT_PREVIEW_SAMPLE = 'The quick brown fox';
        canvas.on('selection:created', (e) => {
            if (activeTableCellEditor) closeTableCellEditor({ commit: true });
            if (!e.target?.isTable) clearTableCellSelections();
            refreshInspector(e);
            renderLayers();
            updateFloatingLinker(e.target);
        });
        canvas.on('selection:updated', (e) => {
            if (activeTableCellEditor) closeTableCellEditor({ commit: true });
            if (!e.target?.isTable) clearTableCellSelections();
            refreshInspector(e);
            renderLayers();
            updateFloatingLinker(e.target);
        });
        canvas.on('selection:cleared', () => {
            if (activeTableCellEditor) closeTableCellEditor({ commit: true });
            clearTableCellSelections();
            $('#noSelection').style.display = 'block';
            inspector.style.display = 'none';
            multiInspector.style.display = 'none';
            renderPageInspector();
            renderLayers();
            updateFloatingLinker(null);
        });
        function updateLiveInspector(options) { const target = options.target; if (!target || target.type === 'activeSelection') return; const updateValue = (id, value) => { const el = document.getElementById(id); if (el) el.value = value; }; updateValue('inspector-pos-x', Math.round(target.left)); updateValue('inspector-pos-y', Math.round(target.top)); updateValue('inspector-dim-w', Math.round(target.getScaledWidth())); updateValue('inspector-dim-h', Math.round(target.getScaledHeight())); updateValue('inspector-opacity-slider', target.opacity); updateValue('inspector-opacity-input', target.opacity); updateValue('inspector-stroke-width-slider', target.strokeWidth); updateValue('inspector-stroke-width-input', target.strokeWidth); if (target.rx !== undefined) { updateValue('inspector-corner-radius-slider', target.rx); updateValue('inspector-corner-radius-input', target.rx); } }
        function refreshInspector(e) { const target = e.target || canvas.getActiveObject(); if (!target) return; if (target.type === 'activeSelection') { inspector.style.display = 'none'; multiInspector.style.display = 'grid'; $('#noSelection').style.display = 'none'; renderMultiSelectInspector(target); } else { multiInspector.style.display = 'none'; inspector.style.display = 'grid'; $('#noSelection').style.display = 'none'; renderSingleObjectInspector(target); } }
        function getCommonPropertyValue(objects, property) { const firstValue = objects[0][property]; for (let i = 1; i < objects.length; i++) { if (objects[i][property] !== firstValue) return ''; } return firstValue; }
        function setCommonPropertyValue(objects, property, value) {
            if (property === 'fontFamily') ensureFontFamilyLoaded(value);
            objects.forEach(obj => {
                if (property === 'curveAmount' && obj.type === 'textbox') {
                    setTextboxCurve(obj, value, { skipRender: true });
                    return;
                }
                obj.set(property, value);
                if (obj.type === 'textbox' && ['text', 'fontSize', 'fontFamily', 'fontWeight', 'fontStyle'].includes(property)) {
                    refreshTextboxCurve(obj, { skipRender: true });
                }
                if (property === 'fontFamily' && typeof obj.initDimensions === 'function') {
                    obj.initDimensions();
                    obj.setCoords?.();
                }
            });
            canvas.renderAll();
            requestSaveState();
        }
        function selectSameTypeObjects(baseObject) {
            if (!baseObject) return;
            const matches = canvas.getObjects().filter(obj => {
                if (!obj || obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine || obj.isArtboard) return false;
                if (obj.locked) return false;
                if (baseObject.isTable) return !!obj.isTable;
                if (baseObject.isSvgGroup) return !!obj.isSvgGroup;
                return obj.type === baseObject.type && !obj.isTable && !obj.isSvgGroup;
            });

            if (!matches.length) return;
            if (matches.length === 1) canvas.setActiveObject(matches[0]);
            else canvas.setActiveObject(new fabric.ActiveSelection(matches, { canvas }));
            canvas.requestRenderAll();
            refreshInspector({ target: canvas.getActiveObject() });
        }
        function renderMultiSelectInspector(selection) {
            multiInspector.innerHTML = '';
            const objects = selection.getObjects();

            // Check if all selected objects are text
            const allText = objects.every(obj => obj.type === 'textbox');

            multiInspector.appendChild(section('Actions', [
                buttonRow('Group', () => { if (selection.size() > 1) selection.toGroup(); canvas.requestRenderAll(); }),
                buttonRow('Remove', () => { removeCanvasObjects(objects); })
            ]));

            // Alignment for multiple objects
            multiInspector.appendChild(section('Align Objects', [alignMultipleObjectsButtons()]));
            multiInspector.appendChild(section('Align to Page', [alignToPageButtons(true)]));
            multiInspector.appendChild(section('Distribute', [distributeButtons()]));

            // If all selected are text, show text formatting
            if (allText) {
                const commonFontSize = getCommonPropertyValue(objects, 'fontSize');
                const commonFontFamily = getCommonPropertyValue(objects, 'fontFamily');
                const commonFill = getCommonPropertyValue(objects, 'fill');
                const commonTextAlign = getCommonPropertyValue(objects, 'textAlign');
                const commonFontWeight = getCommonPropertyValue(objects, 'fontWeight');
                const commonFontStyle = getCommonPropertyValue(objects, 'fontStyle');
                const commonUnderline = getCommonPropertyValue(objects, 'underline');
                const commonCurveAmount = getCommonPropertyValue(objects, 'curveAmount');

                multiInspector.appendChild(section('Text Formatting', [
                    inputRow('Font Size', commonFontSize || '', v => setCommonPropertyValue(objects, 'fontSize', parseFloat(v) || 14)),
                    fontFamilyInputRow('Font Family', commonFontFamily || 'Arial', v => setCommonPropertyValue(objects, 'fontFamily', v)),
                    colorInputRow('Text Color', commonFill || '#000000', v => setCommonPropertyValue(objects, 'fill', v)),
                    sliderRow('Curve', Number.isFinite(parseFloat(commonCurveAmount)) ? parseFloat(commonCurveAmount) : 0, v => setCommonPropertyValue(objects, 'curveAmount', parseFloat(v) || 0), { min: -100, max: 100, step: 1 }),
                    buttonGroupRow('Text Style', [
                        { value: 'bold', label: 'B', active: commonFontWeight === 'bold' },
                        { value: 'italic', label: 'I', active: commonFontStyle === 'italic' },
                        { value: 'underline', label: 'U', active: commonUnderline === true }
                    ], null, (v) => {
                        objects.forEach(obj => {
                            if (v === 'bold') obj.set('fontWeight', obj.fontWeight === 'bold' ? 'normal' : 'bold');
                            else if (v === 'italic') obj.set('fontStyle', obj.fontStyle === 'italic' ? 'normal' : 'italic');
                            else if (v === 'underline') obj.set('underline', !obj.underline);
                            refreshTextboxCurve(obj, { skipRender: true });
                        });
                        canvas.renderAll();
                        requestSaveState();
                        refreshInspector({ target: selection });
                    }),
                    buttonGroupRow('Alignment', ['left', 'center', 'right', 'justify'], commonTextAlign || 'left', v => {
                        objects.forEach(obj => {
                            obj.set({ textAlign: v });
                            obj.initDimensions();
                            refreshTextboxCurve(obj, { skipRender: true });
                        });
                        canvas.requestRenderAll();
                        requestSaveState();
                    })
                ]));
            }

            multiInspector.appendChild(section('Common', [
                sliderRow('Opacity', getCommonPropertyValue(objects, 'opacity') ?? 1, (v) => setCommonPropertyValue(objects, 'opacity', v), { min: 0, max: 1, step: 0.01 }),
                colorInputRow('Stroke Color', getCommonPropertyValue(objects, 'stroke') ?? '', v => setCommonPropertyValue(objects, 'stroke', v)),
                sliderRow('Stroke Width', getCommonPropertyValue(objects, 'strokeWidth') ?? 0, (v) => setCommonPropertyValue(objects, 'strokeWidth', v), { min: 0, max: 50, step: 1 })
            ]));
        }



        function setObjectDimensions(obj, w, h, opts = {}) {
            const lockWidth = !!opts.lockWidth;
            const minSize = 1;
            if (!obj || !obj.width || !obj.height) return;
            const newW = Math.max(minSize, Number(w) || obj.getScaledWidth());
            const newH = Math.max(minSize, Number(h) || obj.getScaledHeight());

            const baseW = obj.width;
            const baseH = obj.height;

            if (!lockWidth) obj.scaleX = newW / baseW;
            obj.scaleY = newH / baseH;
            obj.setCoords();
        }

        function dimensionsRow(obj) {
            const isTextbox = obj?.type === 'textbox';
            const w = document.createElement('div');
            w.className = 'stack full-width';
            w.innerHTML = `<label>Dimensions</label>`;
            const r = document.createElement('div');
            r.className = 'row';

            const x = document.createElement('input');
            x.type = 'number';
            x.value = Math.round(obj.getScaledWidth());
            x.id = 'inspector-dim-w';

            const y = document.createElement('input');
            y.type = 'number';
            y.value = Math.round(obj.getScaledHeight());
            y.id = 'inspector-dim-h';

            if (isTextbox) {
                x.disabled = true;
                x.title = 'Text box width is locked. Use the text box handles to resize width.';
                x.style.opacity = '0.6';
            }

            const update = () => {
                setObjectDimensions(obj, x.value, y.value, { lockWidth: isTextbox });
                canvas.requestRenderAll();
                updateLiveInspector({ target: canvas.getActiveObject() });
            };
            const finalUpdate = () => { update(); requestSaveState(); };
            x.oninput = update; y.oninput = update;
            x.onchange = finalUpdate; y.onchange = finalUpdate;

            r.append(x, y);
            w.appendChild(r);
            return w;
        }

        function renderSingleObjectInspector(o) {
            inspector.innerHTML = '';
            const actions = [];
            if (o.type === 'group' && !o.isTable && !o.isSvgGroup) actions.push(buttonRow('Ungroup', () => o.toActiveSelection()));
            actions.push(buttonRow('Select Same Type', () => selectSameTypeObjects(o)));
            actions.push(buttonRow('Remove', () => removeCanvasObjects([o])));
            inspector.appendChild(section('Actions', actions));

            inspector.appendChild(section('Advanced Links', [buttonRow(`Manage Links (${getBindingsFor(o).length})`, () => { selectedObjectForManager = o; openDataLinksManager(); })]));
            if (o.type === 'image') inspector.appendChild(section('Image', [buttonRow('Crop Image', () => openVisualCropper(o))]));
            if (['rect', 'image', 'circle', 'triangle', 'polygon'].includes(o.type)) { const shapeProps = []; if (['rect', 'image'].includes(o.type)) shapeProps.push(sliderRow('Corner Radius', o.rx ?? 0, (v) => o.set({ rx: v, ry: v }), { min: 0, max: Math.min(o.width, o.height) / 2, step: 1 })); inspector.appendChild(section('Shape Properties', shapeProps)); }

            if (o.isSvgGroup) {
                inspector.appendChild(section('SVG Style', [
                    colorInputRow('Fill', o.fill, v => { o.set('fill', v); o.forEachObject(sub => { if (sub.fill !== 'none') sub.set({ fill: v }) }); }),
                    colorInputRow('Stroke', o.stroke, v => { o.set('stroke', v); o.forEachObject(sub => sub.set({ stroke: v })); }),
                    sliderRow('Stroke Width', o.strokeWidth ?? 1, v => {
                        o.set({ strokeWidth: parseFloat(v) });
                        o.forEachObject(sub => sub.set({ strokeWidth: parseFloat(v) }));
                        // Fix for pivot shift: setCoords and recalibrate if group
                        o.setCoords();
                        if (o.type === 'group') {
                            // This re-calculates the group size based on children
                            const center = o.getCenterPoint();
                            o.addWithUpdate();
                            o.setPositionByOrigin(center, 'center', 'center');
                        }
                        canvas.renderAll();
                        requestSaveState();
                    }, { min: 0, max: 20, step: 0.5 })
                ]));
            }

            if (['rect', 'triangle', 'circle', 'polygon', 'path'].includes(o.type)) { inspector.appendChild(section('Fill', [colorInputRow('Color', o.fill, v => o.set({ fill: v })), buttonRow('Fill with Image', () => { editingFillObject = o; $('#imageFillUpload').click(); })])); $('#imageFillUpload').onchange = e => { if (!e.target.files?.[0] || !editingFillObject) return; const reader = new FileReader(); reader.onload = ev => { fabric.Image.fromURL(ev.target.result, img => { editingFillObject.set('fill', new fabric.Pattern({ source: img.getElement(), repeat: 'repeat' })); canvas.renderAll(); requestSaveState(); }, { crossOrigin: 'anonymous' }); }; reader.readAsDataURL(e.target.files[0]); e.target.value = ''; }; }
            if (['rect', 'triangle', 'circle', 'polygon', 'path', 'line'].includes(o.type)) {
                inspector.appendChild(section('Stroke', [
                    colorInputRow('Color', o.stroke || '#000000', v => {
                        o.set({ stroke: v || null });
                    }),
                    sliderRow('Width', o.strokeWidth ?? 1, v => {
                        o.set({ strokeWidth: Math.max(0, parseFloat(v) || 0) });
                        o.setCoords();
                    }, { min: 0, max: 40, step: 0.5 })
                ]));
            }

            if (o.isTable) {
                ensureTableCellData(o);
                const selectedCells = getSelectedTableCellIndices(o);
                const singleSelectedCellIndex = selectedCells.length === 1 ? selectedCells[0] : -1;
                const cellTextBinding = singleSelectedCellIndex >= 0
                    ? getBindingsFor(o).find(b => b.property === 'Cell Text' && getNormalizedBindingCellIndex(o, b) === singleSelectedCellIndex)
                    : null;
                const selectionInfo = document.createElement('div');
                selectionInfo.className = 'full-width muted';
                selectionInfo.style.fontSize = '11px';
                selectionInfo.style.marginBottom = '6px';
                selectionInfo.textContent = selectedCells.length
                    ? `${selectedCells.length} cell(s) selected`
                    : 'No cells selected. Click table cells (Shift/Ctrl for multi-select). Double-click a cell to edit.';

                const cellLinkInfo = document.createElement('div');
                cellLinkInfo.className = 'full-width muted';
                cellLinkInfo.style.fontSize = '11px';
                if (singleSelectedCellIndex < 0) {
                    cellLinkInfo.textContent = 'Data Link: select exactly one cell to link it to a data column.';
                } else {
                    cellLinkInfo.textContent = `Data Link ${tableCellRefLabel(o, singleSelectedCellIndex)}: ${cellTextBinding?.column || 'not linked'}`;
                }

                const tableRows = [
                    selectionInfo,
                    cellLinkInfo,
                    buttonRow('Link Selected Cell To Column', () => {
                        if (singleSelectedCellIndex < 0) {
                            showNotification('Select exactly one table cell first.');
                            return;
                        }
                        let binding = cellTextBinding;
                        if (!binding) {
                            binding = saveBinding(o, { column: '', property: 'Cell Text', cellIndex: singleSelectedCellIndex });
                        } else {
                            binding.cellIndex = singleSelectedCellIndex;
                            requestSaveState();
                        }
                        openColumnSelectionModal(o, binding, {
                            onLinked: () => {
                                if (dataLinksManagerModal && dataLinksManagerModal.style.display === 'flex') renderDataLinksManager();
                                refreshInspector({ target: o });
                            }
                        });
                    }),
                    buttonRow('Remove Selected Cell Link', () => {
                        if (singleSelectedCellIndex < 0 || !cellTextBinding) {
                            showNotification('No linked cell selected.');
                            return;
                        }
                        removeBinding(o, cellTextBinding);
                        refreshInspector({ target: o });
                    }),
                    buttonRow('Select All Cells', () => {
                        setSelectedTableCells(o, Array.from({ length: o.rows * o.cols }, (_, i) => i));
                        refreshInspector({ target: o });
                    }),
                    buttonRow('Clear Cell Selection', () => {
                        o._selectedCells = new Set();
                        refreshTableSelectionVisual(o);
                        canvas.requestRenderAll();
                        refreshInspector({ target: o });
                    }),
                    inputRow('Rows', o.rows || 1, v => {
                        const targetRows = Math.max(1, parseInt(v, 10) || 1);
                        resizeTableCellData(o, targetRows, Math.max(1, o.cols || 1));
                        o.rowHeights = Array.from({ length: targetRows }, (_, i) => o.rowHeights?.[i] || o.rowHeights?.[0] || 50);
                        o.headerRows = Math.min(o.headerRows || 0, targetRows);
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }, 'number'),
                    inputRow('Columns', o.cols || 1, v => {
                        const targetCols = Math.max(1, parseInt(v, 10) || 1);
                        resizeTableCellData(o, Math.max(1, o.rows || 1), targetCols);
                        o.colWidths = Array.from({ length: targetCols }, (_, i) => o.colWidths?.[i] || o.colWidths?.[0] || 120);
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }, 'number'),
                    inputRow('Header Rows', o.headerRows || 0, v => {
                        o.headerRows = Math.max(0, Math.min(o.rows || 1, parseInt(v, 10) || 0));
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }, 'number'),
                    colorInputRow('Header Fill', o.headerFill || '#f3f4f6', v => {
                        o.headerFill = v;
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }),
                    colorInputRow('Body Fill', o.bodyFill || '#ffffff', v => {
                        o.bodyFill = v;
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }),
                    colorInputRow('Border Color', o.borderColor || '#333333', v => {
                        o.borderColor = v;
                        applyToSelectedTableCells(o, (cell) => { cell.borderColor = v || '#333333'; }, { fallbackAll: true });
                    }),
                    sliderRow('Border Width', o.borderWidth || 1, v => {
                        o.borderWidth = parseFloat(v);
                        applyToSelectedTableCells(o, (cell) => { cell.borderWidth = Math.max(0.5, parseFloat(v) || 1); }, { fallbackAll: true });
                    }, { min: 0, max: 20, step: 0.5 }),
                    inputRow('Cell Text', getCommonSelectedTableCellValue(o, 'text', { fallbackAll: false }) || '', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.text = v; }, { fallbackAll: true });
                    }),
                    colorInputRow('Cell Fill', getCommonSelectedTableCellValue(o, 'fill', { fallbackAll: false }) || '#ffffff', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.fill = v || '#ffffff'; }, { fallbackAll: true });
                    }),
                    colorInputRow('Cell Text Color', getCommonSelectedTableCellValue(o, 'textColor', { fallbackAll: false }) || '#111111', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.textColor = v || '#111111'; }, { fallbackAll: true });
                    }),
                    sliderRow('Cell Font Size', getCommonSelectedTableCellValue(o, 'fontSize', { fallbackAll: false }) || 14, v => {
                        applyToSelectedTableCells(o, (cell) => { cell.fontSize = Math.max(6, parseFloat(v) || 14); }, { fallbackAll: true });
                    }, { min: 6, max: 96, step: 1 }),
                    buttonGroupRow('Cell H Align', ['left', 'center', 'right', 'justify'], getCommonSelectedTableCellValue(o, 'textAlign', { fallbackAll: false }) || '', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.textAlign = v; }, { fallbackAll: true });
                    }),
                    buttonGroupRow('Cell V Align', ['top', 'middle', 'bottom'], getCommonSelectedTableCellValue(o, 'textVAlign', { fallbackAll: false }) || '', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.textVAlign = v; }, { fallbackAll: true });
                    }),
                    buttonRow('Center Text In Cell', () => {
                        applyToSelectedTableCells(o, (cell) => {
                            cell.textAlign = 'center';
                            cell.textVAlign = 'middle';
                        }, { fallbackAll: true });
                    }),
                    iconButtonsRow('Borders', [
                        { icon: tableActionIcon('top'), label: 'Top', title: 'Toggle top border', onClick: () => toggleSelectedTableBorderSide(o, 'top') },
                        { icon: tableActionIcon('right'), label: 'Right', title: 'Toggle right border', onClick: () => toggleSelectedTableBorderSide(o, 'right') },
                        { icon: tableActionIcon('bottom'), label: 'Bottom', title: 'Toggle bottom border', onClick: () => toggleSelectedTableBorderSide(o, 'bottom') },
                        { icon: tableActionIcon('left'), label: 'Left', title: 'Toggle left border', onClick: () => toggleSelectedTableBorderSide(o, 'left') }
                    ]),
                    iconButtonsRow('Structure', [
                        { icon: tableActionIcon('addRow'), label: 'Row+', title: 'Add row', onClick: () => addTableRow(o) },
                        { icon: tableActionIcon('removeRow'), label: 'Row-', title: 'Remove row', onClick: () => removeTableRow(o) },
                        { icon: tableActionIcon('addCol'), label: 'Col+', title: 'Add column', onClick: () => addTableColumn(o) },
                        { icon: tableActionIcon('removeCol'), label: 'Col-', title: 'Remove column', onClick: () => removeTableColumn(o) }
                    ])
                ];
                inspector.appendChild(section('Table', tableRows));
            }

            if (o.type === 'textbox') {
                inspector.appendChild(section('Text', [
                    inputRow('Content', o.text, v => {
                        o.set({ text: v });
                        refreshTextboxCurve(o, { skipRender: true });
                    }, 'textarea'),
                    inputRow('Font Size', o.fontSize, v => {
                        o.set({ fontSize: parseFloat(v) });
                        refreshTextboxCurve(o, { skipRender: true });
                    }),
                    fontFamilyInputRow('Font Family', o.fontFamily, (selectedFamily) => {
                        o.set({ fontFamily: selectedFamily });
                        if (typeof o.initDimensions === 'function') {
                            o.initDimensions();
                            o.setCoords?.();
                        }
                        refreshTextboxCurve(o, { skipRender: true });
                        canvas.renderAll();
                        requestSaveState();
                    }, { showUploadButton: true }),
                    colorInputRow('Fill Color', o.fill, v => o.set({ fill: v })),
                    sliderRow('Curve', Number.isFinite(parseFloat(o.curveAmount)) ? parseFloat(o.curveAmount) : 0, v => {
                        setTextboxCurve(o, parseFloat(v) || 0, { skipRender: true });
                    }, { min: -100, max: 100, step: 1 }),
                    buttonGroupRow('Text Style', [
                        { value: 'bold', label: 'B', active: o.fontWeight === 'bold' },
                        { value: 'italic', label: 'I', active: o.fontStyle === 'italic' },
                        { value: 'underline', label: 'U', active: o.underline === true }
                    ], null, (v) => {
                        if (v === 'bold') o.set('fontWeight', o.fontWeight === 'bold' ? 'normal' : 'bold');
                        else if (v === 'italic') o.set('fontStyle', o.fontStyle === 'italic' ? 'normal' : 'italic');
                        else if (v === 'underline') o.set('underline', !o.underline);
                        refreshTextboxCurve(o, { skipRender: true });
                        canvas.renderAll();
                        requestSaveState();
                        refreshInspector({ target: o });
                    }),
                    buttonGroupRow('Alignment', ['left', 'center', 'right', 'justify'], o.textAlign, v => {
                        o.set({ textAlign: v });
                        o.initDimensions();
                        refreshTextboxCurve(o, { skipRender: true });
                        canvas.requestRenderAll();
                    })
                ]));
            }
            inspector.appendChild(section('Common', [
                xyInputRow('Position', { x: o.left, y: o.top }, (p) => o.set({ left: p.x, top: p.y })),
                xyInputRow('Dimensions', { w: o.getScaledWidth(), h: o.getScaledHeight() }, (d) => { setObjectDimensions(o, d.w, d.h); }),
                sliderRow('Opacity', o.opacity ?? 1, (v) => o.set({ opacity: v }), { min: 0, max: 1, step: 0.01 }),
            ]));
            inspector.appendChild(section('Align to Page', [alignToPageButtons()]));
        }
        function renderPageInspector() {
            const pageRect = canvas.getObjects().find(o => o.oid === 'pageRect');
            if (!pageRect) return;
            const container = document.getElementById('pageInspector');
            if (!container) return;
            container.innerHTML = '';
            const pageProps = section('Page Style', [
                colorInputRow('Background Color', pageRect.fill || '#ffffff', (v) => {
                    pageRect.set({ fill: v });
                    canvas.requestRenderAll();
                    requestSaveState();
                }),
                buttonRow('Set Background Image', () => {
                    const up = document.getElementById('imageFillUpload');
                    if (!up) return;
                    editingFillObject = pageRect;
                    up.click();
                })
            ]);
            container.appendChild(pageProps);
        }
        on('#loadTemplateBtnPage', 'click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleTemplateLoader(e.currentTarget || e.target);
        });
        function section(title, rows) { const w = document.createElement('div'); w.className = 'stack'; w.innerHTML = `<h3>${title}</h3>`; const g = document.createElement('div'); g.className = 'prop-grid'; rows.forEach(r => g.appendChild(r)); w.appendChild(g); return w; }
        function inputRow(label, value, onChange, type = 'text') { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const i = document.createElement(type === 'textarea' ? 'textarea' : 'input'); if (type !== 'textarea') i.type = type; i.value = value ?? ''; i.oninput = () => { onChange(i.value); canvas.requestRenderAll(); }; i.onchange = () => requestSaveState(); if (type === 'textarea') i.rows = 3; w.appendChild(i); return w; }
        function xyInputRow(label, values, onChange) { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const r = document.createElement('div'); r.className = 'row'; const x = document.createElement('input'); x.type = 'number'; x.value = Math.round(values.x ?? values.w ?? 0); const y = document.createElement('input'); y.type = 'number'; y.value = Math.round(values.y ?? values.h ?? 0); if (label === 'Position') { x.id = 'inspector-pos-x'; y.id = 'inspector-pos-y'; } else if (label === 'Dimensions') { x.id = 'inspector-dim-w'; y.id = 'inspector-dim-h'; } const update = () => { const v = label === 'Position' ? { x: parseFloat(x.value), y: parseFloat(y.value) } : { w: parseFloat(x.value), h: parseFloat(y.value) }; onChange(v); canvas.requestRenderAll(); updateLiveInspector({ target: canvas.getActiveObject() }); }; const finalUpdate = () => { update(); requestSaveState(); }; x.oninput = update; y.oninput = update; x.onchange = finalUpdate; y.onchange = finalUpdate; r.append(x, y); w.appendChild(r); return w; }
        function sliderRow(label, value, onChange, { min = 0, max = 100, step = 1 }, idPrefix = null) { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const r = document.createElement('div'); r.className = 'slider-wrapper'; const s = document.createElement('input'); s.type = 'range'; s.min = min; s.max = max; s.step = step; s.value = value; const n = document.createElement('input'); n.type = 'number'; n.min = min; n.max = max; n.step = step; n.value = value; const idBase = idPrefix || 'inspector-' + label.toLowerCase().replace(/\s+/g, '-'); s.id = idBase + '-slider'; n.id = idBase + '-input'; const update = (val) => { onChange(val); canvas.requestRenderAll(); }; s.oninput = () => { n.value = s.value; update(parseFloat(s.value)); }; n.oninput = () => { s.value = n.value; update(parseFloat(n.value)); }; s.onchange = () => requestSaveState(); n.onchange = () => requestSaveState(); r.append(s, n); w.appendChild(r); return w; }
        function selectRow(label, opts, val, onChange) { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const s = document.createElement('select'); opts.forEach(opt => s.innerHTML += `<option value="${opt}" ${opt == val ? 'selected' : ''}>${opt}</option>`); s.onchange = e => { onChange(e.target.value); canvas.renderAll(); requestSaveState(); }; w.appendChild(s); return w; }
        function fontFamilyInputRow(label, value, onCommit, options = {}) {
            const showUploadButton = !!options.showUploadButton;
            const w = document.createElement('div');
            w.className = 'stack full-width';
            w.innerHTML = `<label>${label}</label>`;

            const topRow = document.createElement('div');
            topRow.className = 'row';
            topRow.style.gap = '8px';

            const selectedInput = document.createElement('input');
            selectedInput.type = 'text';
            selectedInput.value = value ?? '';
            selectedInput.placeholder = 'Selected font family';
            selectedInput.autocomplete = 'off';
            selectedInput.spellcheck = false;
            selectedInput.style.flex = '1';
            selectedInput.style.fontFamily = `"${normalizeFontFamilyName(selectedInput.value) || 'Inter'}", var(--font), sans-serif`;

            const commitSelected = () => {
                const nextValue = normalizeFontFamilyName(selectedInput.value);
                if (!nextValue) return;
                selectedInput.value = nextValue;
                selectedInput.style.fontFamily = `"${nextValue}", var(--font), sans-serif`;
                addFontFamilyToRegistry(nextValue);
                ensureFontFamilyLoaded(nextValue);
                onCommit(nextValue);
            };

            selectedInput.addEventListener('keydown', (e) => {
                if (e.key !== 'Enter') return;
                e.preventDefault();
                selectedInput.blur();
            });
            selectedInput.addEventListener('change', commitSelected);

            topRow.appendChild(selectedInput);

            if (showUploadButton) {
                const btn = document.createElement('button');
                btn.className = 'btn ghost icon-only';
                btn.title = 'Upload Font';
                btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>';
                btn.onclick = () => $('#fontUpload').click();
                topRow.appendChild(btn);
            }

            const controlsRow = document.createElement('div');
            controlsRow.className = 'row';
            controlsRow.style.gap = '8px';

            const searchInput = document.createElement('input');
            searchInput.type = 'search';
            searchInput.value = fontPickerState.search || '';
            searchInput.placeholder = 'Search fonts...';
            searchInput.style.flex = '1';
            searchInput.autocomplete = 'off';
            searchInput.spellcheck = false;

            const serifSelect = document.createElement('select');
            serifSelect.style.width = '120px';
            getFontSerifFilterOptions().forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.label;
                serifSelect.appendChild(option);
            });
            serifSelect.value = fontPickerState.serif || 'all';

            const styleSelect = document.createElement('select');
            styleSelect.style.width = '130px';
            getFontStyleFilterOptions().forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.label;
                styleSelect.appendChild(option);
            });
            styleSelect.value = fontPickerState.style || 'all';

            controlsRow.append(serifSelect, styleSelect);

            const searchRow = document.createElement('div');
            searchRow.className = 'row';
            searchRow.style.gap = '8px';
            searchRow.appendChild(searchInput);

            const results = document.createElement('div');
            results.style.maxHeight = '180px';
            results.style.overflowY = 'auto';
            results.style.border = '1px solid var(--border)';
            results.style.borderRadius = '10px';
            results.style.padding = '4px';
            results.style.background = 'var(--panel)';

            const formatCategoryLabel = (category) => {
                const normalized = normalizeFontCategory(category);
                if (normalized === 'sans-serif') return 'Sans';
                if (normalized === 'serif') return 'Serif';
                if (normalized === 'display') return 'Display';
                if (normalized === 'handwriting') return 'Handwriting';
                if (normalized === 'monospace') return 'Mono';
                return normalized;
            };

            const applyFont = (fontFamily) => {
                const nextValue = normalizeFontFamilyName(fontFamily);
                if (!nextValue) return;
                selectedInput.value = nextValue;
                selectedInput.style.fontFamily = `"${nextValue}", var(--font), sans-serif`;
                addFontFamilyToRegistry(nextValue);
                ensureFontFamilyLoaded(nextValue);
                onCommit(nextValue);
            };

            const renderResults = () => {
                const query = String(searchInput.value || '').trim().toLowerCase();
                const activeSerif = String(serifSelect.value || 'all');
                const activeStyle = String(styleSelect.value || 'all');
                fontPickerState.search = searchInput.value || '';
                fontPickerState.serif = activeSerif;
                fontPickerState.style = activeStyle;

                const matched = FONT_LIST.filter(fontName => {
                    if (query && !String(fontName).toLowerCase().includes(query)) return false;
                    if (!fontMatchesSerifFilter(fontName, activeSerif)) return false;
                    if (!fontMatchesStyleFilter(fontName, activeStyle)) return false;
                    return true;
                });

                results.innerHTML = '';
                if (!matched.length) {
                    const empty = document.createElement('div');
                    empty.className = 'muted';
                    empty.style.fontSize = '11px';
                    empty.style.padding = '8px';
                    empty.textContent = 'No fonts match this search/filter.';
                    results.appendChild(empty);
                    return;
                }

                const visible = matched.slice(0, MAX_FONT_PREVIEW_RESULTS);
                visible.forEach((fontName, idx) => {
                    const btn = document.createElement('button');
                    btn.className = 'btn ghost';
                    btn.type = 'button';
                    btn.style.width = '100%';
                    btn.style.justifyContent = 'space-between';
                    btn.style.alignItems = 'center';
                    btn.style.height = 'auto';
                    btn.style.padding = '6px 8px';
                    btn.style.marginBottom = '4px';
                    btn.style.display = 'flex';
                    btn.style.gap = '8px';

                    const left = document.createElement('div');
                    left.style.flex = '1';
                    left.style.minWidth = '0';

                    const family = document.createElement('div');
                    family.textContent = fontName;
                    family.style.fontFamily = `"${fontName}", var(--font), sans-serif`;
                    family.style.fontSize = '14px';
                    family.style.textAlign = 'left';
                    family.style.whiteSpace = 'nowrap';
                    family.style.overflow = 'hidden';
                    family.style.textOverflow = 'ellipsis';

                    const sample = document.createElement('div');
                    sample.textContent = FONT_PREVIEW_SAMPLE;
                    sample.style.fontFamily = `"${fontName}", var(--font), sans-serif`;
                    sample.style.fontSize = '11px';
                    sample.style.opacity = '0.8';
                    sample.style.textAlign = 'left';
                    sample.style.whiteSpace = 'nowrap';
                    sample.style.overflow = 'hidden';
                    sample.style.textOverflow = 'ellipsis';

                    left.append(family, sample);

                    const badge = document.createElement('span');
                    badge.className = 'muted';
                    badge.style.fontSize = '10px';
                    badge.style.whiteSpace = 'nowrap';
                    badge.textContent = formatCategoryLabel(getFontCategory(fontName));

                    btn.append(left, badge);
                    btn.onclick = () => applyFont(fontName);
                    btn.onmouseenter = () => { ensureFontFamilyLoaded(fontName); };
                    results.appendChild(btn);

                    if (idx < 8) ensureFontFamilyLoaded(fontName);
                });

                if (matched.length > visible.length) {
                    const note = document.createElement('div');
                    note.className = 'muted';
                    note.style.fontSize = '10px';
                    note.style.textAlign = 'center';
                    note.style.padding = '4px 0 2px';
                    note.textContent = `Showing ${visible.length} of ${matched.length} matches. Refine search/filter.`;
                    results.appendChild(note);
                }
            };

            searchInput.addEventListener('input', renderResults);
            serifSelect.addEventListener('change', renderResults);
            styleSelect.addEventListener('change', renderResults);

            w.append(topRow, controlsRow, searchRow, results);
            renderResults();
            return w;
        }
        function buttonRow(label, onClick) { const w = document.createElement('div'); w.className = 'full-width'; const b = document.createElement('button'); b.className = 'btn ghost'; b.textContent = label; b.onclick = onClick; b.style.width = '100%'; w.appendChild(b); return w; }
        function tableActionIcon(kind) {
            const icons = {
                addRow: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="14" height="14"/><line x1="3" y1="11" x2="17" y2="11"/><line x1="20" y1="16" x2="20" y2="22"/><line x1="17" y1="19" x2="23" y2="19"/></svg>',
                removeRow: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="14" height="14"/><line x1="3" y1="11" x2="17" y2="11"/><line x1="17" y1="19" x2="23" y2="19"/></svg>',
                addCol: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="14" height="14"/><line x1="10" y1="4" x2="10" y2="18"/><line x1="20" y1="16" x2="20" y2="22"/><line x1="17" y1="19" x2="23" y2="19"/></svg>',
                removeCol: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="14" height="14"/><line x1="10" y1="4" x2="10" y2="18"/><line x1="17" y1="19" x2="23" y2="19"/></svg>',
                top: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16"/><line x1="4" y1="4" x2="20" y2="4" stroke-width="3"/></svg>',
                right: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16"/><line x1="20" y1="4" x2="20" y2="20" stroke-width="3"/></svg>',
                bottom: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16"/><line x1="4" y1="20" x2="20" y2="20" stroke-width="3"/></svg>',
                left: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16"/><line x1="4" y1="4" x2="4" y2="20" stroke-width="3"/></svg>'
            };
            return icons[kind] || '';
        }
        function iconButtonsRow(label, items) {
            const w = document.createElement('div');
            w.className = 'stack full-width';
            w.innerHTML = `<label>${label}</label>`;
            const r = document.createElement('div');
            r.className = 'row';
            r.style.gap = '6px';
            items.forEach(item => {
                const b = document.createElement('button');
                b.className = 'btn ghost';
                b.style.flex = '1';
                b.style.padding = '0 8px';
                b.style.height = '30px';
                b.title = item.title || item.label || '';
                b.innerHTML = `${item.icon || ''}${item.label ? `<span>${item.label}</span>` : ''}`;
                b.onclick = item.onClick;
                r.appendChild(b);
            });
            w.appendChild(r);
            return w;
        }
        function colorInputRow(label, value, onChange) {
            const w = document.createElement('div');
            w.className = 'stack full-width';
            w.innerHTML = `<label>${label}</label>`;
            const r = document.createElement('div');
            r.className = 'color-picker-wrapper';

            const t = document.createElement('input');
            t.type = 'text';
            t.value = value || '';
            t.placeholder = 'No color';

            const c = document.createElement('input');
            c.type = 'color';
            c.value = value || '#000000';

            // "Clear Color" button
            const clearBtn = document.createElement('button');
            clearBtn.className = 'btn ghost';
            clearBtn.textContent = '×';
            clearBtn.title = 'Clear color (set to null)';
            clearBtn.style.cssText = 'padding: 4px 8px; font-size: 16px; line-height: 1;';
            clearBtn.onclick = (e) => {
                e.preventDefault();
                t.value = '';
                onChange(null);
                canvas.requestRenderAll();
                requestSaveState();
            };

            const update = (val) => { onChange(val); canvas.requestRenderAll(); };
            t.oninput = () => { if (t.value) c.value = t.value; update(t.value || null); };
            c.oninput = () => { t.value = c.value; update(c.value); };
            t.onchange = () => requestSaveState();
            c.onchange = () => requestSaveState();

            r.append(t, c, clearBtn);
            w.appendChild(r);
            return w;
        }
        function buttonGroupRow(label, options, value, onChange) {
            const w = document.createElement('div');
            w.className = 'stack full-width';
            w.innerHTML = `<label>${label}</label>`;
            const r = document.createElement('div');
            r.className = 'align-buttons';
            r.style.gridTemplateColumns = `repeat(${options.length}, 32px)`;

            const icons = {
                left: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/></svg>',
                center: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/></svg>',
                right: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M9 15v2h12v-2H9zm-6 6h18v-2H3v2zm6-8h12v-2H9v2zM3 7v2h18V7H3zM3 3v2h18V3H3z"/></svg>',
                justify: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/></svg>'
            };

            options.forEach(opt => {
                const isObject = typeof opt === 'object';
                const val = isObject ? opt.value : opt;
                const label = isObject ? opt.label : opt;
                const isActive = isObject ? opt.active : (val === value);

                const btn = document.createElement('button');
                btn.className = 'btn ghost';
                if (isActive) btn.classList.add('active');

                // Use icon if available, otherwise use label
                if (icons[val]) {
                    btn.innerHTML = icons[val];
                } else {
                    btn.textContent = label;
                    btn.style.fontWeight = val === 'bold' ? 'bold' : 'normal';
                    btn.style.fontStyle = val === 'italic' ? 'italic' : 'normal';
                    btn.style.textDecoration = val === 'underline' ? 'underline' : 'none';
                }

                btn.onclick = () => {
                    onChange(val);
                    // For toggle buttons (bold, italic, underline), don't clear others
                    if (!isObject || !opt.hasOwnProperty('active')) {
                        r.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    }
                };
                r.appendChild(btn);
            });
            w.appendChild(r);
            return w;
        }

        // --- VISUAL CROPPER ---
        function initializeVisualCropper() { const modal = $('#visualCropModal'); const container = $('#visualCropContainer'); cropCanvas = new fabric.Canvas('cropCanvas', { selection: false, backgroundColor: '#222' }); new ResizeObserver(() => { const { width, height } = container.getBoundingClientRect(); cropCanvas.setWidth(width).setHeight(height); }).observe(container); on('#closeVisualCropModal', 'click', closeVisualCropper); on('#cancelCropBtn', 'click', closeVisualCropper); on('#applyCropBtn', 'click', applyCrop); }
        function openVisualCropper(imageObject) { croppingImage = imageObject; const modal = $('#visualCropModal'); modal.style.display = 'flex'; cropCanvas.clear(); const { width: cW, height: cH } = $('#visualCropContainer').getBoundingClientRect(); cropCanvas.setWidth(cW).setHeight(cH); const imgEl = croppingImage.getElement(); const scale = Math.min(cW / imgEl.naturalWidth, cH / imgEl.naturalHeight) * 0.8; const imgInstance = new fabric.Image(imgEl, { selectable: false, evented: false, scaleX: scale, scaleY: scale }); cropCanvas.add(imgInstance); cropCanvas.centerObject(imgInstance); cropCanvas.add(new fabric.Rect({ fill: 'rgba(0,0,0,0.3)', width: cW, height: cH, selectable: false, evented: false })); const cropBox = new fabric.Rect({ left: imgInstance.left, top: imgInstance.top, width: imgInstance.getScaledWidth(), height: imgInstance.getScaledHeight(), fill: 'transparent', stroke: '#fff', strokeWidth: 2, cornerColor: '#fff', cornerSize: 12, transparentCorners: false, }); cropCanvas.add(cropBox); cropCanvas.setActiveObject(cropBox); cropCanvas.renderAll(); }
        function closeVisualCropper() { $('#visualCropModal').style.display = 'none'; croppingImage = null; cropCanvas.clear(); }
        function applyCrop() { if (!croppingImage || !cropCanvas.getActiveObject()) return; const cropBox = cropCanvas.getActiveObject(); const imgInstance = cropCanvas.getObjects('image')[0]; const cropX = (cropBox.left - imgInstance.left) / imgInstance.scaleX; const cropY = (cropBox.top - imgInstance.top) / imgInstance.scaleY; const width = cropBox.getScaledWidth() / imgInstance.scaleX; const height = cropBox.getScaledHeight() / imgInstance.scaleY; croppingImage.set({ cropX, cropY, width, height }); croppingImage.scaleToWidth(cropBox.getScaledWidth()); canvas.renderAll(); requestSaveState(); closeVisualCropper(); }

        // --- ALIGNMENT & DATA BINDING ---
        function alignToPageButtons(isMultiSelect = false) {
            const container = document.createElement('div');
            container.className = 'align-buttons full-width';
            const icons = {
                left: '<svg viewBox="0 0 24 24"><path d="M18 21V3h2v18h-2zm-4 0V3h2v18h-2zM4 21h6V3H4v18z" fill="currentColor"/></svg>',
                h_center: '<svg viewBox="0 0 24 24"><path d="M4 21V3h2v18H4zm14 0V3h2v18h-2zM9 21V3h6v18H9z" fill="currentColor"/></svg>',
                right: '<svg viewBox="0 0 24 24"><path d="M4 21V3h2v18H4zm4 0V3h2v18H8zm12 0h-6V3h6v18z" fill="currentColor"/></svg>',
                top: '<svg viewBox="0 0 24 24" transform="rotate(90)"><path d="M18 21V3h2v18h-2zm-4 0V3h2v18h-2zM4 21h6V3H4v18z" fill="currentColor"/></svg>',
                v_center: '<svg viewBox="0 0 24 24" transform="rotate(90)"><path d="M4 21V3h2v18H4zm14 0V3h2v18h-2zM9 21V3h6v18H9z" fill="currentColor"/></svg>',
                bottom: '<svg viewBox="0 0 24 24" transform="rotate(90)"><path d="M4 21V3h2v18H4zm4 0V3h2v18H8zm12 0h-6V3h6v18z" fill="currentColor"/></svg>'
            };

            // Actions for single objects
            const singleActions = {
                left: o => o.set({ originX: 'left', left: pageRect.left }),
                h_center: o => o.set({ originX: 'center', left: pageRect.left + pageRect.width / 2 }),
                right: o => o.set({ originX: 'left', left: pageRect.left + pageRect.width - o.getScaledWidth() }),
                top: o => o.set({ originY: 'top', top: pageRect.top }),
                v_center: o => o.set({ originY: 'center', top: pageRect.top + pageRect.height / 2 }),
                bottom: o => o.set({ originY: 'top', top: pageRect.top + pageRect.height - o.getScaledHeight() })
            };

            // For multi-select, we calculate offset to move the whole group
            function alignMultiSelection(selection, key) {
                if (!selection) return;
                const bounds = selection.getBoundingRect(true, true);
                let dx = 0, dy = 0;

                switch (key) {
                    case 'left':
                        dx = pageRect.left - bounds.left;
                        break;
                    case 'h_center':
                        dx = (pageRect.left + pageRect.width / 2) - (bounds.left + bounds.width / 2);
                        break;
                    case 'right':
                        dx = (pageRect.left + pageRect.width) - (bounds.left + bounds.width);
                        break;
                    case 'top':
                        dy = pageRect.top - bounds.top;
                        break;
                    case 'v_center':
                        dy = (pageRect.top + pageRect.height / 2) - (bounds.top + bounds.height / 2);
                        break;
                    case 'bottom':
                        dy = (pageRect.top + pageRect.height) - (bounds.top + bounds.height);
                        break;
                }

                // Move all objects by the calculated offset
                selection.forEachObject(obj => {
                    obj.set({ left: obj.left + dx, top: obj.top + dy });
                    obj.setCoords();
                });
                selection.setCoords();
            }

            Object.keys(icons).forEach(key => {
                const btn = document.createElement('button');
                btn.className = 'btn ghost';
                btn.innerHTML = icons[key];
                btn.title = `Align ${key.replace('_', ' ')}`;
                btn.onclick = () => {
                    const active = canvas.getActiveObject();
                    if (active && pageRect) {
                        if (active.type === 'activeSelection') {
                            alignMultiSelection(active, key);
                        } else {
                            singleActions[key](active);
                            active.setCoords();
                        }
                        canvas.renderAll();
                        requestSaveState();
                    }
                };
                container.appendChild(btn);
            });
            return container;
        }

        function alignMultipleObjectsButtons() {
            const container = document.createElement('div');
            container.className = 'align-buttons full-width';
            container.style.gridTemplateColumns = 'repeat(6, 32px)';

            const alignments = [
                { key: 'left', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="3" y1="4" x2="3" y2="20" stroke="currentColor" stroke-width="2"/><rect x="6" y="7" width="8" height="3" fill="currentColor"/><rect x="6" y="14" width="12" height="3" fill="currentColor"/></svg>', title: 'Align left edges' },
                { key: 'h_center', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="12" y1="3" x2="12" y2="21" stroke="currentColor" stroke-width="2"/><rect x="7" y="6" width="10" height="3" fill="currentColor"/><rect x="5" y="15" width="14" height="3" fill="currentColor"/></svg>', title: 'Align centers horizontally' },
                { key: 'right', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="21" y1="4" x2="21" y2="20" stroke="currentColor" stroke-width="2"/><rect x="10" y="7" width="8" height="3" fill="currentColor"/><rect x="6" y="14" width="12" height="3" fill="currentColor"/></svg>', title: 'Align right edges' },
                { key: 'top', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="4" y1="3" x2="20" y2="3" stroke="currentColor" stroke-width="2"/><rect x="7" y="6" width="3" height="8" fill="currentColor"/><rect x="14" y="6" width="3" height="12" fill="currentColor"/></svg>', title: 'Align top edges' },
                { key: 'v_center', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="3" y1="12" x2="21" y2="12" stroke="currentColor" stroke-width="2"/><rect x="6" y="7" width="3" height="10" fill="currentColor"/><rect x="15" y="5" width="3" height="14" fill="currentColor"/></svg>', title: 'Align centers vertically' },
                { key: 'bottom', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="4" y1="21" x2="20" y2="21" stroke="currentColor" stroke-width="2"/><rect x="7" y="10" width="3" height="8" fill="currentColor"/><rect x="14" y="6" width="3" height="12" fill="currentColor"/></svg>', title: 'Align bottom edges' }
            ];

            alignments.forEach(({ key, icon, title }) => {
                const btn = document.createElement('button');
                btn.className = 'btn ghost align-btn';
                btn.innerHTML = icon;
                btn.title = title;
                btn.onclick = () => {
                    const active = canvas.getActiveObject();
                    if (!active || active.type !== 'activeSelection') return;

                    const objects = active.getObjects();
                    if (objects.length < 2) return;

                    // Calculate alignment reference
                    let refValue;
                    if (key === 'left') {
                        refValue = Math.min(...objects.map(o => o.left - o.getScaledWidth() / 2));
                        objects.forEach(o => o.set({ left: refValue + o.getScaledWidth() / 2 }));
                    } else if (key === 'right') {
                        refValue = Math.max(...objects.map(o => o.left + o.getScaledWidth() / 2));
                        objects.forEach(o => o.set({ left: refValue - o.getScaledWidth() / 2 }));
                    } else if (key === 'h_center') {
                        const lefts = objects.map(o => o.left);
                        refValue = (Math.min(...lefts) + Math.max(...lefts)) / 2;
                        objects.forEach(o => o.set({ left: refValue }));
                    } else if (key === 'top') {
                        refValue = Math.min(...objects.map(o => o.top - o.getScaledHeight() / 2));
                        objects.forEach(o => o.set({ top: refValue + o.getScaledHeight() / 2 }));
                    } else if (key === 'bottom') {
                        refValue = Math.max(...objects.map(o => o.top + o.getScaledHeight() / 2));
                        objects.forEach(o => o.set({ top: refValue - o.getScaledHeight() / 2 }));
                    } else if (key === 'v_center') {
                        const tops = objects.map(o => o.top);
                        refValue = (Math.min(...tops) + Math.max(...tops)) / 2;
                        objects.forEach(o => o.set({ top: refValue }));
                    }

                    objects.forEach(o => o.setCoords());
                    canvas.renderAll();
                    requestSaveState();
                };
                container.appendChild(btn);
            });

            return container;
        }

        // --- Distribution tools (multi-select) ---
        function distributeSelection(selection, axis) {
            if (!selection || selection.type !== 'activeSelection') return;
            const objs = selection.getObjects().filter(o => o && o.oid !== 'pageRect' && !o.isArtboard);
            if (objs.length < 3) return; // distribution needs 3+ objects

            const rectFor = (o) => {
                o.setCoords();
                return o.getBoundingRect(true, true);
            };

            const items = objs.map(o => ({ o, r: rectFor(o) }));
            if (axis === 'h') {
                items.sort((a, b) => a.r.left - b.r.left);
                const leftEdge = Math.min(...items.map(i => i.r.left));
                const rightEdge = Math.max(...items.map(i => i.r.left + i.r.width));
                const total = items.reduce((s, i) => s + i.r.width, 0);
                const gap = (rightEdge - leftEdge - total) / (items.length - 1);
                let cursor = leftEdge;
                items.forEach(i => {
                    const dx = cursor - i.r.left;
                    i.o.left += dx;
                    i.o.setCoords();
                    // refresh cached rect for subsequent objects
                    cursor += i.r.width + gap;
                });
            } else {
                items.sort((a, b) => a.r.top - b.r.top);
                const topEdge = Math.min(...items.map(i => i.r.top));
                const bottomEdge = Math.max(...items.map(i => i.r.top + i.r.height));
                const total = items.reduce((s, i) => s + i.r.height, 0);
                const gap = (bottomEdge - topEdge - total) / (items.length - 1);
                let cursor = topEdge;
                items.forEach(i => {
                    const dy = cursor - i.r.top;
                    i.o.top += dy;
                    i.o.setCoords();
                    cursor += i.r.height + gap;
                });
            }

            selection.setCoords();
            canvas.requestRenderAll();
            requestSaveState();
        }

        function distributeButtons() {
            const container = document.createElement('div');
            container.className = 'align-buttons';
            container.style.gridTemplateColumns = 'repeat(2, 32px)';

            const hBtn = document.createElement('button');
            hBtn.className = 'btn ghost';
            hBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16"><rect x="3" y="4" width="2" height="16" fill="currentColor" opacity="0.3"/><rect x="19" y="4" width="2" height="16" fill="currentColor" opacity="0.3"/><rect x="11" y="6" width="2" height="12" fill="currentColor"/></svg>';
            hBtn.title = 'Distribute Horizontally';
            hBtn.onclick = () => distributeSelection(canvas.getActiveObject(), 'h');

            const vBtn = document.createElement('button');
            vBtn.className = 'btn ghost';
            vBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" style="transform: rotate(90deg)"><rect x="3" y="4" width="2" height="16" fill="currentColor" opacity="0.3"/><rect x="19" y="4" width="2" height="16" fill="currentColor" opacity="0.3"/><rect x="11" y="6" width="2" height="12" fill="currentColor"/></svg>';
            vBtn.title = 'Distribute Vertically';
            vBtn.onclick = () => distributeSelection(canvas.getActiveObject(), 'v');

            container.append(hBtn, vBtn);
            return container;
        }
        function getBindingsFor(o) { const id = ensureId(o); if (!bindings.has(id)) bindings.set(id, []); return bindings.get(id); }
        function isCellTextBinding(o, b) {
            return !!(o?.isTable && b?.property === 'Cell Text');
        }
        function getNormalizedBindingCellIndex(table, binding) {
            if (!table?.isTable) return 0;
            ensureTableCellData(table);
            const max = Math.max(0, table.rows * table.cols - 1);
            const raw = parseInt(binding?.cellIndex, 10);
            const idx = Number.isFinite(raw) ? raw : 0;
            return Math.max(0, Math.min(max, idx));
        }
        function bindingsMatch(o, a, b) {
            if (a?.property !== b?.property) return false;
            if (isCellTextBinding(o, a) || isCellTextBinding(o, b)) {
                return getNormalizedBindingCellIndex(o, a) === getNormalizedBindingCellIndex(o, b);
            }
            return true;
        }
        function saveBinding(o, b) {
            const arr = getBindingsFor(o);
            const incoming = { ...(b || {}) };
            if (isCellTextBinding(o, incoming)) incoming.cellIndex = getNormalizedBindingCellIndex(o, incoming);
            let existing = arr.find(i => bindingsMatch(o, i, incoming));
            if (!existing) {
                arr.push(incoming);
                existing = incoming;
            } else {
                Object.assign(existing, incoming);
            }
            requestSaveState();
            return existing;
        }
        function removeBinding(o, b) { const arr = getBindingsFor(o); const i = arr.indexOf(b); if (i > -1) arr.splice(i, 1); requestSaveState(); }
        function ensureId(o) { if (!o.oid) o.oid = `obj_${Date.now()}_${Math.random()}`; return o.oid; }
        canvas.on('object:added', (e) => {
            if (!e.target) return;
            if (e.target.isCanvasGhost) return;
            ensureId(e.target);
            if (e.target.type === 'textbox') {
                e.target.padding = 0;
            }
            applyLockStateToObject(e.target);
            if (e.target.type === 'path' || e.target.isSvgGroup || e.target.type === 'group') {
                e.target.objectCaching = false;
            }
            if (e.target.oid !== 'pageRect' && !e.target.excludeFromExport && !e.target.isSnapLine && !e.target.isArtboard && !e.target.pageId) {
                e.target.pageId = currentCanvasPageId();
            }
            if (!e.target.isCanvasGhost) {
                applyObjectMaskForPage(e.target, currentPageIndex);
            }
        });


        // --- 8. CORRECTED & ENHANCED FLOATING UI LOGIC ---
        const floatingLinker = $('#floating-linker');
        const floatingLinkBtn = $('#floatingLinkBtn');
        const floatingColumnList = $('#floatingColumnList');
        const floatingColumnListContent = $('#floatingColumnListContent');
        const floatingColumnSearch = $('#floatingColumnSearch');

        function updateFloatingLinker(target) {
            const activeObjects = canvas.getActiveObjects();

            // Hide if nothing is selected
            if (activeObjects.length === 0) {
                floatingLinker.style.display = 'none';
                floatingColumnList.style.display = 'none';
                return;
            }

            // Keep endpoint handles unobstructed while editing lines.
            if (activeObjects.length === 1 && activeObjects[0]?.type === 'line') {
                floatingLinker.style.display = 'none';
                floatingColumnList.style.display = 'none';
                return;
            }

            // Show the main floating container for any selection (single or multiple)
            floatingLinker.style.display = 'flex';

            // The "anchor" for positioning is always the active selection group or the single object
            const anchor = canvas.getActiveObject();
            updateFloatingLinkerPosition(anchor);

            // Only show the "Link Data" button for a SINGLE selection when data is loaded
            if (activeObjects.length === 1 && headers.length > 0) {
                floatingLinkBtn.style.display = 'inline-flex';
                let objBindings = getBindingsFor(activeObjects[0]);

                // If it's a table and a specific cell is selected, show only what's linked to that cell
                if (activeObjects[0].isTable) {
                    const selectedCellIndex = getSingleSelectedTableCellIndex(activeObjects[0]);
                    if (selectedCellIndex >= 0) {
                        objBindings = objBindings.filter(b =>
                            b.property === 'Cell Text' &&
                            getNormalizedBindingCellIndex(activeObjects[0], b) === selectedCellIndex
                        );
                    }
                }

                if (objBindings.length > 0) {
                    // Show actual linked column names
                    const colNames = [...new Set(objBindings.map(b => b.column).filter(Boolean))];
                    floatingLinkBtn.textContent = colNames.length > 0 ? colNames.join(', ') : 'Link Data';
                } else {
                    floatingLinkBtn.textContent = 'Link Data';
                }
            } else {
                floatingLinkBtn.style.display = 'none';
            }
        }

        function updateFloatingLinkerPosition(target) {
            // Guard against errors if the target or its coordinates aren't ready
            if (!target || !floatingLinker) return;

            if (!target.oCoords) {
                if (typeof target.setCoords === 'function') target.setCoords();
                if (!target.oCoords) return;
            }

            const canvasRect = canvas.upperCanvasEl.getBoundingClientRect();

            // Default object controls expose `tr`; custom controls (e.g. line endpoints) may not.
            let anchorPoint = target.oCoords.tr
                || target.oCoords.br
                || target.oCoords.end
                || target.oCoords.start
                || null;

            if (!anchorPoint || !Number.isFinite(anchorPoint.x) || !Number.isFinite(anchorPoint.y)) {
                const coords = typeof target.getCoords === 'function' ? target.getCoords() : null;
                if (Array.isArray(coords) && coords.length > 0) {
                    anchorPoint = coords.reduce((best, p) => {
                        if (!best) return p;
                        if (p.x > best.x) return p;
                        if (p.x === best.x && p.y < best.y) return p;
                        return best;
                    }, null);
                }
            }

            if (!anchorPoint || !Number.isFinite(anchorPoint.x) || !Number.isFinite(anchorPoint.y)) return;

            floatingLinker.style.left = `${anchorPoint.x + canvasRect.left + 10}px`;
            floatingLinker.style.top = `${anchorPoint.y + canvasRect.top}px`;
        }


        // Show/Hide the column list dropdown
        floatingLinkBtn.addEventListener('click', () => {
            const target = canvas.getActiveObject();
            if (!target) return;
            const isVisible = floatingColumnList.style.display === 'block';
            floatingColumnList.style.display = isVisible ? 'none' : 'block';
            if (!isVisible) {
                renderFloatingColumnList(target, '');
                floatingColumnSearch.focus();
            }
        });

        // Filter the column list
        floatingColumnSearch.addEventListener('input', () => {
            renderFloatingColumnList(canvas.getActiveObject(), floatingColumnSearch.value);
        });

        function renderFloatingColumnList(target, query) {
            if (!target) return;
            floatingColumnListContent.innerHTML = '';
            const q = query.toLowerCase();

            // If identifier column is set, show a grouped view with row selector
            const hasIdentifier = identifierColumn && headers.includes(identifierColumn);

            // Determine if there's an existing binding for the current focus (single cell for tables, or first binding for others)
            let currentBinding = null;
            if (target.isTable) {
                const cellIdx = getSingleSelectedTableCellIndex(target);
                if (cellIdx >= 0) {
                    currentBinding = getBindingsFor(target).find(b =>
                        b.property === 'Cell Text' &&
                        getNormalizedBindingCellIndex(target, b) === cellIdx
                    );
                }
            } else {
                currentBinding = getBindingsFor(target)[0];
            }

            headers.filter(h => h.toLowerCase().includes(q)).forEach(h => {
                const item = document.createElement('div');
                item.className = 'col-item';
                item.style.cssText = 'display: flex; flex-direction: column; gap: 4px;';

                const isSelected = currentBinding && currentBinding.column === h;
                if (isSelected) {
                    item.setAttribute('aria-selected', 'true');
                }

                const headerRow = document.createElement('div');
                headerRow.style.cssText = 'display: flex; justify-content: space-between; align-items: center; width: 100%;';

                const label = document.createElement('span');
                label.textContent = h;
                headerRow.appendChild(label);

                if (isSelected) {
                    const unlinkBtn = document.createElement('button');
                    unlinkBtn.className = 'btn ghost';
                    unlinkBtn.style.cssText = 'padding: 0; min-width: 20px; height: 20px; border: none; background: transparent; color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 4px;';
                    unlinkBtn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M18 6L6 18M6 6l12 12"/></svg>';
                    unlinkBtn.title = 'Remove Link';
                    unlinkBtn.onmouseover = () => unlinkBtn.style.background = 'rgba(239, 68, 68, 0.1)';
                    unlinkBtn.onmouseout = () => unlinkBtn.style.background = 'transparent';
                    unlinkBtn.onclick = (e) => {
                        e.stopPropagation();
                        removeBinding(target, currentBinding);
                        floatingColumnList.style.display = 'none';
                        updateFloatingLinker(target);
                        refreshInspector({ target });
                    };
                    headerRow.appendChild(unlinkBtn);
                }
                item.appendChild(headerRow);

                // Check if this column has multi-row data when identifier is set
                let rowSelectEl = null;
                if (hasIdentifier && h !== identifierColumn) {
                    // Count unique identifier values to see if multi-row
                    const identValues = [...new Set(dataRows.map(r => r[identifierColumn]).filter(Boolean))];
                    const hasMultiRow = identValues.some(id => dataRows.filter(r => r[identifierColumn] === id).length > 1);
                    if (hasMultiRow) {
                        // Show a row index selector
                        const maxRowsPerIdent = Math.max(...identValues.map(id => dataRows.filter(r => r[identifierColumn] === id).length));
                        rowSelectEl = document.createElement('select');
                        rowSelectEl.style.cssText = 'font-size: 11px; padding: 2px 4px; margin-top: 2px;';
                        for (let ri = 0; ri < maxRowsPerIdent; ri++) {
                            const opt = document.createElement('option');
                            opt.value = ri;
                            opt.textContent = `Row ${ri + 1}`;
                            rowSelectEl.appendChild(opt);
                        }
                        if (isSelected && typeof currentBinding.rowIndex === 'number') {
                            rowSelectEl.value = currentBinding.rowIndex;
                        }
                        rowSelectEl.onclick = (e) => e.stopPropagation();
                        item.appendChild(rowSelectEl);
                    }
                }

                item.onclick = () => {
                    const selectedRowIndex = rowSelectEl ? parseInt(rowSelectEl.value, 10) : 0;
                    const bindingData = { column: h, rowIndex: selectedRowIndex };

                    if (target.isTable) {
                        const selectedCellIndex = getSingleSelectedTableCellIndex(target);
                        if (selectedCellIndex < 0) {
                            showNotification('Select one table cell before linking data.');
                            floatingColumnList.style.display = 'none';
                            return;
                        }
                        const existing = getBindingsFor(target).find(b =>
                            b.property === 'Cell Text' && getNormalizedBindingCellIndex(target, b) === selectedCellIndex
                        );
                        if (existing) {
                            existing.column = h;
                            if (hasIdentifier) existing.rowIndex = selectedRowIndex;
                            requestSaveState();
                        } else {
                            const newB = { column: h, property: 'Cell Text', cellIndex: selectedCellIndex };
                            if (hasIdentifier) newB.rowIndex = selectedRowIndex;
                            saveBinding(target, newB);
                        }
                    } else {
                        const defaultProp = defaultPropertyFor(target);
                        const targetBindings = getBindingsFor(target);
                        if (targetBindings.length > 0) {
                            targetBindings[0].column = h;
                            targetBindings[0].property = defaultProp;
                            if (hasIdentifier) targetBindings[0].rowIndex = selectedRowIndex;
                        } else {
                            const newB = { column: h, property: defaultProp };
                            if (hasIdentifier) newB.rowIndex = selectedRowIndex;
                            saveBinding(target, newB);
                        }
                    }
                    requestSaveState();
                    floatingColumnList.style.display = 'none';
                    updateFloatingLinker(target);
                    refreshInspector({ target });
                };
                floatingColumnListContent.appendChild(item);
            });
        }

        // Add event handlers for Duplicate and Delete buttons
        on('#duplicateBtn', 'click', () => {
            duplicateSelection();
        });

        on('#deleteBtn', 'click', () => {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                removeCanvasObjects(activeObjects);
            }
        });

        // Bring to Front / Send to Back quick buttons
        on('#bringToFrontBtn', 'click', () => {
            const activeObjects = canvas.getActiveObjects();
            activeObjects.forEach(obj => canvas.bringToFront(obj));
            renderLayers();
            requestSaveState();
        });

        on('#sendToBackBtn', 'click', () => {
            const activeObjects = canvas.getActiveObjects();
            activeObjects.forEach(obj => canvas.sendToBack(obj));
            keepPageRectAtBack();
            renderLayers();
            requestSaveState();
        });

        canvas.on('object:moving', () => {
            floatingLinker.style.display = 'none';
            floatingColumnList.style.display = 'none';
        });
        canvas.on('object:modified', () => {
            updateFloatingLinker(canvas.getActiveObject());
        });

        // Hide dropdown if clicking outside
        window.addEventListener('click', (e) => {
            if (!floatingLinker.contains(e.target)) {
                floatingColumnList.style.display = 'none';
            }
        });

        const dataLinksManagerModal = $('#dataLinksManagerModal');
        const openDataLinksManagerBtn = $('#openDataLinksManagerBtn');
        const closeDataLinksManagerModalBtn = $('#closeDataLinksManagerModal');
        let selectedObjectForManager = null;

        // --- IDENTIFIER COLUMN LOGIC ---
        function refreshIdentifierDropdown() {
            const dropdown = $('#csvIdentifierColumnDropdown');
            if (!dropdown) return;
            dropdown.innerHTML = '<option value="">(None)</option>';
            headers.forEach(h => {
                const opt = document.createElement('option');
                opt.value = h;
                opt.textContent = h;
                if (h === identifierColumn) opt.selected = true;
                dropdown.appendChild(opt);
            });
        }

        on('#csvIdentifierColumnDropdown', 'change', (e) => {
            identifierColumn = e.target.value;
            requestSaveState();
        });

        function showIdentifierColumnModal() {
            const modal = $('#identifierColumnModal');
            const select = $('#identifierColumnSelect');
            const preview = $('#identifierColumnPreview');
            if (!modal || !select) return;

            select.innerHTML = '<option value="">(None — each row is a separate page)</option>';
            headers.forEach(h => {
                const opt = document.createElement('option');
                opt.value = h;
                opt.textContent = h;
                if (h === identifierColumn) opt.selected = true;
                select.appendChild(opt);
            });

            const updatePreview = () => {
                const col = select.value;
                if (!col) {
                    preview.textContent = `Each of the ${dataRows.length} rows will generate a separate page.`;
                    return;
                }
                const uniqueValues = [...new Set(dataRows.map(r => r[col]).filter(Boolean))];
                const multiRowCount = uniqueValues.filter(v => dataRows.filter(r => r[col] === v).length > 1).length;
                preview.textContent = `${uniqueValues.length} unique value(s). ${multiRowCount} with multiple rows.`;
            };
            select.onchange = updatePreview;
            updatePreview();

            modal.style.display = 'flex';
        }

        on('#confirmIdentifierColumnBtn', 'click', () => {
            const select = $('#identifierColumnSelect');
            identifierColumn = select ? select.value : '';
            refreshIdentifierDropdown();
            requestSaveState();
            $('#identifierColumnModal').style.display = 'none';
        });

        on('#skipIdentifierColumnBtn', 'click', () => {
            identifierColumn = '';
            refreshIdentifierDropdown();
            requestSaveState();
            $('#identifierColumnModal').style.display = 'none';
        });

        on('#closeIdentifierColumnModal', 'click', () => {
            $('#identifierColumnModal').style.display = 'none';
        });

        function openDataLinksManager() {
            renderDataLinksManager();
            dataLinksManagerModal.style.display = 'flex';
        }
        function closeDataLinksManager() {
            dataLinksManagerModal.style.display = 'none';
            selectedObjectForManager = null;
        }
        openDataLinksManagerBtn.addEventListener('click', openDataLinksManager);
        closeDataLinksManagerModalBtn.addEventListener('click', closeDataLinksManager);

        function renderDataLinksManager() {
            const objectsList = $('#dataLinksObjectsList');
            objectsList.innerHTML = '';
            const objects = canvas.getObjects().filter(o => o.oid !== 'pageRect' && !o.excludeFromExport && !o.isArtboard);
            if (objects.length === 0) {
                objectsList.innerHTML = '<p class="muted" style="font-size:12px; text-align:center;">No objects on canvas.</p>';
                $('#dataLinksEditorContent').innerHTML = '<p class="muted" style="text-align:center; padding-top: 24px;">Add an object to the canvas to create a data link.</p>';
                return;
            }
            objects.forEach(obj => {
                const item = document.createElement('div');
                item.className = 'data-links-object-item';
                item.setAttribute('data-oid', ensureId(obj));
                // Keep object names consistent with the Layers panel
                let name = obj.name || obj.type;
                const bindingCount = getBindingsFor(obj).length;
                item.innerHTML = `<strong>${name}</strong> <br> <span class="muted">${bindingCount} link(s)</span>`;
                item.addEventListener('click', () => {
                    selectedObjectForManager = obj;
                    document.querySelectorAll('.data-links-object-item').forEach(el => el.removeAttribute('aria-selected'));
                    item.setAttribute('aria-selected', 'true');
                    renderBindingsForObject(obj);
                });
                objectsList.appendChild(item);
            });
            if (selectedObjectForManager) {
                const selectedItem = objectsList.querySelector(`[data-oid="${selectedObjectForManager.oid}"]`);
                if (selectedItem) selectedItem.setAttribute('aria-selected', 'true');
                else selectedObjectForManager = null;
            }
            if (selectedObjectForManager) renderBindingsForObject(selectedObjectForManager);
            else $('#dataLinksEditorContent').innerHTML = '<p class="muted" style="text-align:center; padding-top: 24px;">Select an object from the left to manage its data links.</p>';
        }

        function renderBindingsForObject(obj) {
            const container = $('#dataLinksEditorContent');
            container.innerHTML = '';
            const linksWrapper = document.createElement('div');
            linksWrapper.className = 'links-list-wrapper';
            const header = document.createElement('h4');
            header.textContent = 'Active Links';
            linksWrapper.appendChild(header);
            const objectBindings = getBindingsFor(obj);
            if (objectBindings.length === 0) {
                linksWrapper.innerHTML += '<p class="muted" style="text-align:center; padding: 16px 0;">No data links configured for this object.</p>';
            } else {
                objectBindings.forEach(b => linksWrapper.appendChild(bindingEditorRow(obj, b)));
            }
            const buttonWrapper = document.createElement('div');
            buttonWrapper.className = 'add-link-button-wrapper';
            const addButton = document.createElement('button');
            addButton.className = 'btn';
            addButton.textContent = 'Add New Link';
            addButton.style.width = '100%';
            addButton.onclick = () => {
                const newBinding = { column: '', property: defaultPropertyFor(obj) };
                if (obj.isTable && newBinding.property === 'Cell Text') {
                    const selectedCellIndex = getSingleSelectedTableCellIndex(obj);
                    newBinding.cellIndex = selectedCellIndex >= 0 ? selectedCellIndex : 0;
                }
                saveBinding(obj, newBinding);
                renderDataLinksManager();
            };
            buttonWrapper.appendChild(addButton);
            container.append(linksWrapper, buttonWrapper);
        }

        function bindingEditorRow(o, b) {
            const box = document.createElement('div');
            box.className = 'stack';
            box.style.cssText = 'border:1px solid var(--border);padding:8px;border-radius:8px;margin-top:8px;';

            box.appendChild(selectRow('Property', propertyOptionsFor(o), b.property, v => {
                b.property = v;
                if (isCellTextBinding(o, b)) b.cellIndex = getNormalizedBindingCellIndex(o, b);
                requestSaveState();
                renderDataLinksManager();
            }));

            const info = document.createElement('div');
            info.className = 'muted';
            info.textContent = `Linked to: ${b.column || '\u2014'}${(b.rowIndex > 0) ? ` (Row ${b.rowIndex + 1})` : ''}`;
            info.style.fontSize = '12px';

            if (isCellTextBinding(o, b)) {
                ensureTableCellData(o);
                b.cellIndex = getNormalizedBindingCellIndex(o, b);
                const targetCell = document.createElement('div');
                targetCell.className = 'muted';
                targetCell.style.fontSize = '12px';
                targetCell.textContent = `Target Cell: ${tableCellRefLabel(o, b.cellIndex)}`;

                const posWrap = document.createElement('div');
                posWrap.className = 'row';
                posWrap.style.gap = '8px';
                posWrap.style.marginTop = '6px';
                const rowInput = document.createElement('input');
                rowInput.type = 'number';
                rowInput.min = '1';
                rowInput.max = `${o.rows}`;
                rowInput.title = 'Row';
                rowInput.value = `${Math.floor(b.cellIndex / o.cols) + 1}`;
                const colInput = document.createElement('input');
                colInput.type = 'number';
                colInput.min = '1';
                colInput.max = `${o.cols}`;
                colInput.title = 'Column';
                colInput.value = `${(b.cellIndex % o.cols) + 1}`;

                const updateCellTarget = () => {
                    const row = Math.max(1, Math.min(o.rows, parseInt(rowInput.value, 10) || 1));
                    const col = Math.max(1, Math.min(o.cols, parseInt(colInput.value, 10) || 1));
                    rowInput.value = `${row}`;
                    colInput.value = `${col}`;
                    b.cellIndex = (row - 1) * o.cols + (col - 1);
                    targetCell.textContent = `Target Cell: ${tableCellRefLabel(o, b.cellIndex)}`;
                    requestSaveState();
                    refreshInspector({ target: o });
                };
                rowInput.oninput = updateCellTarget;
                colInput.oninput = updateCellTarget;
                posWrap.append(rowInput, colInput);
                box.append(targetCell, posWrap);
            }

            const linkBtn = document.createElement('button');
            linkBtn.className = b.column ? 'btn primary' : 'btn';
            linkBtn.textContent = b.column ? 'Change Column' : 'Link Column';
            linkBtn.onclick = () => {
                openColumnSelectionModal(o, b);
            };

            const delBtn = document.createElement('button');
            delBtn.className = 'btn ghost';
            delBtn.textContent = 'Remove';
            delBtn.onclick = () => {
                removeBinding(o, b);
                renderDataLinksManager();
            };

            const btnGroup = document.createElement('div');
            btnGroup.className = 'row';
            btnGroup.style.marginTop = '8px';
            btnGroup.append(linkBtn, delBtn);

            box.append(info, btnGroup);
            return box;
        }


        function openColumnSelectionModal(object, binding, options = {}) {
            const modal = $('#columnSelectModal');
            const list = $('#columnSelectList');
            const searchInput = $('#columnSelectSearch');
            const confirmBtn = $('#confirmColumnSelect');

            const renderList = (query = '') => {
                list.innerHTML = '';
                const q = query.toLowerCase();
                headers.forEach((h, index) => {
                    if (h.toLowerCase().includes(q)) {
                        const item = document.createElement('div');
                        item.className = 'col-item';
                        item.dataset.columnName = h; // Store name for confirmation

                        const sample = dataRows.length > 0 ? (dataRows[0]?.[h] ?? '\u2014') : '\u2014';

                        item.innerHTML = `<strong>Column ${index + 1}: ${h}</strong><div class="muted" style="font-size: 11px;">Sample: ${sample}</div>`;

                        // Preselect currently linked column
                        if (binding.column && binding.column === h) {
                            item.setAttribute('aria-selected', 'true');
                        }

                        item.onclick = () => {
                            list.querySelectorAll('.col-item').forEach(el => el.removeAttribute('aria-selected'));
                            item.setAttribute('aria-selected', 'true');
                        };
                        list.appendChild(item);
                    }
                });
            };

            // Use a fresh, single-use event listener for confirmation to avoid old references
            const confirmHandler = () => {
                const selectedEl = list.querySelector('[aria-selected="true"]');
                if (selectedEl) {
                    binding.column = selectedEl.dataset.columnName;
                    requestSaveState();
                    if (typeof options.onLinked === 'function') options.onLinked(binding);
                    else renderDataLinksManager(); // Refresh manager to show the new column name
                    modal.style.display = 'none';
                } else {
                    showNotification("Please select a column.", 'info', 2000);
                }
            };

            confirmBtn.onclick = confirmHandler;

            searchInput.oninput = () => renderList(searchInput.value);

            renderList(); // Initial render
            modal.style.display = 'flex';
        }

        function propertyOptionsFor(o) { const common = ['Opacity', 'Stroke Color', 'Stroke Width']; if (o.isTable) return ['Cell Text', 'Border Color', 'Border Width']; if (o.type === 'textbox') return ['Text Content', 'Font Family', 'Font Size', 'Fill Color', ...common]; if (['rect', 'image'].includes(o.type)) common.push('Corner Radius'); if (o.isSvgGroup || ['rect', 'circle', 'triangle', 'polygon', 'path'].includes(o.type)) return ['Fill', 'Stroke Color', 'Stroke Width', 'Opacity']; return common; }
        function defaultPropertyFor(o) { if (o?.isTable) return 'Cell Text'; return o.type === 'textbox' ? 'Text Content' : 'Fill'; }



// components/05-export-engine.js
// --- EXPORT ---
const exportFormatSelect = $('#exportFormatSelect');
const exportBtn = $('#exportBtn');
const exportSinglePdfBtn = $('#exportSinglePdfBtn');
const exportAllCanvasesBtn = $('#exportAllCanvasesBtn');
const exportPageSelectorWrap = $('#exportPageSelectorWrap');
const exportPageSelectorBtn = $('#exportPageSelectorBtn');
const exportPageSelectorMenu = $('#exportPageSelectorMenu');
const exportAllPagesToggle = $('#exportAllPagesToggle');
const exportPageCheckboxList = $('#exportPageCheckboxList');
const proLimitModal = $('#proLimitModal');
let exportSelectedPageIndexes = new Set([0]);

function setExportPageSelectorOpen(isOpen) {
    if (!exportPageSelectorMenu || !exportPageSelectorBtn) return;
    exportPageSelectorMenu.style.display = isOpen ? 'block' : 'none';
    exportPageSelectorBtn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
}

function sanitizeExportPageSelections() {
    const next = new Set();
    exportSelectedPageIndexes.forEach(idx => {
        if (Number.isInteger(idx) && idx >= 0 && idx < documentPages.length) next.add(idx);
    });
    if (!next.size && documentPages.length) {
        const safeCurrent = Math.max(0, Math.min(documentPages.length - 1, currentPageIndex));
        next.add(safeCurrent);
    }
    exportSelectedPageIndexes = next;
}

function getSelectedExportPageIndexes() {
    if (!Array.isArray(documentPages) || !documentPages.length) return [];
    if (documentPages.length === 1) return [0];
    if (!exportAllPagesToggle || exportAllPagesToggle.checked) {
        return documentPages.map((_, idx) => idx);
    }
    sanitizeExportPageSelections();
    return Array.from(exportSelectedPageIndexes).sort((a, b) => a - b);
}

function syncExportPageSelectorUI() {
    const totalPages = Array.isArray(documentPages) ? documentPages.length : 0;
    const hasMultipleCanvases = totalPages > 1;

    if (exportPageSelectorWrap) exportPageSelectorWrap.style.display = hasMultipleCanvases ? 'inline-flex' : 'none';
    if (exportAllCanvasesBtn) exportAllCanvasesBtn.style.display = hasMultipleCanvases ? 'inline-flex' : 'none';

    if (!hasMultipleCanvases) {
        setExportPageSelectorOpen(false);
        return;
    }

    if (exportAllPagesToggle && !exportAllPagesToggle.checked) sanitizeExportPageSelections();

    const selectedIndexes = getSelectedExportPageIndexes();
    if (exportPageSelectorBtn) {
        exportPageSelectorBtn.textContent = selectedIndexes.length === totalPages
            ? 'Pages: All'
            : `Pages: ${selectedIndexes.map(idx => idx + 1).join(', ')}`;
    }

    if (!exportPageCheckboxList) return;
    exportPageCheckboxList.innerHTML = '';

    const lockSelection = !!exportAllPagesToggle?.checked;
    const selectedSet = new Set(selectedIndexes);

    documentPages.forEach((_, idx) => {
        const item = document.createElement('label');
        item.className = 'export-page-checkbox-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = String(idx);
        checkbox.checked = lockSelection || selectedSet.has(idx);
        checkbox.disabled = lockSelection;
        checkbox.addEventListener('change', () => {
            if (checkbox.checked) exportSelectedPageIndexes.add(idx);
            else exportSelectedPageIndexes.delete(idx);

            if (!exportSelectedPageIndexes.size) {
                exportSelectedPageIndexes.add(idx);
                checkbox.checked = true;
            }
            syncExportPageSelectorUI();
        });

        const title = document.createElement('span');
        title.textContent = `Page ${idx + 1}`;

        item.append(checkbox, title);
        exportPageCheckboxList.appendChild(item);
    });
}

// Update the UI based on user role and data loaded
function updateExportUI() {
    let format = exportFormatSelect.value;
    const hasData = dataRows.length > 0;

    const isPro = userRole === 'pro' || userRole === 'admin';
    $('#exportFormatSelect option[value="png"]').disabled = !isPro;
    $('#exportFormatSelect option[value="jpg"]').disabled = !isPro;
    if (!isPro && (format === 'png' || format === 'jpg')) {
        exportFormatSelect.value = 'pdf';
        format = 'pdf';
    }

    if (hasData && format !== 'json') {
        exportBtn.textContent = 'Export as ZIP';
        exportSinglePdfBtn.style.display = 'inline-flex';
    } else {
        exportBtn.textContent = 'Export';
        exportSinglePdfBtn.style.display = 'none';
    }

    syncExportPageSelectorUI();
}

function ensureTextboxPathsCloneSafe(rootObject) {
    if (!rootObject) return;

    const stack = [rootObject];
    const visited = new Set();
    const curveEpsilon = (typeof TEXT_CURVE_EPSILON === 'number') ? TEXT_CURVE_EPSILON : 0.001;

    const clearInvalidTextboxPath = (textbox) => {
        textbox.set({
            path: null,
            pathAlign: 'baseline',
            pathSide: 'left',
            pathStartOffset: 0
        });
        if (typeof textbox.initDimensions === 'function') textbox.initDimensions();
        if (typeof textbox.setCoords === 'function') textbox.setCoords();
    };

    while (stack.length) {
        const obj = stack.pop();
        if (!obj || visited.has(obj)) continue;
        visited.add(obj);

        if (obj.type === 'textbox') {
            const curveAmount = (typeof clampTextCurveAmount === 'function')
                ? clampTextCurveAmount(obj.curveAmount)
                : (parseFloat(obj.curveAmount) || 0);
            const hasCurve = Math.abs(curveAmount) > curveEpsilon;
            const hasPath = !!obj.path;
            const hasValidPathObject = hasPath
                && typeof obj.path.toObject === 'function'
                && typeof obj.path.isNotVisible === 'function';
            const missingCurvedPath = hasCurve && !hasPath;
            const invalidPathObject = hasPath && !hasValidPathObject;
            const staleFlatPath = !hasCurve && hasPath;

            if (missingCurvedPath || invalidPathObject || staleFlatPath) {
                try {
                    if (hasCurve && typeof refreshTextboxCurve === 'function') {
                        refreshTextboxCurve(obj, { skipRender: true });
                    } else {
                        clearInvalidTextboxPath(obj);
                    }
                } catch (error) {
                    console.warn('Failed to normalize textbox path before clone:', error);
                    clearInvalidTextboxPath(obj);
                }
            }
        }

        if (typeof obj.getObjects === 'function') {
            const children = obj.getObjects();
            if (Array.isArray(children) && children.length) {
                children.forEach(child => stack.push(child));
            }
        }
    }
}

// 3. Restored High-Quality "Invisible Canvas" Rendering Engine
async function generateCanvasDataURL(format = 'jpeg', quality = 0.9) {
    if (!pageRect) return null;

    const { left: pageLeft, top: pageTop, width: pageW, height: pageH } = pageRect;

    // Use a higher multiplier for PNG for better quality, JPEG is fine at 2x
    const multiplier = format === 'png' ? 3 : 2;

    const tempCanvasEl = document.createElement('canvas');
    tempCanvasEl.width = pageW;
    tempCanvasEl.height = pageH;

    // Create a static canvas that won't be rendered to the screen
    const tempCanvas = new fabric.StaticCanvas(tempCanvasEl, {
        width: pageW,
        height: pageH,
        backgroundColor: pageRect.fill,
    });

    // Clone all objects except the page rectangle and guides
    const objectsToClone = canvas.getObjects().filter(obj => obj.oid !== 'pageRect' && !obj.excludeFromExport && !obj.isArtboard);
    objectsToClone.forEach(obj => ensureTextboxPathsCloneSafe(obj));
    const clonePromises = objectsToClone.map(obj => new Promise(resolve => obj.clone(resolve, SERIALIZE_PROPS)));
    const clonedObjects = await Promise.all(clonePromises);

    clonedObjects.forEach(clone => {
        ensureTextboxPathsCloneSafe(clone);
        if (clone?.type === 'textbox') {
            refreshTextboxCurve(clone, { skipRender: true });
        }
        // Position the clone relative to the page, not the entire canvas
        clone.set({
            left: clone.left - pageLeft,
            top: clone.top - pageTop
        });
        tempCanvas.add(clone);
    });

    // Ensure everything is rendered before exporting
    tempCanvas.renderAll();

    const dataURL = tempCanvas.toDataURL({
        format: format,
        quality: quality,
        multiplier: 3
    });

    // Clean up the temporary canvas
    tempCanvas.dispose();

    return dataURL;
}

async function generatePageDataURLFromPageState(pageState, format = 'jpeg', quality = 0.9) {
    const width = parsePositiveInt(pageState?.width, DEFAULT_PAGE_WIDTH);
    const height = parsePositiveInt(pageState?.height, DEFAULT_PAGE_HEIGHT);
    const safeCanvasState = sanitizeCanvasStateForEditor(pageState?.canvas, {
        pageWidth: width,
        pageHeight: height
    });

    const off = document.createElement('canvas');
    off.width = width;
    off.height = height;
    const staticCanvas = new fabric.StaticCanvas(off, {
        width,
        height,
        renderOnAddRemove: false,
        selection: false,
        backgroundColor: '#ffffff'
    });

    return new Promise((resolve, reject) => {
        try {
            staticCanvas.loadFromJSON(safeCanvasState, () => {
                try {
                    const objects = staticCanvas.getObjects();
                    const artboard = objects.find(o => o && (o.oid === 'pageRect' || o.isArtboard));
                    if (artboard?.fill) staticCanvas.setBackgroundColor(artboard.fill, () => { });

                    objects.forEach(obj => {
                        if (!obj) return;
                        if (obj.oid === 'pageRect' || obj.isArtboard || obj.excludeFromExport || obj.isSnapLine || obj.isCanvasGhost) {
                            staticCanvas.remove(obj);
                            return;
                        }
                        if (obj.type === 'textbox') {
                            ensureTextboxPathsCloneSafe(obj);
                            refreshTextboxCurve(obj, { skipRender: true });
                        }
                    });

                    staticCanvas.renderAll();
                    const dataURL = staticCanvas.toDataURL({
                        format,
                        quality,
                        multiplier: format === 'png' ? 3 : 2
                    });
                    staticCanvas.dispose();
                    resolve(dataURL);
                } catch (error) {
                    staticCanvas.dispose();
                    reject(error);
                }
            });
        } catch (error) {
            staticCanvas.dispose();
            reject(error);
        }
    });
}

function bindingPropertyToObjectProp(property) {
    switch (property) {
        case 'Text Content': return 'text';
        case 'Font Family': return 'fontFamily';
        case 'Font Size': return 'fontSize';
        case 'Fill':
        case 'Fill Color': return 'fill';
        case 'Opacity': return 'opacity';
        case 'Border Color': return 'borderColor';
        case 'Border Width': return 'borderWidth';
        case 'Stroke Color': return 'stroke';
        case 'Stroke Width': return 'strokeWidth';
        case 'Corner Radius': return 'rx';
        default: return property ? property.toLowerCase().replace(/\s/g, '') : '';
    }
}

function getRowsForIdentifier(identValue) {
    if (!identifierColumn || !identValue) return [];
    return dataRows.filter(r => r[identifierColumn] === identValue);
}

function applyDataBindingsForRow(row) {
    const originalStates = new Map();
    if (!row) return originalStates;

    // If identifier column is set, gather all rows for this identifier
    const identValue = identifierColumn ? row[identifierColumn] : null;
    const identRows = identValue ? getRowsForIdentifier(identValue) : [row];

    canvas.getObjects().forEach(obj => {
        const objBindings = getBindingsFor(obj);
        if (objBindings.length === 0) return;

        const originalProps = {};
        objBindings.forEach(binding => {
            // Resolve which row to use: if binding has a rowIndex and identifier is set, use that row
            const bindingRowIndex = (identifierColumn && typeof binding.rowIndex === 'number') ? binding.rowIndex : 0;
            const effectiveRow = (identifierColumn && typeof binding.rowIndex === 'number') ? identRows[bindingRowIndex] : row;
            const value = effectiveRow ? (effectiveRow[binding.column] ?? '') : '';
            if (value == null) return;

            if (obj.isTable && binding.property === 'Cell Text') {
                ensureTableCellData(obj);
                const cellIndex = getNormalizedBindingCellIndex(obj, binding);
                if (!originalProps.__tableCellTexts) originalProps.__tableCellTexts = {};
                if (originalProps.__tableCellTexts[cellIndex] === undefined) {
                    originalProps.__tableCellTexts[cellIndex] = obj.cellData[cellIndex]?.text || '';
                }
                applyBinding(obj, binding.property, value, binding);
                return;
            }

            if (obj.isTable && (binding.property === 'Border Color' || binding.property === 'Border Width')) {
                ensureTableCellData(obj);
                if (!originalProps.__tableCellBorders) {
                    originalProps.__tableCellBorders = obj.cellData.map(cell => ({
                        borderColor: cell.borderColor,
                        borderWidth: cell.borderWidth
                    }));
                }
            }

            const propName = bindingPropertyToObjectProp(binding.property);
            if (propName && originalProps[propName] === undefined) originalProps[propName] = obj[propName];
            applyBinding(obj, binding.property, value, binding);
        });

        if (Object.keys(originalProps).length > 0) originalStates.set(obj, originalProps);
    });

    canvas.renderAll();
    return originalStates;
}

function restoreDataBindingsState(originalStates) {
    originalStates.forEach((props, obj) => {
        if (props.__tableCellTexts && obj.isTable) {
            ensureTableCellData(obj);
            Object.entries(props.__tableCellTexts).forEach(([idx, text]) => {
                const cellIndex = parseInt(idx, 10);
                if (obj.cellData[cellIndex]) obj.cellData[cellIndex].text = text;
            });
        }
        if (props.__tableCellBorders && obj.isTable) {
            ensureTableCellData(obj);
            props.__tableCellBorders.forEach((cellBorder, idx) => {
                if (!obj.cellData[idx] || !cellBorder) return;
                obj.cellData[idx].borderColor = cellBorder.borderColor;
                obj.cellData[idx].borderWidth = cellBorder.borderWidth;
            });
        }
        if (obj.isTable && (props.__tableCellTexts || props.__tableCellBorders)) {
            updateTableLayout(obj);
        }
        const plainProps = { ...props };
        delete plainProps.__tableCellTexts;
        delete plainProps.__tableCellBorders;
        if (Object.keys(plainProps).length > 0) obj.set(plainProps);
        if (obj.type === 'textbox' && (plainProps.text !== undefined || plainProps.fontSize !== undefined || plainProps.fontFamily !== undefined)) {
            refreshTextboxCurve(obj, { skipRender: true });
        }
    });
    if (originalStates.size > 0) canvas.renderAll();
}

// Main handler for the primary export button
async function handleExport() {
    syncCurrentPageStateFromCanvas();
    const format = exportFormatSelect.value;
    const hasData = dataRows.length > 0;
    const totalRows = dataRows.length;
    const title = ($('#titleInput').value || 'Untitled_Template').trim();
    const isFreeUser = userRole !== 'pro' && userRole !== 'admin';

    // 2. Apply freemium limit
    // If identifier column is set, deduplicate rows by identifier for export
    let exportRows;
    if (hasData && identifierColumn && headers.includes(identifierColumn)) {
        const seen = new Set();
        exportRows = dataRows.filter(r => {
            const id = r[identifierColumn];
            if (!id || seen.has(id)) return false;
            seen.add(id);
            return true;
        });
    } else {
        exportRows = hasData ? dataRows : [null];
    }
    const rowsToProcess = hasData
        ? (isFreeUser ? exportRows.slice(0, 15) : exportRows)
        : [null];

    const zip = new JSZip();

    // Handle JSON export separately
    if (format === 'json') {
        const exportPayload = {
            version: 'csvlink-template-v2',
            ...buildTemplatePayload()
        };
        const json = JSON.stringify(exportPayload, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        saveAs(blob, `${title}.json`);
        return;
    }

    for (let i = 0; i < rowsToProcess.length; i++) {
        const row = rowsToProcess[i];
        const originalStates = row ? applyDataBindingsForRow(row) : new Map();

        const fileName = `${title}${hasData ? `_row_${i + 1}` : ''}.${format}`;
        const exportFormat = (format === 'pdf' || format === 'jpg') ? 'jpeg' : 'png';
        const dataURL = await generateCanvasDataURL(exportFormat);

        if (format === 'pdf') {
            const { width: pageW, height: pageH } = pageRect;
            const pdf = new jsPDF({ unit: 'px', format: [pageW, pageH] });
            pdf.addImage(dataURL, 'JPEG', 0, 0, pageW, pageH);
            if (hasData) {
                zip.file(fileName, await pdf.output('blob'));
            } else {
                saveAs(pdf.output('blob'), fileName);
            }
        } else if (format === 'png' || format === 'jpg') {
            const blob = await (await fetch(dataURL)).blob();
            if (hasData) {
                zip.file(fileName, blob);
            } else {
                saveAs(blob, fileName);
            }
        }

        // Restore original states
        restoreDataBindingsState(originalStates);
    }

    if (hasData) {
        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, `${title}.zip`);
    }

    // 2. Show pro modal AFTER export if limit was hit
    if (isFreeUser && totalRows > 15) {
        proLimitModal.style.display = 'flex';
    }
}
// Handle the "Single PDF" export button
async function handleSinglePdfExport() {
    syncCurrentPageStateFromCanvas();
    if (!dataRows.length) return;

    const isFreeUser = userRole !== 'pro' && userRole !== 'admin';
    let singlePdfExportRows;
    if (identifierColumn && headers.includes(identifierColumn)) {
        const seen = new Set();
        singlePdfExportRows = dataRows.filter(r => {
            const id = r[identifierColumn];
            if (!id || seen.has(id)) return false;
            seen.add(id);
            return true;
        });
    } else {
        singlePdfExportRows = dataRows;
    }
    const totalRows = singlePdfExportRows.length;
    const rowsToProcess = isFreeUser ? singlePdfExportRows.slice(0, 15) : singlePdfExportRows;

    const title = ($('#titleInput').value || 'Untitled_Template').trim();
    if (!pageRect) { alert('Page object not found.'); return; }
    const { width: pageW, height: pageH } = pageRect;
    const pdf = new jsPDF({ unit: 'px', format: [pageW, pageH] });
    let firstPage = true;

    for (const row of rowsToProcess) {
        const originalStates = applyDataBindingsForRow(row);

        const dataURL = await generateCanvasDataURL('jpeg');
        if (!firstPage) pdf.addPage([pageW, pageH]);
        pdf.addImage(dataURL, 'JPEG', 0, 0, pageW, pageH);
        firstPage = false;

        restoreDataBindingsState(originalStates);
    }

    saveAs(pdf.output('blob'), `${title}_all_pages.pdf`);

    if (isFreeUser && totalRows > 15) {
        proLimitModal.style.display = 'flex';
    }
}

async function handleExportAllCanvases() {
    syncCurrentPageStateFromCanvas();
    if (!Array.isArray(documentPages) || !documentPages.length) return;

    const title = ($('#titleInput').value || 'Untitled_Template').trim();
    const format = exportFormatSelect?.value || 'pdf';
    const selectedPageIndexes = getSelectedExportPageIndexes();
    if (!selectedPageIndexes.length) {
        showNotification('Select at least one page to export.', 'info', 2200);
        return;
    }

    if (format === 'json') {
        const payload = buildTemplatePayload();
        const selectedPages = selectedPageIndexes
            .map(index => deepClone(payload.pages?.[index]))
            .filter(Boolean);
        if (!selectedPages.length) {
            showNotification('No pages available for JSON export.', 'info', 2200);
            return;
        }

        const firstPage = selectedPages[0] || {};
        const exportPayload = {
            ...payload,
            page: {
                title: payload.page?.title || title,
                width: parsePositiveInt(firstPage?.width, DEFAULT_PAGE_WIDTH),
                height: parsePositiveInt(firstPage?.height, DEFAULT_PAGE_HEIGHT)
            },
            canvas: firstPage?.canvas || { version: '5.3.0', background: 'transparent', objects: [] },
            bindings: firstPage?.bindings || [],
            pages: selectedPages,
            currentPageIndex: 0
        };

        const json = JSON.stringify({ version: 'csvlink-template-v2', ...exportPayload }, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        saveAs(blob, `${title}_pages.json`);
        return;
    }

    if (format === 'pdf') {
        const firstPage = documentPages[selectedPageIndexes[0]];
        const firstW = parsePositiveInt(firstPage?.width, DEFAULT_PAGE_WIDTH);
        const firstH = parsePositiveInt(firstPage?.height, DEFAULT_PAGE_HEIGHT);
        const pdf = new jsPDF({ unit: 'px', format: [firstW, firstH] });

        for (let i = 0; i < selectedPageIndexes.length; i++) {
            const pageState = documentPages[selectedPageIndexes[i]];
            const pageW = parsePositiveInt(pageState?.width, DEFAULT_PAGE_WIDTH);
            const pageH = parsePositiveInt(pageState?.height, DEFAULT_PAGE_HEIGHT);
            const dataURL = await generatePageDataURLFromPageState(pageState, 'jpeg');
            if (i > 0) pdf.addPage([pageW, pageH]);
            pdf.addImage(dataURL, 'JPEG', 0, 0, pageW, pageH);
        }

        saveAs(pdf.output('blob'), `${title}_pages.pdf`);
        return;
    }

    const exportFormat = format === 'png' ? 'png' : 'jpeg';
    const ext = format === 'png' ? 'png' : 'jpg';
    if (selectedPageIndexes.length === 1) {
        const selectedIndex = selectedPageIndexes[0];
        const pageState = documentPages[selectedIndex];
        const dataURL = await generatePageDataURLFromPageState(pageState, exportFormat);
        const blob = await (await fetch(dataURL)).blob();
        saveAs(blob, `${title}_page_${selectedIndex + 1}.${ext}`);
        return;
    }

    const zip = new JSZip();
    for (const selectedIndex of selectedPageIndexes) {
        const pageState = documentPages[selectedIndex];
        const dataURL = await generatePageDataURLFromPageState(pageState, exportFormat);
        const blob = await (await fetch(dataURL)).blob();
        zip.file(`${title}_page_${selectedIndex + 1}.${ext}`, blob);
    }
    const content = await zip.generateAsync({ type: 'blob' });
    saveAs(content, `${title}_pages_${ext}.zip`);
}

// Event Listeners for Export
exportBtn.addEventListener('click', handleExport);
exportSinglePdfBtn.addEventListener('click', handleSinglePdfExport);
if (exportAllCanvasesBtn) exportAllCanvasesBtn.addEventListener('click', handleExportAllCanvases);
exportFormatSelect.addEventListener('change', updateExportUI);
if (exportPageSelectorBtn) {
    exportPageSelectorBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        const isOpen = exportPageSelectorMenu?.style.display === 'block';
        setExportPageSelectorOpen(!isOpen);
    });
}
if (exportAllPagesToggle) {
    exportAllPagesToggle.addEventListener('change', () => {
        if (!exportAllPagesToggle.checked) sanitizeExportPageSelections();
        syncExportPageSelectorUI();
    });
}
if (exportPageSelectorMenu) {
    exportPageSelectorMenu.addEventListener('click', (event) => event.stopPropagation());
}
document.addEventListener('click', (event) => {
    if (!exportPageSelectorWrap || !exportPageSelectorMenu) return;
    if (!exportPageSelectorWrap.contains(event.target)) setExportPageSelectorOpen(false);
});
syncExportPageSelectorUI();
on('#closeProLimitModal', 'click', () => proLimitModal.style.display = 'none');

// Binding logic
function applyBinding(o, prop, val, binding = null) {
    const strVal = String(val).trim();
    const numVal = parseFloat(strVal);
    switch (prop) {
        case 'Text Content':
            if (o.type === 'textbox') {
                o.set({ text: strVal });
                refreshTextboxCurve(o, { skipRender: true });
            }
            break;
        case 'Cell Text':
            if (o.isTable) {
                ensureTableCellData(o);
                const cellIndex = getNormalizedBindingCellIndex(o, binding || {});
                if (o.cellData[cellIndex]) {
                    o.cellData[cellIndex].text = strVal;
                    updateTableLayout(o);
                }
            }
            break;
        case 'Font Family':
            if (o.type === 'textbox') {
                ensureFontFamilyLoaded(strVal);
                o.set({ fontFamily: strVal });
                refreshTextboxCurve(o, { skipRender: true });
            }
            break;
        case 'Font Size':
            if (o.type === 'textbox' && !isNaN(numVal)) {
                o.set({ fontSize: numVal });
                refreshTextboxCurve(o, { skipRender: true });
            }
            break;
        case 'Fill': case 'Fill Color': o.set({ fill: strVal }); break;
        case 'Opacity': if (!isNaN(numVal)) o.set({ opacity: numVal }); break;
        case 'Border Color':
            if (o.isTable) {
                o.borderColor = strVal;
                ensureTableCellData(o);
                o.cellData.forEach(cell => { cell.borderColor = strVal; });
                updateTableLayout(o);
            }
            break;
        case 'Border Width':
            if (o.isTable && !isNaN(numVal)) {
                o.borderWidth = numVal;
                ensureTableCellData(o);
                o.cellData.forEach(cell => { cell.borderWidth = Math.max(0.5, numVal); });
                updateTableLayout(o);
            }
            break;
        case 'Stroke Color': o.set({ stroke: strVal }); break;
        case 'Stroke Width':
            if (!isNaN(numVal)) {
                o.set({ strokeWidth: numVal });
                o.setCoords();
            }
            break;
        case 'Corner Radius': if ('rx' in o && !isNaN(numVal)) o.set({ rx: numVal, ry: numVal }); break;
        case 'Image Fill URL': fabric.Image.fromURL(strVal, img => o.set('fill', new fabric.Pattern({ source: img.getElement() })), { crossOrigin: 'anonymous' }); break;
    }
    canvas.renderAll();
}


onClick('#csvViewBtn', openCsvView);
onClick('#closeCsvView', closeCsvView);
function restoreCanvasStateAfterLoad(callback) {
    pageRect = canvas.getObjects().find(o => o.oid === 'pageRect');
    if (pageRect) {
        pageRect.set({
            selectable: false,
            evented: false,
            hasControls: false,
            hasBorders: false,
            lockMovementX: true,
            lockMovementY: true,
            lockScalingX: true,
            lockScalingY: true,
            lockRotation: true,
            isArtboard: true,
            oid: 'pageRect'
        });
    }
    const pageId = currentCanvasPageId();
    canvas.getObjects().forEach(obj => {
        if (!obj || obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine) return;
        try {
            if (!obj.pageId) obj.pageId = pageId;
            stabilizeObjectAfterLoad(obj);
            if (obj.isTable) {
                ensureTableCellData(obj);
                const canInspectChildren = typeof obj.getObjects === 'function';
                const hasCellGroups = canInspectChildren
                    && obj.getObjects().every(child => child?.isTableCellGroup);
                if (!hasCellGroups) rebuildTableCells(obj);
                else updateTableLayout(obj);
            }
        } catch (error) {
            console.warn('Object restore skipped due to invalid object state:', error, obj);
        }
    });
    if (documentPages[currentPageIndex] && pageRect) {
        documentPages[currentPageIndex].width = parsePositiveInt(Math.round(pageRect.width), DEFAULT_PAGE_WIDTH);
        documentPages[currentPageIndex].height = parsePositiveInt(Math.round(pageRect.height), DEFAULT_PAGE_HEIGHT);
    }
    ensureFontsForCanvasObjects(canvas.getObjects());
    keepPageRectAtBack();
    drawGrid();
    renderLayers();
    refreshCanvasPageControls({ preserveScroll: true, ensureActiveVisible: false });
    applyCanvasMaskToActivePageObjects();
    canvas.renderAll();
    // historyLocked will be set to false by the caller (undo/redo)
    if (typeof callback === 'function') {
        callback();
    }
}

function normalizePastedObject(obj, pageId) {
    if (!obj) return;
    const ghostLike = !!obj.isCanvasGhost || !!obj.ghostSourceOid || obj.ghostSourcePageIndex !== undefined;
    if (ghostLike) {
        if (obj.clipPath) obj.clipPath = null;
        if (obj.excludeFromExport) obj.excludeFromExport = false;
        if (obj.isCanvasGhost) obj.isCanvasGhost = false;
        if (obj.isCanvasMask) delete obj.isCanvasMask;
        if (obj.ghostSourceOid) delete obj.ghostSourceOid;
        if (obj.ghostSourcePageIndex !== undefined) delete obj.ghostSourcePageIndex;
    }

    obj.oid = createUid('obj');
    obj.name = getUniqueName(obj.name || obj.type || 'object');
    obj.pageId = pageId;
    obj.evented = true;
    if (!obj.locked) obj.selectable = true;
    applyLockStateToObject(obj);

    // Recursively normalize children if it's a group
    if (typeof obj.forEachObject === 'function') {
        obj.forEachObject(child => normalizePastedObject(child, pageId));
    }
}

function offsetWorkspaceObjects(objects = [], dx = 0, dy = 0) {
    if (!Array.isArray(objects) || !objects.length) return;
    objects.forEach(obj => {
        if (!obj) return;
        obj.set({
            left: normalizeNumeric(obj.left, 0) + dx,
            top: normalizeNumeric(obj.top, 0) + dy
        });
        applyObjectMaskForPage(obj, currentPageIndex);
        obj.setCoords();
    });
}

function collectClipboardSourcePages(target) {
    const pageByOid = new Map();
    const pageIndexes = new Set();
    const objects = target?.type === 'activeSelection' && typeof target.getObjects === 'function'
        ? target.getObjects().filter(Boolean)
        : (target ? [target] : []);

    objects.forEach(obj => {
        if (!obj) return;
        const context = getWorkspaceObjectPageContext(obj);
        const contextIndex = Number.isInteger(context?.pageIndex) ? context.pageIndex : -1;
        const fallbackIndex = resolveObjectSourcePageIndex(obj);
        const pageIndex = contextIndex >= 0 ? contextIndex : fallbackIndex;
        const safeIndex = (pageIndex >= 0 && pageIndex < documentPages.length) ? pageIndex : currentPageIndex;
        pageIndexes.add(safeIndex);
        const oid = String(obj.oid || '').trim();
        if (oid) pageByOid.set(oid, safeIndex);
    });

    return {
        pageByOid,
        pageIndexes: Array.from(pageIndexes),
        hasMultipleSourcePages: pageIndexes.size > 1
    };
}

function copy() {
    const activeObject = canvas.getActiveObject();
    if (!activeObject) return Promise.resolve(false);
    ensureTextboxPathsCloneSafe(activeObject);
    const sourcePageIndex = activeObject.type === 'activeSelection'
        ? resolveSelectionSourcePageIndex(activeObject)
        : resolveObjectSourcePageIndex(activeObject);
    const sourceObjectType = activeObject.type || 'object';
    const sourceMeta = collectClipboardSourcePages(activeObject);

    // Capture data bindings for the clipboard
    const clipboardBindings = new Map();
    const processBindingCapture = (obj) => {
        const oid = (obj.oid || '').trim();
        if (oid && bindings.has(oid)) {
            clipboardBindings.set(oid, deepClone(bindings.get(oid)));
        }
    };

    if (activeObject.type === 'activeSelection') {
        activeObject.getObjects().forEach(processBindingCapture);
    } else {
        processBindingCapture(activeObject);
    }

    return new Promise(resolve => {
        activeObject.clone(cloned => {
            ensureTextboxPathsCloneSafe(cloned);
            _clipboard = cloned;
            _clipboardMeta = {
                sourcePageIndex,
                sourceObjectType,
                pasteCount: 0,
                clipboardBindings,
                sourcePageIndexes: sourceMeta.pageIndexes,
                hasMultipleSourcePages: sourceMeta.hasMultipleSourcePages,
                clipboardPageByOid: sourceMeta.pageByOid
            };
            resolve(true);
        }, SERIALIZE_PROPS);
    });
}

function duplicateSelection() {
    const activeObject = canvas.getActiveObject();
    if (!activeObject) return Promise.resolve(false);
    ensureTextboxPathsCloneSafe(activeObject);
    const sourcePageIndex = currentPageIndex;
    const sourceMeta = collectClipboardSourcePages(activeObject);

    // Keep bound data on duplicated objects, matching copy/paste behavior.
    const clipboardBindings = new Map();
    const processBindingCapture = (obj) => {
        const oid = (obj.oid || '').trim();
        if (oid && bindings.has(oid)) {
            clipboardBindings.set(oid, deepClone(bindings.get(oid)));
        }
    };

    if (activeObject.type === 'activeSelection') {
        activeObject.getObjects().forEach(processBindingCapture);
    } else {
        processBindingCapture(activeObject);
    }

    return new Promise(resolve => {
        activeObject.clone(cloned => {
            ensureTextboxPathsCloneSafe(cloned);
            _clipboard = cloned;
            _clipboardMeta = {
                sourcePageIndex,
                sourceObjectType: cloned?.type || activeObject.type || 'object',
                pasteCount: 0,
                clipboardBindings,
                sourcePageIndexes: sourceMeta.pageIndexes,
                hasMultipleSourcePages: sourceMeta.hasMultipleSourcePages,
                clipboardPageByOid: sourceMeta.pageByOid
            };
            paste();
            resolve(true);
        }, SERIALIZE_PROPS);
    });
}

function removeCanvasObjects(objects = []) {
    const list = Array.from(new Set((objects || []).filter(Boolean)));
    if (!list.length) return false;

    let ghostChanged = false;
    list.forEach(obj => {
        if (obj.isCanvasGhost) {
            if (commitGhostObjectRemoval(obj)) ghostChanged = true;
        }
        // Also remove associated data bindings if it's a permanent removal
        if (!obj.isCanvasGhost && obj.oid) {
            bindings.delete(obj.oid);
        }
    });

    // Handle selection state safely
    const active = canvas.getActiveObject();
    if (active && active.type === 'activeSelection') {
        const members = active.getObjects();
        const remaining = members.filter(m => !list.includes(m));
        if (remaining.length === 0) {
            canvas.discardActiveObject();
        } else if (remaining.length < members.length) {
            // Update selection to exclude removed objects
            canvas.discardActiveObject();
            if (remaining.length === 1) {
                canvas.setActiveObject(remaining[0]);
            } else {
                const sel = new fabric.ActiveSelection(remaining, { canvas });
                canvas.setActiveObject(sel);
            }
        }
    } else if (active && list.includes(active)) {
        canvas.discardActiveObject();
    }

    // Perform actual removal from canvas
    list.forEach(obj => {
        if (obj && typeof canvas.remove === 'function') {
            canvas.remove(obj);
        }
    });

    if (ghostChanged) {
        updateFloatingLinker(null);
        renderCanvasGhostPages();
        renderLayers();
        renderPageInspector();
        refreshCanvasPageControlsDebounced();
        requestSaveState();
        return true;
    }

    canvas.requestRenderAll();
    renderLayers();
    refreshCanvasPageControlsDebounced();
    requestSaveState();
    return false;
}

function cut() {
    copy();
    const activeObjects = canvas.getActiveObjects();
    if (!activeObjects.length) return;
    removeCanvasObjects(activeObjects);
}

function paste(options = {}) {
    if (!_clipboard) return;
    ensureTextboxPathsCloneSafe(_clipboard);
    const forceOffset = options.forceOffset === true;
    const targetPageIndex = currentPageIndex;
    const sourcePageIndex = Number.isInteger(_clipboardMeta?.sourcePageIndex)
        ? Math.max(0, Math.min(documentPages.length - 1, _clipboardMeta.sourcePageIndex))
        : targetPageIndex;
    const pasteCount = Math.max(0, parseInt(_clipboardMeta?.pasteCount, 10) || 0);
    const nextPasteCount = pasteCount + 1;

    const sourcePageLeft = getPageLayoutLeft(sourcePageIndex);
    const targetPageLeft = getPageLayoutLeft(targetPageIndex);
    const deltaX = targetPageLeft - sourcePageLeft;
    const deltaY = 0;
    const samePage = sourcePageIndex === targetPageIndex;
    const nudge = (forceOffset || samePage) ? (20 * nextPasteCount) : 0;
    const copiedFromActiveSelection = _clipboardMeta?.sourceObjectType === 'activeSelection';
    const preserveSourcePages = _clipboardMeta?.hasMultipleSourcePages === true;
    const clipboardPageByOid = _clipboardMeta?.clipboardPageByOid instanceof Map
        ? _clipboardMeta.clipboardPageByOid
        : new Map();

    _clipboard.clone((clonedObj) => {
        isPastingFromClipboard = true;
        try {
            ensureTextboxPathsCloneSafe(clonedObj);
            const currentPageId = currentCanvasPageId();
            const pastedObjects = [];
            let updatedOtherPages = false;
            const clipboardBindings = _clipboardMeta?.clipboardBindings || new Map();
            canvas.discardActiveObject();

            const transferDataBindings = (oldOid, newOid) => {
                if (oldOid && clipboardBindings.has(oldOid)) {
                    bindings.set(newOid, deepClone(clipboardBindings.get(oldOid)));
                }
            };

            const shouldPasteAsSelection = (copiedFromActiveSelection || clonedObj.type === 'activeSelection')
                && typeof clonedObj.getObjects === 'function';
            if (shouldPasteAsSelection) {
                const offsetX = nudge;
                const offsetY = deltaY + nudge;
                clonedObj.canvas = canvas;
                clonedObj.set({
                    left: normalizeNumeric(clonedObj.left, 0) + offsetX,
                    top: normalizeNumeric(clonedObj.top, 0) + offsetY,
                    evented: true
                });
                clonedObj.setCoords(); // CRITICAL: Update matrices before calculating member positions

                const selectionMatrix = typeof clonedObj.calcOwnMatrix === 'function'
                    ? clonedObj.calcOwnMatrix()
                    : clonedObj.calcTransformMatrix();

                const members = (typeof clonedObj.getObjects === 'function' ? clonedObj.getObjects() : []).slice();
                members.forEach(obj => {
                    const oldOid = (obj.oid || '').trim();
                    const mappedSourcePageIndex = clipboardPageByOid.has(oldOid)
                        ? clipboardPageByOid.get(oldOid)
                        : -1;
                    const memberSourcePageIndex = (mappedSourcePageIndex >= 0 && mappedSourcePageIndex < documentPages.length)
                        ? mappedSourcePageIndex
                        : resolveObjectSourcePageIndex(obj);
                    const memberSourcePageLeft = getPageLayoutLeft(memberSourcePageIndex);
                    const memberTargetPageIndex = preserveSourcePages ? memberSourcePageIndex : targetPageIndex;
                    const memberTargetPageLeft = getPageLayoutLeft(memberTargetPageIndex);
                    const memberDeltaX = memberTargetPageLeft - memberSourcePageLeft;
                    const memberTargetPageId = documentPages[memberTargetPageIndex]?.id || currentPageId;

                    // Bake the selection matrix into each member so absolute placement survives ungrouping.
                    if (selectionMatrix && fabric?.util?.addTransformToObject) {
                        fabric.util.addTransformToObject(obj, selectionMatrix);
                        obj.set({
                            left: normalizeNumeric(obj.left, 0) + memberDeltaX,
                            top: normalizeNumeric(obj.top, 0) + deltaY
                        });
                    } else {
                        const matrix = obj.calcTransformMatrix();
                        const decomposed = fabric.util.qrDecompose(matrix);
                        obj.set({
                            left: normalizeNumeric(decomposed.translateX, normalizeNumeric(obj.left, 0)) + memberDeltaX,
                            top: normalizeNumeric(decomposed.translateY, normalizeNumeric(obj.top, 0)) + deltaY,
                            scaleX: normalizeNumeric(decomposed.scaleX, normalizeNumeric(obj.scaleX, 1)),
                            scaleY: normalizeNumeric(decomposed.scaleY, normalizeNumeric(obj.scaleY, 1)),
                            angle: normalizeNumeric(decomposed.angle, normalizeNumeric(obj.angle, 0)),
                            skewX: normalizeNumeric(decomposed.skewX, normalizeNumeric(obj.skewX, 0)),
                            skewY: normalizeNumeric(decomposed.skewY, normalizeNumeric(obj.skewY, 0))
                        });
                    }
                    obj.group = null; // Detach from the temporary cloned selection

                    normalizePastedObject(obj, memberTargetPageId);
                    obj.setCoords();
                    const newOid = obj.oid;
                    if (memberTargetPageIndex === currentPageIndex) {
                        applyObjectMaskForPage(obj, currentPageIndex);
                        canvas.add(obj);
                        pastedObjects.push(obj);
                    } else {
                        const objectState = serializeWorkspaceObjectForPageState(obj, memberTargetPageIndex, newOid);
                        if (objectState) {
                            upsertObjectInPageState(memberTargetPageIndex, newOid, objectState);
                            updatedOtherPages = true;
                        }
                    }

                    // Re-bind data if applicable
                    transferDataBindings(oldOid, newOid);
                });

                if (pastedObjects.length > 0) {
                    const newSelection = new fabric.ActiveSelection(pastedObjects, {
                        canvas: canvas
                    });
                    newSelection.setCoords();
                    canvas.setActiveObject(newSelection);
                }
            } else {
                const oldOid = (clonedObj.oid || '').trim();
                normalizePastedObject(clonedObj, currentPageId);
                const newOid = clonedObj.oid;
                canvas.add(clonedObj);
                pastedObjects.push(clonedObj);

                // Re-bind data if applicable
                transferDataBindings(oldOid, newOid);
            }

            if (!pastedObjects.length && !updatedOtherPages) return;

            if (!shouldPasteAsSelection && pastedObjects.length) {
                offsetWorkspaceObjects(pastedObjects, deltaX + nudge, deltaY + nudge);
                canvas.setActiveObject(pastedObjects[0]);
            }

            _clipboardMeta = {
                ...(_clipboardMeta || {}),
                sourcePageIndex,
                pasteCount: nextPasteCount,
                clipboardBindings // Retain bindings for subsequent pastes
            };

            canvas.requestRenderAll();
            if (updatedOtherPages) renderCanvasGhostPages();
            renderLayers();
            refreshCanvasPageControlsDebounced();
            requestSaveState();
        } finally {
            isPastingFromClipboard = false;
            scheduleOutsideObjectsCleanup();
        }
    }, SERIALIZE_PROPS);
}
function renderLayers(e) {
    const list = $('#layersList'); if (!list) return; list.innerHTML = '';
    const activeObjects = canvas.getActiveObjects();
    const objects = canvas.getObjects().filter(o => o.oid !== 'pageRect' && !o.excludeFromExport && !o.isSnapLine && !o.isArtboard);
    if (objects.length === 0) { list.innerHTML = '<p class="muted" style="text-align: center; padding: 24px 0; font-size: 13px;">Add an object to the canvas.</p>'; return; }
    objects.slice().reverse().forEach(obj => {
        const item = document.createElement('div');
        item.className = 'layer-item';
        item.dataset.locked = !!obj.locked;
        if (activeObjects.includes(obj)) item.classList.add('active');

        item.onclick = (e) => {
            if (obj.locked) return;
            // 7. Layer multi-select
            if (e.shiftKey || e.ctrlKey || e.metaKey) {
                if (canvas.getActiveObjects().includes(obj)) {
                    canvas.getActiveObject().removeWithUpdate(obj);
                } else {
                    canvas.getActiveObject().addWithUpdate(obj);
                }
            } else {
                canvas.setActiveObject(obj);
            }
            canvas.renderAll();
        };

        // DRAG AND DROP HANDLERS
        item.draggable = true;
        item.ondragstart = (e) => {
            item.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', obj.oid);
        };
        item.ondragend = () => {
            item.classList.remove('dragging');
            document.querySelectorAll('.layer-item').forEach(i => i.classList.remove('drag-over'));
        };
        item.ondragover = (e) => {
            e.preventDefault();
            item.classList.add('drag-over');
        };
        item.ondragleave = () => {
            item.classList.remove('drag-over');
        };
        item.ondrop = (e) => {
            e.preventDefault();
            const draggedOid = e.dataTransfer.getData('text/plain');
            const draggedObj = canvas.getObjects().find(o => o.oid === draggedOid);
            if (draggedObj && draggedObj !== obj) {
                // Move draggedObj to be above obj
                canvas.remove(draggedObj);
                const objects = canvas.getObjects();
                const targetIndex = objects.indexOf(obj);
                canvas.insertAt(draggedObj, targetIndex + 1);

                // Re-ensure pageRect is at bottom
                keepPageRectAtBack();
                renderLayers();
                requestSaveState();
            }
        };

        // Capitalize layer name (first letter uppercase)
        const rawName = obj.name || obj.type;
        const displayName = rawName.charAt(0).toUpperCase() + rawName.slice(1);
        const nameSpan = document.createElement('span'); nameSpan.className = 'layer-name'; nameSpan.textContent = displayName;
        nameSpan.ondblclick = () => { /* ... rename logic ... */ };

        item.innerHTML = `
            <div class="layer-actions">
                <button title="Lock/Unlock" class="btn ghost btn-lock"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">${obj.locked ? '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>' : '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>'}</svg></button>
                <button title="Bring Forward" class="btn ghost btn-fwd"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M6 15l6-6 6 6"/></svg></button>
                <button title="Send Backward" class="btn ghost btn-bwd"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M6 9l6 6 6-6"/></svg></button>
                <button title="Bring to Front" class="btn ghost btn-front"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 5l6 6m-6-6l-6 6M12 19V5M5 19h14"/></svg></button>
                <button title="Send to Back" class="btn ghost btn-back"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 19l-6-6m6 6l6-6M12 5v14M5 5h14"/></svg></button>
            </div>`;
        item.prepend(nameSpan);

        item.querySelector('.btn-lock').onclick = (e) => { e.stopPropagation(); toggleLock(obj); };
        item.querySelector('.btn-front').onclick = (e) => { e.stopPropagation(); canvas.bringToFront(obj); renderLayers(); requestSaveState(); };
        item.querySelector('.btn-back').onclick = (e) => { e.stopPropagation(); canvas.sendToBack(obj); keepPageRectAtBack(); renderLayers(); requestSaveState(); };
        item.querySelector('.btn-fwd').onclick = (e) => { e.stopPropagation(); canvas.bringForward(obj); renderLayers(); requestSaveState(); };
        item.querySelector('.btn-bwd').onclick = (e) => { e.stopPropagation(); canvas.sendBackwards(obj); renderLayers(); requestSaveState(); };
        list.appendChild(item);
    });
}
function toggleLock(obj) {
    obj.locked = !obj.locked;
    applyLockStateToObject(obj);
    if (obj.locked) canvas.discardActiveObject();
    obj.setCoords();
    canvas.renderAll();
    renderLayers();
    requestSaveState();
}
function centerAndFitPage() {
    if (!pageRect) return;
    const { width: wrapperW, height: wrapperH } = canvasWrapper.getBoundingClientRect();
    const pageW = pageRect.width;
    const pageH = pageRect.height;
    const zoom = Math.min(wrapperW / pageW, wrapperH / pageH) * 0.95;
    canvas.setZoom(zoom);
    const center = pageRect.getCenterPoint();
    const vpt = [zoom, 0, 0, zoom, (wrapperW / 2) - center.x * zoom, (wrapperH / 2) - center.y * zoom];
    clampViewportTransform(vpt);
    canvas.setViewportTransform(vpt);
    updateZoomLabel();
    canvas.renderAll();
}
onClick('#centerViewBtn', centerAndFitPage);
window.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

    const isCtrl = e.ctrlKey || e.metaKey;
    const key = e.key.toLowerCase();
    const activeObj = canvas.getActiveObject();

    if (isCtrl && key === 'z') {
        e.preventDefault();
        if (e.shiftKey) redo();
        else undo();
    }

    if (isCtrl && key === 'y') {
        e.preventDefault();
        redo();
    }

    if (isCtrl && key === 'c') {
        e.preventDefault();
        copy();
    }

    if (isCtrl && key === 'x') {
        e.preventDefault();
        cut();
    }

    if (isCtrl && key === 'v') {
        e.preventDefault();
        paste();
    }

    if (isCtrl && key === 'd') {
        e.preventDefault();
        duplicateSelection();
    }

    if (isCtrl && key === 'a') {
        e.preventDefault();
        const allObjects = canvas.getObjects().filter(o => o.selectable);
        canvas.setActiveObject(new fabric.ActiveSelection(allObjects, { canvas }));
        canvas.renderAll();
    }

    if (isCtrl && key === 'g') {
        e.preventDefault();
        if (activeObj && activeObj.type === 'activeSelection') activeObj.toGroup();
    }

    if (isCtrl && e.shiftKey && key === 'g') {
        e.preventDefault();
        if (activeObj && activeObj.type === 'group') activeObj.toActiveSelection();
    }

    if (e.key.startsWith('Arrow') && activeObj) {
        e.preventDefault();
        scheduleOutsideObjectsCleanup.clear();
        const amount = e.shiftKey ? 10 : 1;
        switch (e.key) {
            case 'ArrowUp': activeObj.top -= amount; break;
            case 'ArrowDown': activeObj.top += amount; break;
            case 'ArrowLeft': activeObj.left -= amount; break;
            case 'ArrowRight': activeObj.left += amount; break;
        }
        activeObj.setCoords();
        canvas.renderAll();
    }

    if (e.key === 'Delete' || e.key === 'Backspace') {
        const activeObjects = canvas.getActiveObjects();
        if (activeObjects.length) {
            removeCanvasObjects(activeObjects);
        }
    }
});

window.addEventListener('keyup', e => {
    if (!e.key.startsWith('Arrow')) return;
    const active = canvas.getActiveObject();
    if (!active) return;
    scheduleOutsideObjectsCleanup();
    requestSaveState();
});



// components/06-ai-assistant.js
        // --- AI ASSISTANT ---
        const aiApiKeyInput = $('#aiApiKeyPanel');
        const aiPromptInput = $('#aiChatPrompt');
        const aiSendBtn = $('#aiChatSendBtn');
        const aiSendBtnText = $('#aiChatSendText');
        const aiChatSpinner = $('#aiChatSpinner');
        const aiChatLog = $('#aiChatLog');
        const aiResetChatBtn = $('#aiResetChatBtn');
        const aiFileInput = $('#aiChatFile');
        const aiClearFileBtn = $('#aiClearFileBtn');
        const aiAttachmentMeta = $('#aiAttachmentMeta');

        const aiUiReady = [
            aiApiKeyInput,
            aiPromptInput,
            aiSendBtn,
            aiSendBtnText,
            aiChatSpinner,
            aiChatLog,
            aiResetChatBtn,
            aiFileInput,
            aiClearFileBtn,
            aiAttachmentMeta
        ].every(Boolean);

        if (!aiUiReady) {
            console.warn('AI panel controls missing. AI copilot disabled.');
        } else {
            const AI_ICON_BASE = 'https://mzdhdmfjwdpolrxraqtv.supabase.co/storage/v1/object/public/elements/icons';
            const AI_MAX_TEXT_ATTACHMENT_CHARS = 20000;
            const AI_MAX_BINARY_ATTACHMENT_BYTES = 4 * 1024 * 1024;
            const AI_CANVAS_SNAPSHOT_MAX_SIDE = 820;
            const AI_CANVAS_SNAPSHOT_QUALITY = 0.4;
            const AI_REQUEST_TIMEOUT_MS = 36000;
            const AI_TEMPLATE_REQUEST_TIMEOUT_MS = 95000;
            const AI_TEMPLATE_RETRY_TIMEOUT_MS = 60000;
            const AI_MAX_CONVERSATION_ITEMS = 6;
            const AI_MAX_CONVERSATION_CHARS = 240;
            const AI_MAX_APPLIED_ACTIONS = 8;
            const AI_MAX_APPLIED_ACTION_CHARS = 180;
            const AI_MAX_CONTEXT_COLUMNS = 14;
            const AI_MAX_CANVAS_JSON_CHARS = 24000;
            const AI_MAX_CANVAS_JSON_OBJECTS = 80;
            const AI_MAX_TEMPLATE_CONTEXT_CHARS = 52000;
            const AI_MAX_TEMPLATE_OBJECTS_PER_PAGE = 120;
            const AI_MAX_TEMPLATE_PAGES_CONTEXT = 10;
            const AI_ATTACHMENT_IMAGE_MAX_SIDE = 1400;
            const AI_ATTACHMENT_IMAGE_QUALITY = 0.78;
            const AI_ATTACHMENT_IMAGE_TARGET_BASE64 = 900000;
            const AI_RETRY_TEXT_ATTACHMENT_CHARS = 6000;
            const AI_STRICT_MAX_PAGES = 24;
            const AI_STRICT_MAX_OBJECTS_PER_PAGE = 280;
            const AI_STRICT_MAX_GROUP_CHILDREN = 60;
            const AI_STRICT_MAX_OBJECT_DEPTH = 3;
            const AI_STRICT_MAX_TEXT_LENGTH = 5000;
            const AI_STRICT_MAX_IMAGE_SRC_CHARS = 16000;
            const AI_STRICT_MAX_PATH_SEGMENTS = 220;
            const AI_STRICT_MAX_HEADERS = 200;
            const AI_STRICT_MAX_ROWS = 5000;
            const AI_STRICT_ALLOWED_TYPES = new Set([
                'rect',
                'circle',
                'triangle',
                'textbox',
                'image',
                'line',
                'path',
                'group',
                'polygon',
                'polyline',
                'ellipse'
            ]);
            const AI_STRICT_ALLOWED_TEXT_ALIGNS = new Set(['left', 'center', 'right', 'justify']);
            const AI_MODEL_NAME = 'gemini-2.5-flash';
            const AI_MODEL_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/${AI_MODEL_NAME}:generateContent`;
            const AI_MODEL_STREAM_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/${AI_MODEL_NAME}:streamGenerateContent?alt=sse`;
            const AI_CREATIVE_REQUEST_TIMEOUT_MS = 90000;
            const AI_LIVE_RENDER_DELAY_MS = 28;
            const AI_JSON_RESPONSE_SCHEMA = {
                type: 'OBJECT',
                properties: {
                    thought: { type: 'STRING', description: 'Optional planning notes for action selection.' },
                    reply: { type: 'STRING' },
                    actions: {
                        type: 'ARRAY',
                        items: { type: 'OBJECT' }
                    }
                },
                required: ['reply', 'actions']
            };

            let aiAutoApplyEnabled = true;
            let aiConversation = [];
            let aiAttachment = null;

            const savedApiKey = localStorage.getItem('googleAiApiKey');
            if (savedApiKey) aiApiKeyInput.value = savedApiKey;

            function setAiBusy(isBusy) {
                aiSendBtn.disabled = isBusy;
                aiSendBtnText.style.display = isBusy ? 'none' : 'inline-block';
                aiChatSpinner.style.display = isBusy ? 'inline-flex' : 'none';
            }

            function ensureChatScrolledToBottom() {
                aiChatLog.scrollTop = aiChatLog.scrollHeight;
            }

            function clampText(value, maxChars = 240) {
                const text = String(value || '').replace(/\s+/g, ' ').trim();
                if (!text) return '';
                if (text.length <= maxChars) return text;
                return `${text.slice(0, Math.max(8, maxChars - 3))}...`;
            }

            function extractFirstQuestion(value = '') {
                const text = String(value || '').replace(/\s+/g, ' ').trim();
                if (!text) return '';
                const match = text.match(/[^?]+\?/);
                return match ? match[0].trim() : '';
            }

            function appendAiChatMessage(kind, text) {
                const empty = aiChatLog.querySelector('.ai-chat-empty');
                if (empty) empty.remove();
                const el = document.createElement('div');
                el.className = `ai-chat-message ${kind}`;
                el.textContent = text;
                aiChatLog.appendChild(el);
                ensureChatScrolledToBottom();
                return el;
            }

            function createAiThinkingTicker(targetEl) {
                const startTime = Date.now();
                const stages = [
                    'Thinking',
                    'Reviewing canvas context',
                    'Planning design actions',
                    'Preparing response'
                ];
                let stageIndex = 0;
                let stageOverride = '';

                const render = () => {
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    const stage = stageOverride || stages[stageIndex % stages.length];
                    stageIndex += 1;
                    targetEl.textContent = `${stage}... ${elapsed}s`;
                };

                render();
                const intervalId = setInterval(render, 1200);

                return {
                    setStage(nextStage) {
                        stageOverride = String(nextStage || '').trim();
                    },
                    stop() {
                        clearInterval(intervalId);
                    }
                };
            }

            function resetAiChat() {
                aiConversation = [];
                aiAutoApplyEnabled = true;
                aiChatLog.innerHTML = '<div class="ai-chat-empty muted">Ask for layout ideas, canvas changes, dimensions, icons, and iterative edits.</div>';
                clearAiAttachment();
            }

            function formatAttachmentSize(sizeBytes = 0) {
                if (!Number.isFinite(sizeBytes) || sizeBytes <= 0) return '0 B';
                if (sizeBytes < 1024) return `${sizeBytes} B`;
                if (sizeBytes < 1024 * 1024) return `${(sizeBytes / 1024).toFixed(1)} KB`;
                return `${(sizeBytes / (1024 * 1024)).toFixed(2)} MB`;
            }

            function updateAttachmentMeta() {
                if (!aiAttachment) {
                    aiAttachmentMeta.textContent = '';
                    aiClearFileBtn.disabled = true;
                    return;
                }
                aiAttachmentMeta.textContent = `Attached: ${aiAttachment.name} (${formatAttachmentSize(aiAttachment.size)})`;
                aiClearFileBtn.disabled = false;
            }

            function clearAiAttachment() {
                aiAttachment = null;
                aiFileInput.value = '';
                updateAttachmentMeta();
            }

            function arrayBufferToBase64(buffer) {
                const bytes = new Uint8Array(buffer);
                const chunkSize = 0x8000;
                let binary = '';
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    const chunk = bytes.subarray(i, i + chunkSize);
                    binary += String.fromCharCode(...chunk);
                }
                return btoa(binary);
            }

            function isTextLikeFile(file) {
                if (!file) return false;
                const type = (file.type || '').toLowerCase();
                const name = (file.name || '').toLowerCase();
                return type.startsWith('text/')
                    || type.includes('json')
                    || type.includes('xml')
                    || type.includes('csv')
                    || name.endsWith('.txt')
                    || name.endsWith('.md')
                    || name.endsWith('.json')
                    || name.endsWith('.csv')
                    || name.endsWith('.svg');
            }

            async function readFileAsDataUrl(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(String(e.target?.result || ''));
                    reader.onerror = () => reject(new Error('Failed to read image file.'));
                    reader.readAsDataURL(file);
                });
            }

            async function optimizeImageDataUrl(dataUrl, maxSide = AI_ATTACHMENT_IMAGE_MAX_SIDE, quality = AI_ATTACHMENT_IMAGE_QUALITY) {
                const parsed = String(dataUrl || '').match(/^data:(.*?);base64,(.*)$/);
                if (!parsed?.[1] || !parsed?.[2]) return null;
                const sourceMime = parsed[1];
                const sourceBase64 = parsed[2];
                if (!sourceMime.startsWith('image/')) {
                    return { mimeType: sourceMime, base64Data: sourceBase64 };
                }
                if (sourceBase64.length <= 900000) {
                    return { mimeType: sourceMime, base64Data: sourceBase64 };
                }
                try {
                    const img = await new Promise((resolve, reject) => {
                        const el = new Image();
                        el.onload = () => resolve(el);
                        el.onerror = () => reject(new Error('Failed to decode image attachment.'));
                        el.src = dataUrl;
                    });
                    const naturalW = Math.max(1, parseInt(img.naturalWidth, 10) || parseInt(img.width, 10) || 1);
                    const naturalH = Math.max(1, parseInt(img.naturalHeight, 10) || parseInt(img.height, 10) || 1);
                    const aggressiveMaxSide = sourceBase64.length > 2200000 ? Math.min(maxSide, 1100) : maxSide;
                    const ratio = Math.min(1, aggressiveMaxSide / Math.max(naturalW, naturalH));
                    const targetW = Math.max(1, Math.round(naturalW * ratio));
                    const targetH = Math.max(1, Math.round(naturalH * ratio));
                    const canvasEl = document.createElement('canvas');
                    canvasEl.width = targetW;
                    canvasEl.height = targetH;
                    const ctx = canvasEl.getContext('2d', { alpha: false });
                    if (!ctx) return { mimeType: sourceMime, base64Data: sourceBase64 };
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, targetW, targetH);
                    ctx.drawImage(img, 0, 0, targetW, targetH);
                    const qualitySteps = [quality, 0.68, 0.58, 0.48, 0.4]
                        .filter((value, index, arr) => Number.isFinite(value) && value > 0.2 && arr.indexOf(value) === index);
                    let bestMime = sourceMime;
                    let bestBase64 = sourceBase64;
                    for (let i = 0; i < qualitySteps.length; i++) {
                        const compressedDataUrl = canvasEl.toDataURL('image/jpeg', qualitySteps[i]);
                        const compressedMatch = String(compressedDataUrl).match(/^data:(.*?);base64,(.*)$/);
                        if (!compressedMatch?.[1] || !compressedMatch?.[2]) continue;
                        bestMime = compressedMatch[1];
                        bestBase64 = compressedMatch[2];
                        if (bestBase64.length <= AI_ATTACHMENT_IMAGE_TARGET_BASE64) break;
                    }
                    if (!bestMime || !bestBase64) {
                        return { mimeType: sourceMime, base64Data: sourceBase64 };
                    }
                    return {
                        mimeType: bestMime,
                        base64Data: bestBase64
                    };
                } catch (_) {
                    return { mimeType: sourceMime, base64Data: sourceBase64 };
                }
            }

            async function toAttachmentPayload(file) {
                if (!file) return null;

                if (file.type && file.type.startsWith('image/')) {
                    const dataUrl = await readFileAsDataUrl(file);
                    const optimized = await optimizeImageDataUrl(dataUrl);
                    const mimeType = optimized?.mimeType;
                    const base64Data = optimized?.base64Data;
                    if (!mimeType || !base64Data) throw new Error('Invalid image attachment format.');
                    return {
                        name: file.name || 'image',
                        size: Math.max(file.size || 0, Math.ceil(base64Data.length * 0.75)),
                        kind: 'inline',
                        mimeType,
                        inlineData: base64Data
                    };
                }

                if (isTextLikeFile(file)) {
                    const raw = await file.text();
                    const text = raw.length > AI_MAX_TEXT_ATTACHMENT_CHARS
                        ? `${raw.slice(0, AI_MAX_TEXT_ATTACHMENT_CHARS)}\n...[truncated]`
                        : raw;
                    return {
                        name: file.name || 'text-file',
                        size: file.size || 0,
                        kind: 'text',
                        text
                    };
                }

                const binarySize = file.size || 0;
                if (binarySize > AI_MAX_BINARY_ATTACHMENT_BYTES) {
                    throw new Error('Attachment is too large. Keep binary files under 4 MB.');
                }
                const buffer = await file.arrayBuffer();
                return {
                    name: file.name || 'attachment',
                    size: binarySize,
                    kind: 'inline',
                    mimeType: file.type || 'application/octet-stream',
                    inlineData: arrayBufferToBase64(buffer)
                };
            }

            function summarizeActiveSelection() {
                const active = canvas.getActiveObject();
                if (!active) return 'none';
                if (active.type === 'activeSelection' && typeof active.getObjects === 'function') {
                    const members = active.getObjects().filter(Boolean);
                    const counts = {};
                    members.slice(0, 8).forEach(member => {
                        const type = String(member?.type || 'object');
                        counts[type] = (counts[type] || 0) + 1;
                    });
                    const typeSummary = Object.entries(counts)
                        .slice(0, 4)
                        .map(([type, count]) => `${count} ${type}`)
                        .join(', ');
                    return `${members.length} selected objects${typeSummary ? ` (${typeSummary})` : ''}`;
                }
                const name = active.name || active.type || 'object';
                const width = Math.round(active.getScaledWidth?.() || active.width || 0);
                const height = Math.round(active.getScaledHeight?.() || active.height || 0);
                const details = [`${width}x${height}`];
                const fill = typeof active.fill === 'string' ? active.fill : '';
                const stroke = typeof active.stroke === 'string' ? active.stroke : '';
                if ((active.type === 'textbox' || active.type === 'i-text') && typeof active.text === 'string') {
                    details.push(`text="${clampText(active.text, 30)}"`);
                    if (fill) details.push(`color=${fill}`);
                } else if (fill) {
                    details.push(`fill=${fill}`);
                }
                if (stroke) details.push(`stroke=${stroke}`);
                return `${name} (${details.join(', ')})`;
            }

            function buildEditorContextSummary() {
                const currentPage = documentPages[currentPageIndex] || {};
                const pagesSummary = documentPages
                    .slice(0, 12)
                    .map((p, idx) => {
                        const w = parsePositiveInt(p?.width, DEFAULT_PAGE_WIDTH);
                        const h = parsePositiveInt(p?.height, DEFAULT_PAGE_HEIGHT);
                        return `${idx + 1}:${w}x${h}${idx === currentPageIndex ? '*' : ''}`;
                    })
                    .join(', ');
                const columns = headers.length
                    ? `${headers.slice(0, AI_MAX_CONTEXT_COLUMNS).join(', ')}${headers.length > AI_MAX_CONTEXT_COLUMNS ? ', ...' : ''}`
                    : 'none';
                const objectCount = canvas.getObjects()
                    .filter(o => o && o.oid !== 'pageRect' && !o.excludeFromExport && !o.isSnapLine && !o.isCanvasGhost && !o.isArtboard)
                    .length;
                return [
                    `Pages: ${documentPages.length || 1} (${pagesSummary || '1:768x1024*'})`,
                    `Current page index (1-based): ${currentPageIndex + 1}`,
                    `Current page size: ${parsePositiveInt(currentPage.width, DEFAULT_PAGE_WIDTH)}x${parsePositiveInt(currentPage.height, DEFAULT_PAGE_HEIGHT)}`,
                    `Objects on current page: ${objectCount}`,
                    `Active selection: ${summarizeActiveSelection()}`,
                    `Data columns: ${columns}`
                ].join('\n');
            }

            function buildConversationSummary(limit = 12) {
                const maxItems = Math.max(1, Math.min(limit, AI_MAX_CONVERSATION_ITEMS));
                const subset = aiConversation.slice(-maxItems);
                if (!subset.length) return 'No prior chat context.';
                return subset
                    .map(msg => `${msg.role.toUpperCase()}: ${clampText(msg.text, AI_MAX_CONVERSATION_CHARS)}`)
                    .join('\n');
            }

            function summarizeAppliedActions(actions = []) {
                if (!Array.isArray(actions) || !actions.length) return 'none';
                return actions
                    .slice(0, AI_MAX_APPLIED_ACTIONS)
                    .map((action, idx) => `${idx + 1}. ${clampText(JSON.stringify(action), AI_MAX_APPLIED_ACTION_CHARS)}`)
                    .join('\n');
            }

            function buildCopilotPrompt(userPrompt, options = {}) {
                const phase = String(options.phase || 'full').toLowerCase() === 'draft' ? 'draft' : 'full';
                const maxActions = phase === 'draft' ? 5 : 12;
                const applyMode = aiAutoApplyEnabled ? 'apply' : 'plan_only';
                const includeConversation = options.includeConversation !== false;
                const appliedActions = Array.isArray(options.appliedActions) ? options.appliedActions : [];
                const phaseInstructions = phase === 'draft'
                    ? `Pass type: DRAFT.
- Return only the first ${maxActions} high-impact actions that create visible structure fast.
- Prioritize page/canvas size, major containers, and key headings.
- Do not over-plan. Make progress immediately.`
                    : `Pass type: REFINE.
- Improve polish, spacing, visual hierarchy, and details.
- Avoid repeating actions already applied.`;
                return `
You are the CSVLink AI Copilot. Your job is to ACTUALLY BUILD what the user requests by returning concrete JSON actions.
Do not only describe ideas. Return executable actions whenever canvas edits are requested.
You collaborate iteratively and return compact tool actions, not full Fabric JSON.
Return strict JSON only (no markdown, no code fences):
{
  "reply": "short natural-language response",
  "actions": [
    { "type": "action_name", "...": "params" }
  ]
}

Execution mode: ${applyMode}
- If mode is "plan_only", still propose actions, but keep them low risk.
- Prefer small batches (max ${maxActions} actions) and high-value edits first.
- If the request needs no canvas changes, return an empty "actions" array.
- Default to autonomous decisions. Ask a question only when a critical requirement is missing.
- Keep "reply" operational and brief (max 12 words). No narrative explanations.
- If "Objects on current page" is 0 and user asks for design/layout work, include at least 3 creation actions
  (like add_text/add_shape/add_icon/add_table/add_image_url) before any selection-only actions.
${phaseInstructions}

Available action types:
1) { "type": "add_canvas", "count": 1, "width": 1080, "height": 1350 }
2) { "type": "switch_canvas", "index": 1 }
3) { "type": "set_canvas_size", "scope": "current|all", "width": 1080, "height": 1350 }
4) { "type": "set_title", "title": "My Template" }
5) { "type": "add_text", "text": "Inbox", "x": "center|number|percent", "y": "number|percent|top|center|bottom", "fontSize": 56, "fontFamily": "Inter", "color": "#0f172a", "align": "left|center|right", "width": 700, "curve": -100..100 }
6) { "type": "add_shape", "shape": "rect|square|circle|triangle|line|arrow|star", "x": "center|number", "y": "number", "width": 700, "height": 96, "fill": "#ffffff", "stroke": "#cbd5e1", "strokeWidth": 1, "radius": 14, "opacity": 1 }
7) { "type": "add_icon", "name": "inbox", "x": "number|center", "y": "number", "size": 42, "color": "#334155" }
8) { "type": "add_image_url", "url": "https://...", "x": "center|number", "y": "number", "width": 320, "height": 180, "opacity": 1 }
9) { "type": "add_table", "x": "center|number", "y": "number", "rows": 6, "cols": 4, "cellWidth": 160, "cellHeight": 56, "headerRows": 1 }
10) { "type": "duplicate_selection" }
11) { "type": "delete_selection" }
12) { "type": "clear_canvas" }
13) { "type": "select_all" }
14) { "type": "move_selection", "target": "selection|all", "x": "center|number|percent", "y": "number|percent|top|center|bottom", "dx": 24, "dy": -10 }
15) { "type": "resize_selection", "target": "selection|all", "width": 640, "height": 320, "scale": 1.1 }
16) { "type": "style_selection", "target": "selection|all", "fill": "#ffffff", "stroke": "#cbd5e1", "strokeWidth": 1, "opacity": 1, "color": "#0f172a", "fontSize": 16, "fontFamily": "Inter", "align": "left|center|right", "radius": 12, "curve": -100..100 }
17) { "type": "remove_outside_objects" }
18) { "type": "replace_canvas_json", "canvas": { "version": "5.3.0", "objects": [] }, "width": 768, "height": 1024 }

Coordinate rules:
- Numeric x/y are relative to current page top-left.
- "center" means visual center of current page.
- "50%" means 50 percent of current page width/height.

Canvas JSON rules:
- You receive current-page JSON context in the request. Use it for precise edits.
- Prefer standard action types for small changes.
- Use "replace_canvas_json" for full structural rewrites.

Design quality rules:
- Use an 8px spacing rhythm (8/16/24/32/48/64) and clean alignment.
- Build strong hierarchy: one clear headline, supporting subtext, then details.
- Favor subtle strokes (#cbd5e1), readable contrast, and rounded corners (8-18).
- Keep outputs modular: several focused actions, not one giant monolithic change.

Icon source (preferred):
${AI_ICON_BASE}/{icon-name}.svg

Current editor context:
${buildEditorContextSummary()}

Recent conversation:
${includeConversation ? buildConversationSummary() : 'Skipped for draft speed.'}

Already applied actions (do not repeat):
${summarizeAppliedActions(appliedActions)}

User request:
${userPrompt || '(Attachment-only request)'}
`.trim();
            }

            function parseAiJsonResponse(rawText) {
                if (!rawText || typeof rawText !== 'string') return null;
                const trimmed = rawText
                    .replace(/^```json\s*/i, '')
                    .replace(/^```\s*/i, '')
                    .replace(/\s*```$/i, '')
                    .trim();
                const candidates = [trimmed];
                const objectMatch = trimmed.match(/\{[\s\S]*\}/);
                if (objectMatch?.[0] && objectMatch[0] !== trimmed) candidates.push(objectMatch[0]);
                const arrayMatch = trimmed.match(/\[[\s\S]*\]/);
                if (arrayMatch?.[0] && arrayMatch[0] !== trimmed) candidates.push(arrayMatch[0]);

                for (const candidate of candidates) {
                    try {
                        return JSON.parse(candidate);
                    } catch (_) {
                        continue;
                    }
                }
                return null;
            }

            function normalizeAiParsedPayload(parsed, fallbackReply = 'Done.') {
                if (Array.isArray(parsed)) {
                    return { reply: 'Generated action plan.', actions: parsed };
                }
                if (!parsed || typeof parsed !== 'object') {
                    return { reply: fallbackReply, actions: [] };
                }
                let actions = Array.isArray(parsed.actions)
                    ? parsed.actions
                    : Array.isArray(parsed.plan)
                        ? parsed.plan
                        : [];
                if (!actions.length && parsed.action && typeof parsed.action === 'object') {
                    actions = [parsed.action];
                }
                if (!actions.length) {
                    const canvasPayload = parsed.canvas
                        || parsed.canvas_json
                        || parsed.canvasJson
                        || parsed.page?.canvas
                        || (Array.isArray(parsed.objects) ? {
                            version: '5.3.0',
                            background: 'transparent',
                            objects: parsed.objects
                        } : null);
                    if (canvasPayload && typeof canvasPayload === 'object') {
                        actions = [{
                            type: 'replace_canvas_json',
                            canvas: canvasPayload,
                            width: parsed.page?.width ?? parsed.width,
                            height: parsed.page?.height ?? parsed.height
                        }];
                    }
                }
                return {
                    reply: String(parsed.reply || parsed.message || parsed.summary || fallbackReply),
                    actions
                };
            }

            function extractActionsFromPlainText(rawText) {
                if (!rawText || typeof rawText !== 'string') return [];
                const actions = [];
                const lower = rawText.toLowerCase();
                const countWords = {
                    one: 1,
                    two: 2,
                    three: 3,
                    four: 4,
                    five: 5,
                    six: 6,
                    seven: 7,
                    eight: 8
                };
                const parseCountToken = (token) => {
                    if (!token) return null;
                    const direct = parseInt(token, 10);
                    if (Number.isFinite(direct)) return direct;
                    const byWord = countWords[String(token).trim().toLowerCase()];
                    return Number.isFinite(byWord) ? byWord : null;
                };

                const addCanvasMatch = lower.match(/\b(?:add|create|make|generate|build)\s+((?:\d+|one|two|three|four|five|six|seven|eight))\s+(?:new\s+)?(?:canvas(?:es)?|page(?:s)?)\b/);
                if (addCanvasMatch?.[1]) {
                    actions.push({ type: 'add_canvas', count: parseCountToken(addCanvasMatch[1]) || 1 });
                } else if (/\b(?:add|create|make|generate|build)\s+(?:a|one|new)\s+(?:canvas|page)\b/.test(lower)) {
                    actions.push({ type: 'add_canvas', count: 1 });
                } else if (/\b(?:add|create|make|generate|build)\s+(?:new\s+)?(?:canvases|pages)\b/.test(lower)) {
                    const inferredCount = /\b(multiple|several|few)\b/.test(lower) ? 3 : 2;
                    actions.push({ type: 'add_canvas', count: inferredCount });
                } else if (/\b(?:add|create|make|generate|build)\s+(?:new\s+)?(?:canvas|page)\b/.test(lower)) {
                    actions.push({ type: 'add_canvas', count: 1 });
                }

                const switchMatch = lower.match(/\b(?:switch|go|jump|open|move)\s+(?:to\s+)?(?:canvas|page)\s*(\d+)\b/);
                if (switchMatch?.[1]) {
                    actions.push({ type: 'switch_canvas', index: parseInt(switchMatch[1], 10) });
                }

                const sizeMatch = lower.match(/\b(\d{3,5})\s*(?:x|×|by)\s*(\d{3,5})\b/);
                if (sizeMatch?.[1] && sizeMatch?.[2]) {
                    actions.push({
                        type: 'set_canvas_size',
                        scope: /\ball\b/.test(lower) && /\b(?:canvas|canvases|pages)\b/.test(lower) ? 'all' : 'current',
                        width: parseInt(sizeMatch[1], 10),
                        height: parseInt(sizeMatch[2], 10)
                    });
                }

                const titleMatch = rawText.match(/\b(?:title|name)\s+(?:it|template)?\s*(?:to|as)?\s*["“]([^"”]{2,120})["”]/i);
                if (titleMatch?.[1]) {
                    actions.push({ type: 'set_title', title: titleMatch[1].trim() });
                }

                const headingMatch = rawText.match(/\b(?:add|create|make)\s+(?:a\s+)?(?:title|heading|headline)\s*(?:that\s+says|saying|called|named)?\s*["“]([^"”]{2,120})["”]/i);
                if (headingMatch?.[1]) {
                    actions.push({ type: 'add_text', text: headingMatch[1].trim(), x: 'center', y: '18%', align: 'center' });
                }

                if (/\bclear\s+(?:the\s+)?canvas\b/.test(lower)) {
                    actions.push({ type: 'clear_canvas' });
                }
                if (/\bduplicate\b/.test(lower) && /\b(?:selection|selected)\b/.test(lower)) {
                    actions.push({ type: 'duplicate_selection' });
                }
                if (/\b(delete|remove)\b/.test(lower) && /\b(?:selection|selected)\b/.test(lower)) {
                    actions.push({ type: 'delete_selection' });
                }
                if (/\bselect\s+all\b/.test(lower)) {
                    actions.push({ type: 'select_all' });
                }
                if (/\bcleanup\b/.test(lower) && /\boutside\b/.test(lower)) {
                    actions.push({ type: 'remove_outside_objects' });
                }

                return actions;
            }

            function normalizeAiAction(raw) {
                if (!raw || typeof raw !== 'object') return null;
                const next = { ...raw };
                const rawType = String(next.type || next.tool || next.action || '').trim().toLowerCase().replace(/[\s-]+/g, '_');
                if (!rawType) {
                    const canvasPayload = next.canvas
                        || next.canvas_json
                        || next.canvasJson
                        || next.page?.canvas
                        || (Array.isArray(next.objects) ? {
                            version: '5.3.0',
                            background: 'transparent',
                            objects: next.objects
                        } : null);
                    if (canvasPayload && typeof canvasPayload === 'object') {
                        return {
                            ...next,
                            type: 'replace_canvas_json',
                            canvas: canvasPayload,
                            width: next.page?.width ?? next.width,
                            height: next.page?.height ?? next.height
                        };
                    }
                    return null;
                }
                const aliases = {
                    create_canvas: 'add_canvas',
                    create_canvases: 'add_canvas',
                    new_canvas: 'add_canvas',
                    add_page: 'add_canvas',
                    add_pages: 'add_canvas',
                    create_page: 'add_canvas',
                    create_pages: 'add_canvas',
                    new_page: 'add_canvas',
                    new_pages: 'add_canvas',
                    switch_page: 'switch_canvas',
                    go_to_page: 'switch_canvas',
                    goto_page: 'switch_canvas',
                    resize_canvas: 'set_canvas_size',
                    resize_page: 'set_canvas_size',
                    set_page_size: 'set_canvas_size',
                    set_dimensions: 'set_canvas_size',
                    change_dimensions: 'set_canvas_size',
                    set_page_dimensions: 'set_canvas_size',
                    change_page_dimensions: 'set_canvas_size',
                    add_rectangle: 'add_shape',
                    add_rect: 'add_shape',
                    add_circle: 'add_shape',
                    add_triangle: 'add_shape',
                    add_line: 'add_shape',
                    add_star: 'add_shape',
                    add_arrow: 'add_shape',
                    add_heading: 'add_text',
                    add_headline: 'add_text',
                    add_title: 'add_text',
                    set_heading: 'add_text',
                    remove_selection: 'delete_selection',
                    delete_selected: 'delete_selection',
                    remove_selected: 'delete_selection',
                    clear_current_canvas: 'clear_canvas',
                    clear_page: 'clear_canvas',
                    copy_selection: 'duplicate_selection',
                    duplicate_selected: 'duplicate_selection',
                    select_everything: 'select_all',
                    select_all_objects: 'select_all',
                    move_selected: 'move_selection',
                    move_objects: 'move_selection',
                    nudge_selection: 'move_selection',
                    scale_selection: 'resize_selection',
                    resize_selected: 'resize_selection',
                    format_selection: 'style_selection',
                    set_selection_style: 'style_selection',
                    style_selected: 'style_selection',
                    cleanup_outside_objects: 'remove_outside_objects',
                    remove_outside: 'remove_outside_objects',
                    set_canvas_json: 'replace_canvas_json',
                    update_canvas_json: 'replace_canvas_json',
                    edit_canvas_json: 'replace_canvas_json',
                    replace_canvas_json: 'replace_canvas_json',
                    replace_canvas_state: 'replace_canvas_json',
                    replace_page_json: 'replace_canvas_json'
                };
                const type = aliases[rawType] || rawType;
                if (!type) return null;
                if (type === 'add_shape' && !next.shape && rawType.startsWith('add_')) {
                    next.shape = rawType.replace('add_', '');
                }
                if (type === 'add_canvas') {
                    if (!Number.isFinite(parseInt(next.count, 10))) {
                        const countFallback = parseInt(next.pages ?? next.pageCount ?? next.quantity ?? next.number, 10);
                        if (Number.isFinite(countFallback)) next.count = countFallback;
                    }
                    if (!next.width && Number.isFinite(parseFloat(next.w ?? next.pageWidth ?? next.canvasWidth))) {
                        next.width = parseFloat(next.w ?? next.pageWidth ?? next.canvasWidth);
                    }
                    if (!next.height && Number.isFinite(parseFloat(next.h ?? next.pageHeight ?? next.canvasHeight))) {
                        next.height = parseFloat(next.h ?? next.pageHeight ?? next.canvasHeight);
                    }
                }
                if (type === 'switch_canvas' && next.index == null) {
                    const candidate = parseInt(next.page ?? next.pageIndex ?? next.canvas ?? next.canvasIndex, 10);
                    if (Number.isFinite(candidate)) next.index = candidate;
                }
                if (type === 'set_canvas_size') {
                    if (!next.width && Number.isFinite(parseFloat(next.w ?? next.pageWidth ?? next.canvasWidth))) {
                        next.width = parseFloat(next.w ?? next.pageWidth ?? next.canvasWidth);
                    }
                    if (!next.height && Number.isFinite(parseFloat(next.h ?? next.pageHeight ?? next.canvasHeight))) {
                        next.height = parseFloat(next.h ?? next.pageHeight ?? next.canvasHeight);
                    }
                    if (!next.scope) {
                        if (next.all === true || next.applyToAll === true || next.target === 'all') next.scope = 'all';
                        if (next.current === true) next.scope = 'current';
                    }
                }
                if (type === 'add_text') {
                    if (!next.text && typeof next.title === 'string') next.text = next.title;
                    if (!next.text && typeof next.content === 'string') next.text = next.content;
                    if (!next.text && typeof next.value === 'string') next.text = next.value;
                    if (!next.fontSize && Number.isFinite(parseFloat(next.size))) next.fontSize = parseFloat(next.size);
                }
                if (type === 'add_shape') {
                    if (!next.shape && typeof next.kind === 'string') next.shape = next.kind;
                    if (!next.width && Number.isFinite(parseFloat(next.w))) next.width = parseFloat(next.w);
                    if (!next.height && Number.isFinite(parseFloat(next.h))) next.height = parseFloat(next.h);
                }
                if (type === 'add_icon' && !next.name) {
                    const iconName = next.icon ?? next.iconName ?? next.value;
                    if (typeof iconName === 'string' && iconName.trim()) next.name = iconName.trim();
                }
                if (type === 'add_image_url' && !next.url) {
                    const imageUrl = next.src ?? next.imageUrl ?? next.image;
                    if (typeof imageUrl === 'string' && imageUrl.trim()) next.url = imageUrl.trim();
                }
                if (type === 'move_selection') {
                    if (next.dx == null && Number.isFinite(parseFloat(next.deltaX ?? next.offsetX))) {
                        next.dx = parseFloat(next.deltaX ?? next.offsetX);
                    }
                    if (next.dy == null && Number.isFinite(parseFloat(next.deltaY ?? next.offsetY))) {
                        next.dy = parseFloat(next.deltaY ?? next.offsetY);
                    }
                }
                if (type === 'resize_selection') {
                    if (!next.width && Number.isFinite(parseFloat(next.w))) next.width = parseFloat(next.w);
                    if (!next.height && Number.isFinite(parseFloat(next.h))) next.height = parseFloat(next.h);
                }
                if (type === 'replace_canvas_json') {
                    if (!next.canvas || typeof next.canvas !== 'object') {
                        const canvasPayload = next.canvas_json
                            || next.canvasJson
                            || next.page?.canvas
                            || (Array.isArray(next.objects) ? {
                                version: '5.3.0',
                                background: 'transparent',
                                objects: next.objects
                            } : null);
                        if (canvasPayload && typeof canvasPayload === 'object') next.canvas = canvasPayload;
                    }
                    if (!next.width && Number.isFinite(parseFloat(next.page?.width))) {
                        next.width = parseFloat(next.page.width);
                    }
                    if (!next.height && Number.isFinite(parseFloat(next.page?.height))) {
                        next.height = parseFloat(next.page.height);
                    }
                }
                return { ...next, type };
            }

            function getEditableCanvasObjects() {
                return canvas.getObjects().filter(o =>
                    o && o.oid !== 'pageRect' && !o.excludeFromExport && !o.isSnapLine && !o.isCanvasGhost && !o.isArtboard
                );
            }

            function getActionTargetObjects(action = {}) {
                const targetMode = String(action.target || 'selection').toLowerCase();
                if (targetMode === 'all') return getEditableCanvasObjects();
                const active = canvas.getActiveObject();
                if (!active) return [];
                if (active.type === 'activeSelection' && typeof active.getObjects === 'function') {
                    return active.getObjects().filter(Boolean);
                }
                return [active];
            }

            function ensureActionSelectionTarget(action = {}) {
                const targetMode = String(action.target || 'selection').toLowerCase();
                if (targetMode !== 'all') return canvas.getActiveObject();
                const objects = getEditableCanvasObjects();
                if (!objects.length) return null;
                if (objects.length === 1) {
                    canvas.setActiveObject(objects[0]);
                    return objects[0];
                }
                const selection = new fabric.ActiveSelection(objects, { canvas });
                canvas.setActiveObject(selection);
                return selection;
            }

            function buildCanvasSnapshotPart() {
                try {
                    if (!canvas?.lowerCanvasEl || typeof canvas.toDataURL !== 'function') return null;
                    const width = Number(canvas.lowerCanvasEl.width) || 0;
                    const height = Number(canvas.lowerCanvasEl.height) || 0;
                    if (!width || !height) return null;
                    const maxSide = Math.max(width, height);
                    const multiplier = Math.max(0.2, Math.min(1, AI_CANVAS_SNAPSHOT_MAX_SIDE / maxSide));
                    const dataUrl = canvas.toDataURL({
                        format: 'jpeg',
                        quality: AI_CANVAS_SNAPSHOT_QUALITY,
                        multiplier
                    });
                    const [, mimeType, base64Data] = String(dataUrl).match(/^data:(.*?);base64,(.*)$/) || [];
                    if (!mimeType || !base64Data) return null;
                    if (base64Data.length > 1_100_000) return null;
                    return {
                        inline_data: {
                            mime_type: mimeType,
                            data: base64Data
                        }
                    };
                } catch (err) {
                    console.warn('Unable to build AI canvas snapshot.', err);
                    return null;
                }
            }

            function buildCanvasJsonContextPart() {
                try {
                    if (typeof syncCurrentPageStateFromCanvas === 'function') {
                        syncCurrentPageStateFromCanvas();
                    }
                    const page = documentPages[currentPageIndex] || {};
                    const pageWidth = parsePositiveInt(page.width, DEFAULT_PAGE_WIDTH);
                    const pageHeight = parsePositiveInt(page.height, DEFAULT_PAGE_HEIGHT);
                    const canvasState = (typeof sanitizeCanvasStateForEditor === 'function')
                        ? sanitizeCanvasStateForEditor(page.canvas, { pageWidth, pageHeight })
                        : (page.canvas || { version: '5.3.0', background: 'transparent', objects: [] });
                    const basePayload = {
                        page: {
                            index: currentPageIndex + 1,
                            width: pageWidth,
                            height: pageHeight
                        },
                        canvas: canvasState
                    };
                    let serialized = JSON.stringify(basePayload);
                    if (serialized.length > AI_MAX_CANVAS_JSON_CHARS) {
                        const trimmedObjects = Array.isArray(canvasState?.objects)
                            ? canvasState.objects.slice(0, AI_MAX_CANVAS_JSON_OBJECTS)
                            : [];
                        serialized = JSON.stringify({
                            page: basePayload.page,
                            canvas: {
                                ...canvasState,
                                objects: trimmedObjects
                            },
                            note: `Object list truncated to first ${AI_MAX_CANVAS_JSON_OBJECTS} entries.`
                        });
                    }
                    if (serialized.length > AI_MAX_CANVAS_JSON_CHARS) {
                        serialized = `${serialized.slice(0, AI_MAX_CANVAS_JSON_CHARS)}...[truncated]`;
                    }
                    return {
                        text: `Current editable canvas JSON (current page):\n${serialized}`
                    };
                } catch (err) {
                    console.warn('Unable to build AI canvas JSON context.', err);
                    return null;
                }
            }

            function getCurrentPageFrame() {
                const current = documentPages[currentPageIndex] || {};
                const width = parsePositiveInt(pageRect?.width, parsePositiveInt(current.width, DEFAULT_PAGE_WIDTH));
                const height = parsePositiveInt(pageRect?.height, parsePositiveInt(current.height, DEFAULT_PAGE_HEIGHT));
                const left = normalizeNumeric(pageRect?.left, getPageLayoutLeft(currentPageIndex));
                const top = normalizeNumeric(pageRect?.top, 0);
                return {
                    left,
                    top,
                    width,
                    height,
                    centerX: left + width / 2,
                    centerY: top + height / 2
                };
            }

            function promptHasDesignIntent(promptText = '') {
                const lower = String(promptText || '').toLowerCase();
                return /\b(design|designer|redesign|recreate|layout|mockup|hero|landing|poster|flyer|ui|screen|interface|template|style|look|visual|polish|card|section|resume|cv|curriculum|portfolio|document|doc)\b/.test(lower);
            }

            function promptRequestsCanvasMutation(promptText = '') {
                const lower = String(promptText || '').toLowerCase();
                const intent = /\b(add|create|make|build|generate|design|redesign|recreate|change|update|edit|modify|move|resize|style|apply|do|convert|transform)\b/.test(lower);
                const domain = /\b(canvas|page|pages|template|layout|design|ui|screen|element|elements|object|objects|shape|text|icon|image|table|resume|cv|document|doc|portfolio)\b/.test(lower);
                return intent && domain;
            }

            function inferDesignerHeading(promptText = '') {
                const raw = String(promptText || '').trim();
                const quoted = raw.match(/["“]([^"”]{3,90})["”]/);
                if (quoted?.[1]) return clampText(quoted[1], 72);
                const lower = raw.toLowerCase();
                if (/\b(login|sign[\s-]?in|auth)\b/.test(lower)) return 'Welcome Back';
                if (/\b(sign[\s-]?up|register|onboard)\b/.test(lower)) return 'Create Your Account';
                if (/\b(dashboard|analytics|report)\b/.test(lower)) return 'Performance Overview';
                if (/\b(profile|account)\b/.test(lower)) return 'Account Settings';
                if (/\b(ecommerce|product|shop|store)\b/.test(lower)) return 'Featured Products';
                if (/\b(resume|cv|curriculum|portfolio)\b/.test(lower)) return 'Your Name';
                return 'Design Draft';
            }

            function buildDesignerBootstrapActions(promptText = '') {
                if (!promptHasDesignIntent(promptText) && !promptRequestsCanvasMutation(promptText) && !aiAttachment) return [];
                const lower = String(promptText || '').toLowerCase();
                const resetIntent = /\b(from scratch|start over|blank|clean slate|new design)\b/.test(lower);
                const existingObjects = getEditableCanvasObjects().length;
                if (!resetIntent && existingObjects > 2) {
                    return [{
                        type: 'add_text',
                        text: inferDesignerHeading(promptText),
                        x: 'center',
                        y: '10%',
                        width: Math.max(220, Math.round(getCurrentPageFrame().width * 0.78)),
                        align: 'center',
                        color: '#0f172a',
                        fontSize: Math.max(18, Math.round(getCurrentPageFrame().width * 0.03)),
                        fontFamily: 'Inter'
                    }];
                }

                const frame = getCurrentPageFrame();
                const heading = inferDesignerHeading(promptText);
                const headlineY = Math.max(56, Math.round(frame.height * 0.16));
                const panelHeight = Math.max(200, Math.round(frame.height * 0.58));
                const panelWidth = Math.max(260, Math.round(Math.min(frame.width * 0.88, 980)));
                const subtitleY = Math.max(headlineY + 52, Math.round(frame.height * 0.27));

                return [
                    {
                        type: 'add_shape',
                        shape: 'rect',
                        x: 'center',
                        y: 'center',
                        width: panelWidth,
                        height: panelHeight,
                        fill: '#ffffff',
                        stroke: '#dbe2ea',
                        strokeWidth: 1,
                        radius: 18
                    },
                    {
                        type: 'add_text',
                        text: heading,
                        x: 'center',
                        y: headlineY,
                        width: Math.max(220, Math.round(frame.width * 0.82)),
                        align: 'center',
                        color: '#0f172a',
                        fontSize: Math.max(26, Math.round(frame.width * 0.062)),
                        fontFamily: 'Inter'
                    },
                    {
                        type: 'add_text',
                        text: 'Starter layout added. Ask for sections, icons, and style refinements.',
                        x: 'center',
                        y: subtitleY,
                        width: Math.max(220, Math.round(frame.width * 0.75)),
                        align: 'center',
                        color: '#334155',
                        fontSize: Math.max(13, Math.round(frame.width * 0.02)),
                        fontFamily: 'Inter'
                    }
                ];
            }

            function buildNoOpRescueActions(promptText = '') {
                if (!promptRequestsCanvasMutation(promptText) && !promptHasDesignIntent(promptText) && !aiAttachment) return [];
                const existingObjects = getEditableCanvasObjects().length;
                if (!existingObjects) return buildDesignerBootstrapActions(promptText);
                const frame = getCurrentPageFrame();
                return [{
                    type: 'add_text',
                    text: inferDesignerHeading(promptText),
                    x: 'center',
                    y: Math.max(32, Math.round(frame.height * 0.1)),
                    width: Math.max(220, Math.round(frame.width * 0.8)),
                    align: 'center',
                    color: '#0f172a',
                    fontSize: Math.max(18, Math.round(frame.width * 0.03)),
                    fontFamily: 'Inter'
                }];
            }

            function shouldIncludeCanvasSnapshot(promptText = '') {
                const lower = String(promptText || '').toLowerCase();
                const hasObjects = getEditableCanvasObjects().length > 0;
                if (!hasObjects) return false;
                if (aiAttachment?.kind === 'inline') return true;
                return /\b(edit|update|adjust|tweak|modify|improve|refine|align|move|resize|restyle|based on|this canvas|existing)\b/.test(lower);
            }

            function shouldSkipRemoteAiCall(promptText = '', quickActions = []) {
                return false;
            }

            function resolveAxisCoordinate(value, axis, frame, fallback) {
                if (Number.isFinite(value)) {
                    return (axis === 'x' ? frame.left : frame.top) + value;
                }
                if (typeof value !== 'string') return fallback;
                const raw = value.trim().toLowerCase();
                if (!raw) return fallback;

                if (raw.endsWith('%')) {
                    const pct = parseFloat(raw.slice(0, -1));
                    if (Number.isFinite(pct)) {
                        const ratio = Math.max(0, Math.min(100, pct)) / 100;
                        return axis === 'x'
                            ? frame.left + frame.width * ratio
                            : frame.top + frame.height * ratio;
                    }
                }

                if (raw === 'center' || raw === 'middle') return axis === 'x' ? frame.centerX : frame.centerY;
                if (axis === 'x' && raw === 'left') return frame.left + 24;
                if (axis === 'x' && raw === 'right') return frame.left + frame.width - 24;
                if (axis === 'y' && raw === 'top') return frame.top + 24;
                if (axis === 'y' && raw === 'bottom') return frame.top + frame.height - 24;

                const parsed = parseFloat(raw);
                if (Number.isFinite(parsed)) {
                    return (axis === 'x' ? frame.left : frame.top) + parsed;
                }
                return fallback;
            }

            function resolveActionPoint(action = {}) {
                const frame = getCurrentPageFrame();
                const spawn = getDefaultSpawnPoint();
                return {
                    x: resolveAxisCoordinate(action.x, 'x', frame, spawn.x),
                    y: resolveAxisCoordinate(action.y, 'y', frame, spawn.y)
                };
            }

            function applyCommonObjectStyles(obj, action = {}) {
                if (!obj) return;
                const patch = {};
                if (typeof action.fill === 'string') patch.fill = action.fill;
                if (typeof action.color === 'string' && obj.type === 'textbox') patch.fill = action.color;
                if (typeof action.stroke === 'string') patch.stroke = action.stroke;
                if (Number.isFinite(parseFloat(action.strokeWidth))) patch.strokeWidth = Math.max(0, parseFloat(action.strokeWidth));
                if (Number.isFinite(parseFloat(action.opacity))) patch.opacity = Math.max(0, Math.min(1, parseFloat(action.opacity)));
                obj.set(patch);

                if (obj.type === 'textbox') {
                    if (typeof action.text === 'string') obj.set({ text: action.text });
                    if (Number.isFinite(parseFloat(action.fontSize))) obj.set({ fontSize: Math.max(8, parseFloat(action.fontSize)) });
                    if (typeof action.fontFamily === 'string' && action.fontFamily.trim()) {
                        const requestedFamily = action.fontFamily.trim();
                        ensureFontFamilyLoaded(requestedFamily);
                        obj.set({ fontFamily: requestedFamily });
                    }
                    if (typeof action.align === 'string') obj.set({ textAlign: action.align });
                    if (Number.isFinite(parseFloat(action.width))) obj.set({ width: Math.max(24, parseFloat(action.width)) });
                    if (Number.isFinite(parseFloat(action.curve))) {
                        setTextboxCurve(obj, parseFloat(action.curve), { skipRender: true });
                    } else {
                        refreshTextboxCurve(obj, { skipRender: true });
                    }
                }

                if (obj.type === 'rect' && Number.isFinite(parseFloat(action.radius))) {
                    const r = Math.max(0, parseFloat(action.radius));
                    obj.set({ rx: r, ry: r });
                }

                obj.setCoords();
            }

            function moveSelectionFromAction(action = {}) {
                const target = ensureActionSelectionTarget(action);
                if (!target) return 'No selection to move.';

                const deltaX = parseFloat(action.dx);
                const deltaY = parseFloat(action.dy);
                const hasDelta = Number.isFinite(deltaX) || Number.isFinite(deltaY);
                if (hasDelta) {
                    target.set({
                        left: normalizeNumeric(target.left, 0) + (Number.isFinite(deltaX) ? deltaX : 0),
                        top: normalizeNumeric(target.top, 0) + (Number.isFinite(deltaY) ? deltaY : 0)
                    });
                } else {
                    const frame = getCurrentPageFrame();
                    const fallbackX = normalizeNumeric(target.left, frame.centerX);
                    const fallbackY = normalizeNumeric(target.top, frame.centerY);
                    const nextX = resolveAxisCoordinate(action.x, 'x', frame, fallbackX);
                    const nextY = resolveAxisCoordinate(action.y, 'y', frame, fallbackY);
                    if (typeof target.setPositionByOrigin === 'function') {
                        target.setPositionByOrigin(new fabric.Point(nextX, nextY), 'center', 'center');
                    } else {
                        target.set({ left: nextX, top: nextY });
                    }
                }

                target.setCoords();
                canvas.requestRenderAll();
                return 'Moved selection.';
            }

            function resizeSelectionFromAction(action = {}) {
                const target = ensureActionSelectionTarget(action);
                if (!target) return 'No selection to resize.';

                const requestedW = parseFloat(action.width);
                const requestedH = parseFloat(action.height);
                const requestedScale = parseFloat(action.scale);
                let changed = false;

                if (Number.isFinite(requestedScale) && requestedScale > 0) {
                    target.set({
                        scaleX: (target.scaleX || 1) * requestedScale,
                        scaleY: (target.scaleY || 1) * requestedScale
                    });
                    changed = true;
                }

                const currentW = Math.max(1, target.getScaledWidth?.() || target.width || 1);
                const currentH = Math.max(1, target.getScaledHeight?.() || target.height || 1);

                if (Number.isFinite(requestedW) && requestedW > 0) {
                    target.set({ scaleX: (target.scaleX || 1) * (requestedW / currentW) });
                    changed = true;
                }
                if (Number.isFinite(requestedH) && requestedH > 0) {
                    target.set({ scaleY: (target.scaleY || 1) * (requestedH / currentH) });
                    changed = true;
                }

                if (!changed) return 'Skipped resize: no width/height/scale provided.';
                target.setCoords();
                canvas.requestRenderAll();
                return 'Resized selection.';
            }

            function styleSelectionFromAction(action = {}) {
                const objects = getActionTargetObjects(action);
                if (!objects.length) return 'No selection to style.';
                objects.forEach(obj => applyCommonObjectStyles(obj, action));
                canvas.requestRenderAll();
                return `Styled ${objects.length} selected object${objects.length === 1 ? '' : 's'}.`;
            }

            async function addImageFromUrl(url, action = {}) {
                const { x, y } = resolveActionPoint(action);
                return new Promise((resolve, reject) => {
                    fabric.Image.fromURL(url, (img) => {
                        if (!img) {
                            reject(new Error('Image could not be loaded.'));
                            return;
                        }
                        img.set({
                            left: x,
                            top: y,
                            originX: 'center',
                            originY: 'center',
                            name: getUniqueName('image'),
                            pageId: currentCanvasPageId()
                        });

                        const targetW = parseFloat(action.width);
                        const targetH = parseFloat(action.height);
                        if (Number.isFinite(targetW) && Number.isFinite(targetH) && img.width && img.height) {
                            img.set({ scaleX: targetW / img.width, scaleY: targetH / img.height });
                        } else if (Number.isFinite(targetW)) {
                            img.scaleToWidth(Math.max(8, targetW));
                        } else if (Number.isFinite(targetH)) {
                            img.scaleToHeight(Math.max(8, targetH));
                        }

                        applyCommonObjectStyles(img, action);
                        canvas.add(img).setActiveObject(img);
                        resolve(img);
                    }, { crossOrigin: 'anonymous' });
                });
            }

            async function addSvgFromUrl(url, action = {}) {
                const { x, y } = resolveActionPoint(action);
                return new Promise((resolve, reject) => {
                    fabric.loadSVGFromURL(url, (objects, options) => {
                        if (!objects || !objects.length) {
                            reject(new Error('SVG returned no drawable objects.'));
                            return;
                        }
                        const tint = typeof action.color === 'string' ? action.color : null;
                        objects.forEach(obj => {
                            obj.objectCaching = false;
                            if (tint) {
                                if (typeof obj.fill === 'string' && obj.fill !== 'none') obj.set({ fill: tint });
                                if (typeof obj.stroke === 'string' && obj.stroke !== 'none') obj.set({ stroke: tint });
                            }
                        });
                        const group = new fabric.Group(objects, {
                            ...options,
                            left: x,
                            top: y,
                            originX: 'center',
                            originY: 'center',
                            isSvgGroup: true,
                            objectCaching: false,
                            name: getUniqueName('icon'),
                            pageId: currentCanvasPageId()
                        });
                        const targetSize = Math.max(8, parseFloat(action.size) || 96);
                        group.scaleToWidth(targetSize);
                        applyCommonObjectStyles(group, action);
                        canvas.add(group).setActiveObject(group);
                        resolve(group);
                    }, null, { crossOrigin: 'anonymous' });
                });
            }

            function parseActionIndex(value, fallback = 0) {
                const raw = parseInt(value, 10);
                if (!Number.isFinite(raw)) return fallback;
                if (raw >= 1) return raw - 1;
                return raw;
            }

            async function executeAiAction(action) {
                switch (action.type) {
                    case 'add_canvas': {
                        const count = Math.max(1, Math.min(8, parseInt(action.count, 10) || 1));
                        const width = parsePositiveInt(action.width, parsePositiveInt(generalPageSize.width, DEFAULT_PAGE_WIDTH));
                        const height = parsePositiveInt(action.height, parsePositiveInt(generalPageSize.height, DEFAULT_PAGE_HEIGHT));
                        for (let i = 0; i < count; i++) {
                            await addCanvasPage(documentPages.length, { width, height });
                        }
                        return `Added ${count} canvas${count === 1 ? '' : 'es'} (${width}x${height}).`;
                    }
                    case 'switch_canvas': {
                        if (!documentPages.length) return 'No canvases available.';
                        const target = Math.max(0, Math.min(documentPages.length - 1, parseActionIndex(action.index, currentPageIndex)));
                        await switchToCanvasPage(target, { fitView: false });
                        return `Switched to canvas ${target + 1}.`;
                    }
                    case 'set_canvas_size': {
                        const width = parsePositiveInt(action.width, parsePositiveInt(generalPageSize.width, DEFAULT_PAGE_WIDTH));
                        const height = parsePositiveInt(action.height, parsePositiveInt(generalPageSize.height, DEFAULT_PAGE_HEIGHT));
                        const scope = String(action.scope || 'current').toLowerCase();

                        if (scope === 'all') {
                            $('#pageWidth').value = width;
                            $('#pageHeight').value = height;
                            if (typeof setPageDimensions === 'function') {
                                setPageDimensions();
                                if (typeof setPageDimensions.flush === 'function') setPageDimensions.flush();
                            }
                            return `Updated matching canvases to ${width}x${height}.`;
                        }

                        syncCurrentPageStateFromCanvas();
                        const page = documentPages[currentPageIndex];
                        if (!page) return 'No active canvas to resize.';
                        page.width = width;
                        page.height = height;
                        ensurePageRectInCanvasState(page);
                        await switchToCanvasPage(currentPageIndex, { fitView: false, skipSave: true, suppressHistory: true });
                        generalPageSize = getMostCommonPageSize();
                        syncGeneralPageSizeInputs();
                        return `Resized current canvas to ${width}x${height}.`;
                    }
                    case 'set_title': {
                        const title = String(action.title || '').trim();
                        if (!title) return 'Skipped empty title.';
                        $('#titleInput').value = title;
                        return `Set title to "${title}".`;
                    }
                    case 'replace_canvas_json': {
                        syncCurrentPageStateFromCanvas();
                        const page = documentPages[currentPageIndex];
                        if (!page) return 'No active canvas available.';
                        const candidate = action.canvas
                            || action.canvas_json
                            || action.canvasJson
                            || action.page?.canvas
                            || (Array.isArray(action.objects) ? {
                                version: '5.3.0',
                                background: 'transparent',
                                objects: action.objects
                            } : null);
                        if (!candidate || typeof candidate !== 'object') {
                            return 'Skipped invalid canvas JSON payload.';
                        }
                        const width = parsePositiveInt(
                            action.width ?? action.page?.width,
                            parsePositiveInt(page.width, DEFAULT_PAGE_WIDTH)
                        );
                        const height = parsePositiveInt(
                            action.height ?? action.page?.height,
                            parsePositiveInt(page.height, DEFAULT_PAGE_HEIGHT)
                        );
                        const nextCanvas = (typeof sanitizeCanvasStateForEditor === 'function')
                            ? sanitizeCanvasStateForEditor(candidate, { pageWidth: width, pageHeight: height })
                            : candidate;

                        page.width = width;
                        page.height = height;
                        page.canvas = nextCanvas;
                        ensurePageRectInCanvasState(page);
                        await switchToCanvasPage(currentPageIndex, { fitView: false, skipSave: true, suppressHistory: true });
                        const objectCount = Array.isArray(page.canvas?.objects)
                            ? page.canvas.objects.filter(obj => obj && obj.oid !== 'pageRect').length
                            : 0;
                        return `Replaced current canvas JSON (${objectCount} object${objectCount === 1 ? '' : 's'}).`;
                    }
                    case 'add_text': {
                        const { x, y } = resolveActionPoint(action);
                        adders.text(x, y, String(action.text || 'Text'));
                        const obj = canvas.getActiveObject();
                        applyCommonObjectStyles(obj, action);
                        return `Added text "${String(action.text || 'Text').slice(0, 48)}".`;
                    }
                    case 'add_shape': {
                        const shape = String(action.shape || 'rect').toLowerCase();
                        const { x, y } = resolveActionPoint(action);
                        if (shape === 'rect' || shape === 'rectangle') adders.rect({ x, y, asSquare: false });
                        else if (shape === 'square') adders.square(x, y);
                        else if (shape === 'circle') adders.circle(x, y);
                        else if (shape === 'triangle') adders.triangle(x, y);
                        else if (shape === 'line') adders.line(x, y);
                        else if (shape === 'arrow') adders.arrow(x, y);
                        else if (shape === 'star') adders.star(x, y);
                        else return `Unknown shape "${shape}".`;

                        const obj = canvas.getActiveObject();
                        if (obj && Number.isFinite(parseFloat(action.width)) && Number.isFinite(parseFloat(action.height)) && obj.type !== 'line') {
                            const nextW = Math.max(4, parseFloat(action.width));
                            const nextH = Math.max(4, parseFloat(action.height));
                            if (obj.type === 'circle') {
                                obj.set({ radius: Math.max(2, Math.min(nextW, nextH) / 2) });
                            } else {
                                obj.set({ width: nextW, height: nextH });
                            }
                        }
                        applyCommonObjectStyles(obj, action);
                        return `Added ${shape}.`;
                    }
                    case 'add_icon': {
                        const iconName = String(action.name || 'sparkles').toLowerCase().replace(/[^a-z0-9-]/g, '');
                        const iconUrls = [
                            `${AI_ICON_BASE}/${iconName}.svg`,
                            `https://api.iconify.design/lucide/${iconName}.svg`,
                            `https://api.iconify.design/mdi/${iconName}.svg`
                        ];
                        let loaded = false;
                        let lastError = null;
                        for (const iconUrl of iconUrls) {
                            try {
                                await addSvgFromUrl(iconUrl, action);
                                loaded = true;
                                break;
                            } catch (err) {
                                lastError = err;
                            }
                        }
                        if (!loaded) throw (lastError || new Error(`Icon "${iconName}" could not be loaded.`));
                        return `Added icon "${iconName}".`;
                    }
                    case 'add_image_url': {
                        const url = String(action.url || '').trim();
                        if (!url) return 'Skipped missing image URL.';
                        if (/\.svg(\?|$)/i.test(url)) {
                            await addSvgFromUrl(url, action);
                        } else {
                            await addImageFromUrl(url, action);
                        }
                        return 'Added image from URL.';
                    }
                    case 'add_table': {
                        const { x, y } = resolveActionPoint(action);
                        const rows = Math.max(1, parsePositiveInt(action.rows, 4));
                        const cols = Math.max(1, parsePositiveInt(action.cols, 3));
                        const table = createTableObject({
                            x,
                            y,
                            rows,
                            cols,
                            cellWidth: Math.max(30, parsePositiveInt(action.cellWidth, 140)),
                            cellHeight: Math.max(24, parsePositiveInt(action.cellHeight, 52)),
                            headerRows: Math.max(0, Math.min(rows, parseInt(action.headerRows, 10) || 1))
                        });
                        canvas.add(table).setActiveObject(table);
                        return `Added table ${rows}x${cols}.`;
                    }
                    case 'duplicate_selection': {
                        const duplicated = await duplicateSelection();
                        if (!duplicated) return 'Nothing selected to duplicate.';
                        return 'Duplicated selection.';
                    }
                    case 'delete_selection': {
                        const activeObjects = canvas.getActiveObjects();
                        if (!activeObjects.length) return 'No selection to delete.';
                        removeCanvasObjects(activeObjects);
                        return `Deleted ${activeObjects.length} selected object${activeObjects.length === 1 ? '' : 's'}.`;
                    }
                    case 'clear_canvas': {
                        const removable = getEditableCanvasObjects();
                        if (!removable.length) return 'Canvas already empty.';
                        removeCanvasObjects(removable);
                        return `Cleared ${removable.length} object${removable.length === 1 ? '' : 's'} from current canvas.`;
                    }
                    case 'select_all': {
                        const objects = getEditableCanvasObjects();
                        if (!objects.length) return 'No objects available on this canvas.';
                        if (objects.length === 1) {
                            canvas.setActiveObject(objects[0]);
                        } else {
                            canvas.setActiveObject(new fabric.ActiveSelection(objects, { canvas }));
                        }
                        canvas.requestRenderAll();
                        return `Selected ${objects.length} object${objects.length === 1 ? '' : 's'}.`;
                    }
                    case 'move_selection':
                        return moveSelectionFromAction(action);
                    case 'resize_selection':
                        return resizeSelectionFromAction(action);
                    case 'style_selection':
                        return styleSelectionFromAction(action);
                    case 'remove_outside_objects': {
                        if (typeof removeObjectsOutsideAllCanvasPages !== 'function') {
                            return 'Outside-object cleanup is not available.';
                        }
                        const removed = removeObjectsOutsideAllCanvasPages(null, true);
                        return removed ? 'Removed objects fully outside all canvases.' : 'No outside objects were removed.';
                    }
                    default:
                        return `Skipped unsupported action "${action.type}".`;
                }
            }

            function buildAiSafetyPolicy(promptText = '') {
                const lower = String(promptText || '').toLowerCase();
                const allowClear = /\b(clear|wipe|empty|erase|reset)\b[\s\S]{0,48}\b(canvas|page|design|everything|all)\b/.test(lower)
                    || /\b(start over|from scratch|clean slate)\b/.test(lower);
                const allowDeleteSelection = /\b(delete|remove)\b[\s\S]{0,24}\b(selection|selected|object|element|item|layer)\b/.test(lower)
                    || /\b(delete|remove)\b[\s\S]{0,24}\b(all|everything)\b/.test(lower);
                const allowOutsideCleanup = /\b(remove|cleanup|clean)\b[\s\S]{0,24}\b(outside|off[- ]?canvas)\b/.test(lower);
                return {
                    allowClear,
                    allowDeleteSelection,
                    allowOutsideCleanup,
                    allowEmptyResult: allowClear || allowDeleteSelection || allowOutsideCleanup
                };
            }

            function filterAiActionsForSafety(actions, safetyPolicy) {
                const safe = [];
                const blocked = [];
                const policy = safetyPolicy || buildAiSafetyPolicy('');
                (actions || []).forEach(action => {
                    if (!action || typeof action !== 'object') return;
                    const type = String(action.type || '');
                    if (type === 'clear_canvas' && !policy.allowClear) {
                        blocked.push(action);
                        return;
                    }
                    if (type === 'delete_selection' && !policy.allowDeleteSelection) {
                        blocked.push(action);
                        return;
                    }
                    if (type === 'remove_outside_objects' && !policy.allowOutsideCleanup) {
                        blocked.push(action);
                        return;
                    }
                    if (type === 'replace_canvas_json' && !policy.allowClear) {
                        const candidate = action.canvas
                            || action.canvas_json
                            || action.canvasJson
                            || action.page?.canvas;
                        const hasDrawableObjects = Array.isArray(candidate?.objects)
                            && candidate.objects.some(obj =>
                                obj
                                && obj.oid !== 'pageRect'
                                && !obj.excludeFromExport
                                && !obj.isSnapLine
                                && !obj.isCanvasGhost
                            );
                        if (!hasDrawableObjects && getEditableCanvasObjects().length > 0) {
                            blocked.push(action);
                            return;
                        }
                    }
                    safe.push(action);
                });
                return { safe, blocked };
            }

            async function executeAiActions(actions, statusEl, { allowEmptyResult = false } = {}) {
                if (!Array.isArray(actions) || !actions.length) {
                    statusEl.textContent = 'No canvas actions were generated.';
                    return;
                }

                const beforeCount = getEditableCanvasObjects().length;
                const lines = [];
                for (let i = 0; i < actions.length; i++) {
                    const action = actions[i];
                    const label = `${i + 1}/${actions.length} ${action.type}`;
                    statusEl.textContent = `Applying action ${label}...`;
                    try {
                        const result = await executeAiAction(action);
                        lines.push(`${label}: ${result}`);
                    } catch (err) {
                        lines.push(`${label}: Error - ${err.message}`);
                    }
                }

                canvas.requestRenderAll();
                renderLayers();
                refreshCanvasPageControlsDebounced();
                if (typeof scheduleOutsideObjectsCleanup === 'function') scheduleOutsideObjectsCleanup();
                requestSaveState();

                const afterCount = getEditableCanvasObjects().length;
                if (!allowEmptyResult && beforeCount > 0 && afterCount === 0) {
                    if (typeof undo === 'function') {
                        undo();
                        lines.push('Safety rollback: prevented accidental empty canvas.');
                    } else {
                        lines.push('Safety warning: canvas became empty unexpectedly. Use Undo.');
                    }
                }

                statusEl.textContent = lines.join('\n');
            }

            async function requestAiResponseText(
                apiKey,
                parts,
                {
                    enforceJson = true,
                    onProgress = null,
                    timeoutMs = AI_REQUEST_TIMEOUT_MS,
                    responseSchema = AI_JSON_RESPONSE_SCHEMA
                } = {}
            ) {
                const payload = {
                    contents: [{ parts }]
                };

                if (enforceJson) {
                    payload.generationConfig = {
                        temperature: 0.2,
                        responseMimeType: 'application/json'
                    };
                    if (responseSchema && typeof responseSchema === 'object') {
                        payload.generationConfig.responseSchema = responseSchema;
                    }
                } else {
                    payload.generationConfig = { temperature: 0.2 };
                }

                const abortController = new AbortController();
                const timeoutId = setTimeout(() => abortController.abort(), timeoutMs);

                try {
                    if (typeof onProgress === 'function') {
                        onProgress(enforceJson ? 'Sending request' : 'Retrying request');
                    }

                    const response = await fetch(AI_MODEL_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-goog-api-key': apiKey
                        },
                        body: JSON.stringify(payload),
                        signal: abortController.signal
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        const message = errorData.error?.message || 'Unknown error';
                        if (enforceJson && /responsemimetype|responseschema|generationconfig/i.test(String(message))) {
                            return requestAiResponseText(apiKey, parts, { enforceJson: false, onProgress, timeoutMs });
                        }
                        throw new Error(`API Error ${response.status}: ${message}`);
                    }

                    if (typeof onProgress === 'function') onProgress('Reading response');
                    const data = await response.json();
                    return (data?.candidates?.[0]?.content?.parts || [])
                        .map(part => part.text || '')
                        .join('\n')
                        .trim();
                } catch (error) {
                    if (error?.name === 'AbortError') {
                        throw new Error(`AI request timed out after ${Math.round(timeoutMs / 1000)}s. Try a shorter prompt.`);
                    }
                    throw error;
                } finally {
                    clearTimeout(timeoutId);
                }
            }

            function isAiTimeoutError(error) {
                if (!error) return false;
                const message = String(error.message || '');
                return /timed out|timeout|abort/i.test(message) || error.name === 'AbortError';
            }

            function buildAiRepairPrompt(userPrompt, rawResponse) {
                return `
Convert the assistant output below into strict JSON (no markdown):
{
  "reply": "short response",
  "actions": [{ "type": "action_name" }]
}

Allowed action names:
add_canvas, switch_canvas, set_canvas_size, set_title, add_text, add_shape, add_icon, add_image_url, add_table,
duplicate_selection, delete_selection, clear_canvas, select_all, move_selection, resize_selection, style_selection,
remove_outside_objects, replace_canvas_json.

Rules:
- Keep actions small and realistic for the current request.
- If no actionable canvas step exists, return an empty actions array.

Original user request:
${userPrompt || '(Attachment-only request)'}

Assistant output to convert:
${rawResponse}
`.trim();
            }

            async function tryRepairActionsFromText(apiKey, userPrompt, rawResponse, { onProgress = null, timeoutMs = AI_REQUEST_TIMEOUT_MS } = {}) {
                if (!rawResponse) return null;
                try {
                    if (typeof onProgress === 'function') onProgress('Repairing response format');
                    const repairText = await requestAiResponseText(
                        apiKey,
                        [{ text: buildAiRepairPrompt(userPrompt, rawResponse) }],
                        { enforceJson: true, onProgress, timeoutMs }
                    );
                    const repairedParsed = parseAiJsonResponse(repairText);
                    if (!repairedParsed) return null;
                    return normalizeAiParsedPayload(repairedParsed, 'Converted to actions.');
                } catch (err) {
                    console.warn('AI action repair failed:', err);
                    return null;
                }
            }

            function buildGoogleFontsHint(maxItems = 140) {
                const pool = Array.isArray(globalThis.GOOGLE_FONT_FAMILIES)
                    ? globalThis.GOOGLE_FONT_FAMILIES
                    : (Array.isArray(typeof GOOGLE_FONT_FAMILIES !== 'undefined' ? GOOGLE_FONT_FAMILIES : null)
                        ? GOOGLE_FONT_FAMILIES
                        : []);
                if (!pool.length) {
                    return 'All Google Fonts available in the editor are allowed for fontFamily.';
                }
                const sample = pool.slice(0, Math.max(20, maxItems)).join(', ');
                const truncated = pool.length > maxItems ? ', ...' : '';
                return `All Google Fonts are available for fontFamily (${pool.length} families). Use any Google font name exactly. Sample list: ${sample}${truncated}`;
            }

            function getCurrentPageDimensionsForAi() {
                const page = documentPages[currentPageIndex] || {};
                return {
                    width: parsePositiveInt(page.width, DEFAULT_PAGE_WIDTH),
                    height: parsePositiveInt(page.height, DEFAULT_PAGE_HEIGHT)
                };
            }

            function buildCreativeFabricPrompt(userPrompt, { pageWidth, pageHeight } = {}) {
                const width = parsePositiveInt(pageWidth, DEFAULT_PAGE_WIDTH);
                const height = parsePositiveInt(pageHeight, DEFAULT_PAGE_HEIGHT);
                return `
You are a senior UI/visual designer working directly with Fabric.js object JSON.
Return ONLY a JSON array of drawable Fabric.js objects for ONE page.
Do not return markdown, explanations, wrappers, template schemas, or top-level objects.

Canvas size:
- width: ${width}
- height: ${height}

Allowed object types only:
rect, circle, triangle, textbox, image, line, path, group, polygon, polyline, ellipse.

Strict rules:
- Never include pageRect/isArtboard objects.
- Use top-left anchors: "originX":"left", "originY":"top".
- Keep every object fully inside canvas bounds.
- Prefer "textbox" for text. Keep text wrapping using sensible width.
- For textboxes: keep scaleX=1 and scaleY=1, size via width/fontSize.
- If styles is present on text, use an array.
- Never use textBaseline "alphabetical" (use "alphabetic" or omit).
- Do not use clipPath, transformMatrix, filters, scripts, or non-Fabric custom code.
- Use professional layout quality (spacing rhythm, alignment, readable hierarchy).
${buildGoogleFontsHint()}

User request:
${userPrompt || '(Attachment-only request)'}

Return format example:
[
  { "type":"rect","originX":"left","originY":"top","left":0,"top":0,"width":${width},"height":120,"fill":"#0f172a" },
  { "type":"textbox","originX":"left","originY":"top","left":36,"top":34,"width":420,"text":"Invoice","fontSize":42,"fontFamily":"Inter","fill":"#ffffff","scaleX":1,"scaleY":1,"styles":[] }
]
`.trim();
            }

            function shouldReplaceCurrentCanvasForAi(promptText = '', hasAttachment = false) {
                if (hasAttachment) return true;
                const text = String(promptText || '').toLowerCase();
                if (!text.trim()) return false;
                const replaceIntent = /\b(recreate|create|design|redesign|from scratch|start over|new layout|build a|make a)\b/i.test(text);
                const additiveIntent = /\b(add|append|insert|place|include)\b/i.test(text) && !replaceIntent;
                if (replaceIntent) return true;
                if (additiveIntent) return false;
                return true;
            }

            function buildCreativeAiRequestParts(promptText, { pageWidth, pageHeight, retry = false } = {}) {
                const parts = [{ text: buildCreativeFabricPrompt(promptText, { pageWidth, pageHeight }) }];
                if (!aiAttachment) return parts;
                parts.push({ text: `Reference attachment: ${aiAttachment.name}. Recreate/align design to this reference when relevant.` });
                if (aiAttachment.kind === 'inline') {
                    parts.push({
                        inline_data: {
                            mime_type: aiAttachment.mimeType || 'application/octet-stream',
                            data: aiAttachment.inlineData
                        }
                    });
                } else if (aiAttachment.kind === 'text') {
                    const maxChars = retry ? AI_RETRY_TEXT_ATTACHMENT_CHARS : AI_MAX_TEXT_ATTACHMENT_CHARS;
                    const rawText = String(aiAttachment.text || '');
                    const attachmentText = rawText.length > maxChars
                        ? `${rawText.slice(0, maxChars)}\n...[truncated]`
                        : rawText;
                    parts.push({ text: `Attached file text:\n${attachmentText}` });
                }
                return parts;
            }

            function extractCandidateTextFromGeminiChunk(data) {
                const parts = data?.candidates?.[0]?.content?.parts;
                if (!Array.isArray(parts)) return '';
                return parts
                    .map((part) => (typeof part?.text === 'string' ? part.text : ''))
                    .join('');
            }

            function computeStreamTextDelta(nextText, state) {
                const incoming = String(nextText || '');
                if (!incoming) return '';
                if (!state.lastText) {
                    state.lastText = incoming;
                    return incoming;
                }
                if (incoming === state.lastText) return '';
                if (incoming.startsWith(state.lastText)) {
                    const delta = incoming.slice(state.lastText.length);
                    state.lastText = incoming;
                    return delta;
                }
                if (state.lastText.startsWith(incoming)) {
                    state.lastText = incoming;
                    return '';
                }
                let prefixLen = 0;
                const max = Math.min(state.lastText.length, incoming.length);
                while (prefixLen < max && state.lastText[prefixLen] === incoming[prefixLen]) {
                    prefixLen += 1;
                }
                state.lastText = incoming;
                return incoming.slice(prefixLen);
            }

            async function requestAiResponseTextStream(
                apiKey,
                parts,
                {
                    onProgress = null,
                    timeoutMs = AI_CREATIVE_REQUEST_TIMEOUT_MS,
                    onTextChunk = null,
                    temperature = 0.72
                } = {}
            ) {
                const payload = {
                    contents: [{ parts }],
                    generationConfig: {
                        temperature,
                        responseMimeType: 'application/json'
                    }
                };
                const abortController = new AbortController();
                const timeoutId = setTimeout(() => abortController.abort(), timeoutMs);
                const streamState = { lastText: '' };
                let assembledText = '';
                try {
                    if (typeof onProgress === 'function') onProgress('Opening live stream');
                    const response = await fetch(AI_MODEL_STREAM_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-goog-api-key': apiKey
                        },
                        body: JSON.stringify(payload),
                        signal: abortController.signal
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        const message = errorData.error?.message || `HTTP ${response.status}`;
                        throw new Error(`API Error ${response.status}: ${message}`);
                    }

                    if (!response.body || typeof response.body.getReader !== 'function') {
                        throw new Error('Streaming response body is unavailable.');
                    }

                    const reader = response.body.getReader();
                    const decoder = new TextDecoder('utf-8');
                    let sseBuffer = '';

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        sseBuffer += decoder.decode(value, { stream: true });

                        let boundaryMatch = sseBuffer.match(/\r?\n\r?\n/);
                        while (boundaryMatch && Number.isFinite(boundaryMatch.index)) {
                            const boundaryIndex = boundaryMatch.index;
                            const separatorLength = boundaryMatch[0].length || 2;
                            const eventBlock = sseBuffer.slice(0, boundaryIndex);
                            sseBuffer = sseBuffer.slice(boundaryIndex + separatorLength);
                            boundaryMatch = sseBuffer.match(/\r?\n\r?\n/);

                            const lines = eventBlock.split(/\r?\n/);
                            const dataLines = lines
                                .filter((line) => line.startsWith('data:'))
                                .map((line) => line.slice(5).trimStart());
                            if (!dataLines.length) continue;
                            const dataText = dataLines.join('\n').trim();
                            if (!dataText || dataText === '[DONE]') continue;

                            let chunkData = null;
                            try {
                                chunkData = JSON.parse(dataText);
                            } catch (_) {
                                continue;
                            }
                            const candidateText = extractCandidateTextFromGeminiChunk(chunkData);
                            if (!candidateText) continue;
                            const delta = computeStreamTextDelta(candidateText, streamState);
                            if (!delta) continue;
                            assembledText += delta;
                            if (typeof onTextChunk === 'function') onTextChunk(delta, assembledText);
                        }
                    }

                    const finalFlush = decoder.decode();
                    if (finalFlush) {
                        sseBuffer += finalFlush;
                    }
                    if (sseBuffer.trim()) {
                        const lines = sseBuffer.split(/\r?\n/);
                        const dataLines = lines
                            .filter((line) => line.startsWith('data:'))
                            .map((line) => line.slice(5).trimStart());
                        const dataText = dataLines.join('\n').trim();
                        if (dataText && dataText !== '[DONE]') {
                            try {
                                const chunkData = JSON.parse(dataText);
                                const candidateText = extractCandidateTextFromGeminiChunk(chunkData);
                                const delta = computeStreamTextDelta(candidateText, streamState);
                                if (delta) {
                                    assembledText += delta;
                                    if (typeof onTextChunk === 'function') onTextChunk(delta, assembledText);
                                }
                            } catch (_) {
                                // ignore incomplete final event
                            }
                        }
                    }
                    return assembledText;
                } catch (error) {
                    if (error?.name === 'AbortError') {
                        throw new Error(`AI request timed out after ${Math.round(timeoutMs / 1000)}s. Try a shorter prompt.`);
                    }
                    throw error;
                } finally {
                    clearTimeout(timeoutId);
                }
            }

            function createStreamingFabricArrayParser() {
                let text = '';
                let scanIndex = 0;
                let startedArray = false;
                let objectStart = -1;
                let objectDepth = 0;
                let inString = false;
                let escaped = false;
                const parsedObjects = [];

                const push = (chunkText) => {
                    const incoming = String(chunkText || '');
                    if (!incoming) return [];
                    text += incoming;
                    const newObjects = [];

                    for (let i = scanIndex; i < text.length; i++) {
                        const ch = text[i];
                        if (!startedArray) {
                            if (ch === '[') startedArray = true;
                            continue;
                        }

                        if (objectStart < 0) {
                            if (ch === '{') {
                                objectStart = i;
                                objectDepth = 1;
                                inString = false;
                                escaped = false;
                            }
                            continue;
                        }

                        if (escaped) {
                            escaped = false;
                            continue;
                        }

                        if (ch === '\\' && inString) {
                            escaped = true;
                            continue;
                        }

                        if (ch === '"') {
                            inString = !inString;
                            continue;
                        }

                        if (!inString) {
                            if (ch === '{') {
                                objectDepth += 1;
                            } else if (ch === '}') {
                                objectDepth -= 1;
                                if (objectDepth === 0) {
                                    const objectText = text.slice(objectStart, i + 1);
                                    objectStart = -1;
                                    try {
                                        const parsed = JSON.parse(objectText);
                                        if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
                                            parsedObjects.push(parsed);
                                            newObjects.push(parsed);
                                        }
                                    } catch (_) {
                                        // Ignore malformed fragment; final parse fallback handles this.
                                    }
                                }
                            }
                        }
                    }

                    scanIndex = text.length;
                    return newObjects;
                };

                const finalize = () => {
                    const parsed = parseAiJsonResponse(text);
                    if (Array.isArray(parsed)) {
                        const missing = parsed.slice(parsedObjects.length).filter(obj => obj && typeof obj === 'object' && !Array.isArray(obj));
                        if (missing.length) parsedObjects.push(...missing);
                        return missing;
                    }
                    if (parsed && typeof parsed === 'object' && Array.isArray(parsed.objects)) {
                        const missing = parsed.objects
                            .slice(parsedObjects.length)
                            .filter(obj => obj && typeof obj === 'object' && !Array.isArray(obj));
                        if (missing.length) parsedObjects.push(...missing);
                        return missing;
                    }
                    return [];
                };

                return {
                    push,
                    finalize,
                    getText: () => text,
                    getCount: () => parsedObjects.length
                };
            }

            function parseAiFabricObjectsFromText(rawText) {
                const parsed = parseAiJsonResponse(rawText);
                if (Array.isArray(parsed)) {
                    return parsed.filter(obj => obj && typeof obj === 'object' && !Array.isArray(obj));
                }
                if (parsed && typeof parsed === 'object' && Array.isArray(parsed.objects)) {
                    return parsed.objects.filter(obj => obj && typeof obj === 'object' && !Array.isArray(obj));
                }
                return [];
            }

            function enlivenFabricObjectsSafe(rawObjects = []) {
                return new Promise((resolve) => {
                    if (!Array.isArray(rawObjects) || !rawObjects.length) {
                        resolve([]);
                        return;
                    }
                    try {
                        fabric.util.enlivenObjects(rawObjects, (objects) => {
                            resolve(Array.isArray(objects) ? objects.filter(Boolean) : []);
                        }, null);
                    } catch (error) {
                        console.warn('enlivenObjects failed:', error);
                        resolve([]);
                    }
                });
            }

            function clearCurrentPageDrawableObjects() {
                const objects = getEditableCanvasObjects();
                objects.forEach((obj) => canvas.remove(obj));
                canvas.discardActiveObject();
                canvas.requestRenderAll();
            }

            function delayMs(ms) {
                const wait = Math.max(0, parseInt(ms, 10) || 0);
                if (!wait) return Promise.resolve();
                return new Promise((resolve) => setTimeout(resolve, wait));
            }

            function buildTemplateJsonEditPrompt(userPrompt) {
                return `
You are the CSVLink Template JSON Editor.
Return ONLY one valid JSON object: the full modified template.

Critical output rules:
- Output must be JSON only. No markdown, no code fences, no explanation text.
- Keep compatibility with CSVLink template loader.
- Preserve existing data/keys unless user asks to change them.
- You may change page dimensions, add/remove/reorder pages, and edit canvas objects per request.
- Every page must include a pageRect object (oid="pageRect") sized to that page.
- If a reference file/image is attached, follow it closely in the generated layout.
- Use top-left object anchoring consistently: set "originX":"left" and "originY":"top" on drawable objects.
- Treat "left"/"top" as the object top-left corner (not center).
- Allowed drawable Fabric object types: rect, circle, triangle, textbox, image, line, path, group, polygon, polyline, ellipse.
- Do NOT use clipPath, transformMatrix, filters, or custom script-like fields.
- For text, prefer Fabric "textbox" objects (not "text" or "i-text") so wrapping works.
- For textboxes, keep "scaleX"/"scaleY" at 1 and control size via "fontSize" + "width".
- If "styles" is present on text objects, keep it as an array ("[]" when unused).
- Never use textBaseline "alphabetical"; use "alphabetic" or omit textBaseline.
- Ensure professional composition:
  - Keep all text fully inside page bounds (no clipping).
  - Keep readable typography and consistent spacing.
  - Use sensible textbox widths so long lines wrap instead of overflowing.
  - Maintain a clean margin (about 20-28px) from page edges for text content.
${buildGoogleFontsHint()}

Expected top-level shape:
{
  "version": "csvlink-template-v2",
  "page": { "title": "Untitled_Template", "width": 768, "height": 1024 },
  "canvas": { "version": "5.3.0", "background": "transparent", "objects": [] },
  "bindings": [],
  "pages": [],
  "currentPageIndex": 0,
  "data": { "headers": [], "rows": [], "identifierColumn": "" }
}

User instruction:
${userPrompt || '(Attachment-only request)'}
`.trim();
            }

            function getCurrentTemplatePayloadForAi() {
                try {
                    if (typeof buildTemplatePayload === 'function') {
                        const payload = buildTemplatePayload();
                        if (payload && typeof payload === 'object') return payload;
                    }
                } catch (err) {
                    console.warn('Unable to build template payload for AI context.', err);
                }
                const activePage = documentPages[currentPageIndex] || {};
                return {
                    version: 'csvlink-template-v2',
                    page: {
                        title: $('#titleInput')?.value || 'Untitled_Template',
                        width: parsePositiveInt(activePage.width, DEFAULT_PAGE_WIDTH),
                        height: parsePositiveInt(activePage.height, DEFAULT_PAGE_HEIGHT)
                    },
                    canvas: activePage.canvas || { version: '5.3.0', background: 'transparent', objects: [] },
                    bindings: activePage.bindings || [],
                    pages: documentPages || [],
                    currentPageIndex,
                    data: {
                        headers: headers || [],
                        rows: dataRows || [],
                        identifierColumn: identifierColumn || ''
                    }
                };
            }

            function clampStringForAi(value, maxChars = 220) {
                if (value == null) return '';
                const text = typeof value === 'string'
                    ? value
                    : (typeof value === 'number' || typeof value === 'boolean')
                        ? String(value)
                        : (() => {
                            try {
                                return JSON.stringify(value);
                            } catch (_) {
                                return String(value);
                            }
                        })();
                if (text.length <= maxChars) return text;
                return `${text.slice(0, Math.max(12, maxChars - 3))}...`;
            }

            function compactAiScalar(value, maxChars = 120) {
                if (value == null) return '';
                if (typeof value === 'number' && Number.isFinite(value)) return value;
                if (typeof value === 'boolean') return value;
                return clampStringForAi(value, maxChars);
            }

            function roundFinite(value, digits = 2) {
                const num = Number(value);
                if (!Number.isFinite(num)) return null;
                const factor = Math.pow(10, digits);
                return Math.round(num * factor) / factor;
            }

            function compactCanvasObjectForAi(obj, options = {}) {
                if (!obj || typeof obj !== 'object') return null;
                const depth = parseInt(options.depth, 10) || 0;
                const maxDepth = Math.max(1, parseInt(options.maxDepth, 10) || 2);
                const maxTextChars = Math.max(60, parsePositiveInt(options.maxTextChars, 220));
                const maxSrcChars = Math.max(80, parsePositiveInt(options.maxSrcChars, 260));
                const maxChildObjects = Math.max(2, parsePositiveInt(options.maxChildObjects, 8));

                const compacted = {};
                const type = clampStringForAi(obj.type || 'object', 28);
                compacted.type = type;
                if (obj.oid != null) compacted.oid = clampStringForAi(obj.oid, 80);
                if (obj.name != null) compacted.name = clampStringForAi(obj.name, 80);

                const numericKeys = [
                    'left', 'top', 'width', 'height', 'scaleX', 'scaleY', 'angle', 'opacity',
                    'strokeWidth', 'fontSize', 'lineHeight', 'charSpacing', 'rx', 'ry', 'radius'
                ];
                numericKeys.forEach((key) => {
                    const rounded = roundFinite(obj[key], 2);
                    if (rounded !== null) compacted[key] = rounded;
                });

                const stringKeys = [
                    'fill', 'stroke', 'fontFamily', 'fontWeight', 'fontStyle', 'textAlign', 'textBaseline',
                    'originX', 'originY', 'strokeDashArray', 'globalCompositeOperation'
                ];
                stringKeys.forEach((key) => {
                    if (typeof obj[key] === 'string' && obj[key].trim()) {
                        const limit = key === 'fontFamily' ? 90 : 50;
                        compacted[key] = clampStringForAi(obj[key], limit);
                    }
                });

                if (typeof obj.visible === 'boolean') compacted.visible = obj.visible;
                if (typeof obj.selectable === 'boolean') compacted.selectable = obj.selectable;

                if (typeof obj.text === 'string') {
                    compacted.text = clampStringForAi(obj.text, maxTextChars);
                }
                if (typeof obj.src === 'string') {
                    compacted.src = clampStringForAi(obj.src, maxSrcChars);
                }
                if (Array.isArray(obj.styles) || (obj.styles && typeof obj.styles === 'object')) {
                    compacted.styles = [];
                }

                if (Array.isArray(obj.points) && obj.points.length) {
                    const pointLimit = Math.min(10, obj.points.length);
                    compacted.points = obj.points.slice(0, pointLimit).map((point) => ({
                        x: roundFinite(point?.x, 1) ?? 0,
                        y: roundFinite(point?.y, 1) ?? 0
                    }));
                    if (obj.points.length > pointLimit) {
                        compacted.__pointsTruncated = obj.points.length - pointLimit;
                    }
                }

                if (Array.isArray(obj.path) && obj.path.length) {
                    const pathLimit = Math.min(8, obj.path.length);
                    compacted.path = obj.path.slice(0, pathLimit).map((segment) =>
                        Array.isArray(segment) ? segment.slice(0, 5) : segment
                    );
                    if (obj.path.length > pathLimit) {
                        compacted.__pathTruncated = obj.path.length - pathLimit;
                    }
                }

                if (Array.isArray(obj.objects) && obj.objects.length && depth < maxDepth) {
                    const childLimit = Math.min(maxChildObjects, obj.objects.length);
                    compacted.objects = obj.objects
                        .slice(0, childLimit)
                        .map((child) => compactCanvasObjectForAi(child, {
                            ...options,
                            depth: depth + 1,
                            maxChildObjects: Math.max(2, Math.floor(maxChildObjects * 0.75))
                        }))
                        .filter(Boolean);
                    if (obj.objects.length > childLimit) {
                        compacted.__objectsTruncated = obj.objects.length - childLimit;
                    }
                }

                if (obj.clipPath && typeof obj.clipPath === 'object' && depth < maxDepth) {
                    const compactClip = compactCanvasObjectForAi(obj.clipPath, {
                        ...options,
                        depth: depth + 1,
                        maxChildObjects: Math.max(2, Math.floor(maxChildObjects * 0.6))
                    });
                    if (compactClip) compacted.clipPath = compactClip;
                }

                return compacted;
            }

            function compactCanvasForAi(canvasPayload, options = {}) {
                const source = canvasPayload && typeof canvasPayload === 'object' ? canvasPayload : {};
                const sourceObjects = Array.isArray(source.objects) ? source.objects : [];
                const maxObjectsPerPage = Math.max(12, parsePositiveInt(options.maxObjectsPerPage, AI_MAX_TEMPLATE_OBJECTS_PER_PAGE));
                const includedObjects = sourceObjects
                    .slice(0, maxObjectsPerPage)
                    .map((obj) => compactCanvasObjectForAi(obj, options))
                    .filter(Boolean);
                const compacted = {
                    version: clampStringForAi(source.version || '5.3.0', 16),
                    background: typeof source.background === 'string' ? clampStringForAi(source.background, 40) : 'transparent',
                    objects: includedObjects
                };
                if (sourceObjects.length > includedObjects.length) {
                    compacted.__truncatedObjects = sourceObjects.length - includedObjects.length;
                }
                if (sourceObjects.length) compacted.__objectCount = sourceObjects.length;
                return compacted;
            }

            function compactBindingsForAi(bindings, options = {}) {
                if (!Array.isArray(bindings) || !bindings.length) return [];
                const maxBindings = Math.max(8, parsePositiveInt(options.maxBindings, 80));
                return bindings
                    .slice(0, maxBindings)
                    .map((binding) => {
                        if (Array.isArray(binding)) {
                            return [
                                clampStringForAi(binding[0], 100),
                                clampStringForAi(binding[1], 180)
                            ];
                        }
                        if (binding && typeof binding === 'object') {
                            const compacted = {};
                            const keys = ['oid', 'column', 'property', 'path', 'source', 'target', 'type', 'key'];
                            keys.forEach((key) => {
                                if (binding[key] != null) {
                                    compacted[key] = compactAiScalar(binding[key], 140);
                                }
                            });
                            return Object.keys(compacted).length ? compacted : null;
                        }
                        return clampStringForAi(binding, 180);
                    })
                    .filter(Boolean);
            }

            function compactDataRowsForAi(rows, headers, options = {}) {
                if (!Array.isArray(rows) || !rows.length) return [];
                const maxRows = Math.max(0, parseInt(options.maxRows, 10) || 0);
                if (maxRows <= 0) return [];
                const maxCols = Math.max(1, parsePositiveInt(options.maxCols, 12));
                const maxCellChars = Math.max(24, parsePositiveInt(options.maxCellChars, 80));
                return rows.slice(0, maxRows).map((row) => {
                    if (Array.isArray(row)) {
                        return row
                            .slice(0, maxCols)
                            .map((cell) => compactAiScalar(cell, maxCellChars));
                    }
                    if (row && typeof row === 'object') {
                        const keys = Array.isArray(headers) && headers.length
                            ? headers.slice(0, maxCols)
                            : Object.keys(row).slice(0, maxCols);
                        const compacted = {};
                        keys.forEach((key) => {
                            compacted[key] = compactAiScalar(row[key], maxCellChars);
                        });
                        return compacted;
                    }
                    return compactAiScalar(row, maxCellChars);
                });
            }

            function compactTemplatePayloadForAi(templatePayload, options = {}) {
                const source = templatePayload && typeof templatePayload === 'object' ? templatePayload : {};
                const fallbackPageWidth = parsePositiveInt(source?.page?.width, DEFAULT_PAGE_WIDTH);
                const fallbackPageHeight = parsePositiveInt(source?.page?.height, DEFAULT_PAGE_HEIGHT);
                const sourcePages = Array.isArray(source.pages) && source.pages.length
                    ? source.pages
                    : [{
                        width: fallbackPageWidth,
                        height: fallbackPageHeight,
                        canvas: source.canvas || { version: '5.3.0', background: 'transparent', objects: [] },
                        bindings: source.bindings || []
                    }];
                const totalPages = sourcePages.length;
                const maxPages = Math.max(1, parsePositiveInt(options.maxPages, AI_MAX_TEMPLATE_PAGES_CONTEXT));
                const limitedPages = sourcePages.slice(0, maxPages);
                const currentPage = parseInt(source.currentPageIndex, 10);
                const currentPageIndex = Number.isFinite(currentPage) ? Math.max(0, currentPage) : 0;

                const pages = limitedPages.map((page, idx) => {
                    const width = parsePositiveInt(page?.width, fallbackPageWidth);
                    const height = parsePositiveInt(page?.height, fallbackPageHeight);
                    const canvasPayload = page?.canvas && typeof page.canvas === 'object'
                        ? page.canvas
                        : (idx === currentPageIndex ? source.canvas : null);
                    const canvasCompact = compactCanvasForAi(canvasPayload, options);
                    const pageBindings = compactBindingsForAi(page?.bindings, options);
                    const compactedPage = { width, height, canvas: canvasCompact, bindings: pageBindings };
                    if (page?.name != null) compactedPage.name = clampStringForAi(page.name, 80);
                    if (page?.title != null) compactedPage.title = clampStringForAi(page.title, 80);
                    if (pageBindings.length < (Array.isArray(page?.bindings) ? page.bindings.length : 0)) {
                        compactedPage.__truncatedBindings = (page.bindings.length - pageBindings.length);
                    }
                    return compactedPage;
                });

                const maxHeaders = Math.max(8, parsePositiveInt(options.maxHeaders, 48));
                const headerValues = Array.isArray(source?.data?.headers) ? source.data.headers : [];
                const headersCompact = headerValues
                    .slice(0, maxHeaders)
                    .map((header) => clampStringForAi(header, 120));
                const rowsCompact = compactDataRowsForAi(source?.data?.rows, headersCompact, options);

                const payload = {
                    version: clampStringForAi(source.version || 'csvlink-template-v2', 48),
                    page: {
                        title: clampStringForAi(source?.page?.title || 'Untitled_Template', 120),
                        width: parsePositiveInt(source?.page?.width, fallbackPageWidth),
                        height: parsePositiveInt(source?.page?.height, fallbackPageHeight)
                    },
                    currentPageIndex: Math.min(currentPageIndex, Math.max(0, pages.length - 1)),
                    pages,
                    data: {
                        headers: headersCompact,
                        rows: rowsCompact,
                        identifierColumn: clampStringForAi(source?.data?.identifierColumn || '', 120)
                    }
                };

                if (source.canvas && typeof source.canvas === 'object') {
                    payload.canvas = compactCanvasForAi(source.canvas, options);
                }
                const rootBindings = compactBindingsForAi(source.bindings, options);
                if (rootBindings.length) payload.bindings = rootBindings;

                payload.__meta = {
                    totalPages,
                    includedPages: pages.length,
                    truncatedPages: Math.max(0, totalPages - pages.length),
                    contextMode: options.tight ? 'tight' : 'standard'
                };
                if (headerValues.length > headersCompact.length) {
                    payload.__meta.truncatedHeaders = headerValues.length - headersCompact.length;
                }
                if (Array.isArray(source?.data?.rows) && source.data.rows.length > rowsCompact.length) {
                    payload.__meta.truncatedRows = source.data.rows.length - rowsCompact.length;
                }
                return payload;
            }

            function buildTemplateContextForAi(templatePayload, options = {}) {
                const tight = options.tight === true;
                const maxChars = Math.max(12000, parsePositiveInt(options.maxChars, AI_MAX_TEMPLATE_CONTEXT_CHARS));
                let config = {
                    tight,
                    maxPages: tight ? Math.min(4, AI_MAX_TEMPLATE_PAGES_CONTEXT) : AI_MAX_TEMPLATE_PAGES_CONTEXT,
                    maxObjectsPerPage: tight ? Math.max(24, Math.floor(AI_MAX_TEMPLATE_OBJECTS_PER_PAGE * 0.45)) : AI_MAX_TEMPLATE_OBJECTS_PER_PAGE,
                    maxBindings: tight ? 30 : 80,
                    maxHeaders: tight ? 20 : 48,
                    maxRows: tight ? 1 : 2,
                    maxCols: tight ? 8 : 12,
                    maxCellChars: tight ? 60 : 84,
                    maxTextChars: tight ? 120 : 220,
                    maxSrcChars: tight ? 140 : 280,
                    maxChildObjects: tight ? 4 : 8,
                    maxDepth: tight ? 1 : 2
                };

                let compactPayload = null;
                let jsonText = '';
                for (let attempt = 0; attempt < 6; attempt++) {
                    compactPayload = compactTemplatePayloadForAi(templatePayload, config);
                    jsonText = JSON.stringify(compactPayload);
                    if (jsonText.length <= maxChars) {
                        return {
                            jsonText,
                            charCount: jsonText.length,
                            config,
                            summary: compactPayload.__meta || {}
                        };
                    }
                    config = {
                        ...config,
                        maxPages: Math.max(1, Math.floor(config.maxPages * 0.75)),
                        maxObjectsPerPage: Math.max(12, Math.floor(config.maxObjectsPerPage * 0.68)),
                        maxBindings: Math.max(8, Math.floor(config.maxBindings * 0.65)),
                        maxHeaders: Math.max(8, Math.floor(config.maxHeaders * 0.75)),
                        maxRows: attempt >= 1 ? 0 : Math.max(0, config.maxRows - 1),
                        maxCols: Math.max(4, Math.floor(config.maxCols * 0.75)),
                        maxCellChars: Math.max(30, Math.floor(config.maxCellChars * 0.85)),
                        maxTextChars: Math.max(70, Math.floor(config.maxTextChars * 0.82)),
                        maxSrcChars: Math.max(90, Math.floor(config.maxSrcChars * 0.78)),
                        maxChildObjects: Math.max(2, Math.floor(config.maxChildObjects * 0.75)),
                        maxDepth: attempt >= 2 ? 1 : config.maxDepth
                    };
                }

                const source = templatePayload && typeof templatePayload === 'object' ? templatePayload : {};
                const summaryPages = (Array.isArray(source.pages) ? source.pages : [])
                    .slice(0, 6)
                    .map((page, idx) => ({
                        index: idx,
                        width: parsePositiveInt(page?.width, DEFAULT_PAGE_WIDTH),
                        height: parsePositiveInt(page?.height, DEFAULT_PAGE_HEIGHT),
                        objectCount: Array.isArray(page?.canvas?.objects) ? page.canvas.objects.length : 0
                    }));
                const fallback = {
                    version: clampStringForAi(source.version || 'csvlink-template-v2', 48),
                    page: {
                        title: clampStringForAi(source?.page?.title || 'Untitled_Template', 120),
                        width: parsePositiveInt(source?.page?.width, DEFAULT_PAGE_WIDTH),
                        height: parsePositiveInt(source?.page?.height, DEFAULT_PAGE_HEIGHT)
                    },
                    currentPageIndex: Math.max(0, parseInt(source.currentPageIndex, 10) || 0),
                    data: {
                        headers: Array.isArray(source?.data?.headers)
                            ? source.data.headers.slice(0, 16).map((header) => clampStringForAi(header, 100))
                            : [],
                        rows: [],
                        identifierColumn: clampStringForAi(source?.data?.identifierColumn || '', 100)
                    },
                    pageSummaries: summaryPages,
                    __meta: {
                        contextMode: 'fallback',
                        note: 'Template context trimmed to page summaries due payload size.'
                    }
                };
                const fallbackText = JSON.stringify(fallback);
                return {
                    jsonText: fallbackText,
                    charCount: fallbackText.length,
                    config,
                    summary: fallback.__meta || {}
                };
            }

            function buildTemplateEditorRequestParts(promptText, contextPacket, { retry = false } = {}) {
                const parts = [
                    { text: buildTemplateJsonEditPrompt(promptText) },
                    {
                        text: `Current template JSON context (${contextPacket?.charCount || 0} chars):\n${contextPacket?.jsonText || '{}'}`
                    }
                ];

                if (!aiAttachment) return parts;
                parts.push({ text: `Attached reference file: ${aiAttachment.name}` });
                if (aiAttachment.kind === 'inline') {
                    parts.push({
                        inline_data: {
                            mime_type: aiAttachment.mimeType || 'application/octet-stream',
                            data: aiAttachment.inlineData
                        }
                    });
                    return parts;
                }
                if (aiAttachment.kind === 'text') {
                    const maxChars = retry ? AI_RETRY_TEXT_ATTACHMENT_CHARS : AI_MAX_TEXT_ATTACHMENT_CHARS;
                    const rawText = String(aiAttachment.text || '');
                    const attachmentText = rawText.length > maxChars
                        ? `${rawText.slice(0, maxChars)}\n...[truncated]`
                        : rawText;
                    parts.push({ text: `Attached file text:\n${attachmentText}` });
                }
                return parts;
            }

            function normalizeAiTemplatePayload(raw) {
                if (!raw || typeof raw !== 'object') return null;
                if (raw.template && typeof raw.template === 'object') return raw.template;
                if (raw.result && typeof raw.result === 'object') return raw.result;
                if (raw.output && typeof raw.output === 'object') return raw.output;
                if (raw.pages || raw.canvas || raw.page) return raw;
                return null;
            }

            function toFiniteNumber(value, fallback = 0) {
                const num = parseFloat(value);
                return Number.isFinite(num) ? num : fallback;
            }

            function clampFiniteNumber(value, minValue, maxValue, fallback = minValue) {
                const safeMin = Number.isFinite(minValue) ? minValue : fallback;
                const safeMax = Number.isFinite(maxValue) ? maxValue : fallback;
                if (safeMax < safeMin) return safeMin;
                const num = toFiniteNumber(value, fallback);
                return Math.min(safeMax, Math.max(safeMin, num));
            }

            function sanitizeSafeString(value, maxChars = 120, fallback = '') {
                if (value == null) return fallback;
                const text = String(value).replace(/\u0000/g, '').trim();
                if (!text) return fallback;
                if (text.length <= maxChars) return text;
                return text.slice(0, maxChars);
            }

            function sanitizeSafeColor(value, fallback = '#000000') {
                if (typeof value !== 'string') return fallback;
                const text = value.trim();
                if (!text || text.length > 90) return fallback;
                const lower = text.toLowerCase();
                if (lower.includes('javascript:') || lower.includes('url(') || lower.includes('<') || lower.includes('>')) {
                    return fallback;
                }
                if (/^#([0-9a-f]{3,8})$/i.test(text)) return text;
                if (/^rgba?\(\s*[-\d.,%\s]+\)$/i.test(text)) return text;
                if (/^hsla?\(\s*[-\d.,%\s]+\)$/i.test(text)) return text;
                if (/^[a-z]{3,24}$/i.test(text)) return text;
                if (lower === 'transparent' || lower === 'currentcolor' || lower === 'none') {
                    return lower === 'none' ? 'transparent' : text;
                }
                return fallback;
            }

            function sanitizeSafeImageSrc(value) {
                if (typeof value !== 'string') return '';
                const src = value.trim();
                if (!src || src.length > AI_STRICT_MAX_IMAGE_SRC_CHARS) return '';
                if (/^https?:\/\//i.test(src)) return src;
                if (/^data:image\//i.test(src)) return src;
                if (/^blob:/i.test(src)) return src;
                return '';
            }

            function sanitizeSafeFontFamily(value) {
                const fallback = 'Arial';
                const requested = sanitizeSafeString(value, 90, '');
                if (!requested) return fallback;
                const normalized = requested.replace(/^["']+|["']+$/g, '').trim();
                if (!normalized) return fallback;

                if (typeof GOOGLE_FONT_FAMILY_MAP !== 'undefined' && GOOGLE_FONT_FAMILY_MAP instanceof Map) {
                    const mapped = GOOGLE_FONT_FAMILY_MAP.get(normalized.toLowerCase());
                    if (mapped) return mapped;
                }

                if (typeof FONT_LIST !== 'undefined' && Array.isArray(FONT_LIST)) {
                    const found = FONT_LIST.find((name) => String(name).toLowerCase() === normalized.toLowerCase());
                    if (found) return found;
                }

                return normalized;
            }

            function sanitizeSafeStrokeDashArray(rawDash) {
                if (!Array.isArray(rawDash)) return undefined;
                const dash = rawDash
                    .map((item) => clampFiniteNumber(item, 0, 400, 0))
                    .filter((item) => Number.isFinite(item) && item >= 0)
                    .slice(0, 12);
                return dash.length ? dash : undefined;
            }

            function sanitizeSafePath(rawPath) {
                if (!rawPath) return null;
                if (typeof rawPath === 'string') {
                    const text = rawPath.trim();
                    if (!text || text.length > 6000 || text.includes('<')) return null;
                    return text;
                }
                if (!Array.isArray(rawPath)) return null;
                const segments = rawPath.slice(0, AI_STRICT_MAX_PATH_SEGMENTS);
                const nextSegments = [];
                for (let i = 0; i < segments.length; i++) {
                    const segment = segments[i];
                    if (!Array.isArray(segment) || !segment.length) continue;
                    const cmd = sanitizeSafeString(segment[0], 2, '');
                    if (!cmd) continue;
                    const args = segment
                        .slice(1, 10)
                        .map((value) => clampFiniteNumber(value, -20000, 20000, 0));
                    nextSegments.push([cmd, ...args]);
                }
                return nextSegments.length ? nextSegments : null;
            }

            function sanitizeSafePoints(rawPoints, { pageWidth, pageHeight }) {
                if (!Array.isArray(rawPoints)) return [];
                return rawPoints
                    .slice(0, 220)
                    .map((point) => {
                        if (!point || typeof point !== 'object') return null;
                        const x = clampFiniteNumber(point.x, -pageWidth, pageWidth * 2, 0);
                        const y = clampFiniteNumber(point.y, -pageHeight, pageHeight * 2, 0);
                        return { x, y };
                    })
                    .filter(Boolean);
            }

            function estimateStrictObjectSize(obj, { pageWidth, pageHeight }) {
                if (!obj || typeof obj !== 'object') return { width: 1, height: 1 };
                const type = String(obj.type || '').toLowerCase();
                if (type === 'circle') {
                    const radius = Math.max(1, toFiniteNumber(obj.radius, 24));
                    return { width: radius * 2, height: radius * 2 };
                }
                if (type === 'textbox') {
                    const width = Math.max(40, toFiniteNumber(obj.width, Math.min(280, pageWidth)));
                    const fontSize = Math.max(8, toFiniteNumber(obj.fontSize, 24));
                    const lineHeight = Math.max(0.9, toFiniteNumber(obj.lineHeight, 1.16));
                    const lines = Math.max(1, String(obj.text || '').split('\n').length);
                    const height = Math.max(fontSize * lineHeight * lines + 12, fontSize + 10);
                    return { width, height };
                }
                if (type === 'line') {
                    const width = Math.abs(toFiniteNumber(obj.x2, 120) - toFiniteNumber(obj.x1, 0));
                    const height = Math.abs(toFiniteNumber(obj.y2, 0) - toFiniteNumber(obj.y1, 0));
                    return { width: Math.max(2, width), height: Math.max(2, height) };
                }
                const width = Math.max(1, toFiniteNumber(obj.width, 120));
                const height = Math.max(1, toFiniteNumber(obj.height, 80));
                return { width, height };
            }

            function clampStrictObjectToPage(obj, { pageWidth, pageHeight }) {
                if (!obj || typeof obj !== 'object') return obj;
                const size = estimateStrictObjectSize(obj, { pageWidth, pageHeight });
                const objectWidth = Math.max(1, Math.min(pageWidth, size.width));
                const objectHeight = Math.max(1, Math.min(pageHeight, size.height));
                const maxLeft = Math.max(0, pageWidth - objectWidth);
                const maxTop = Math.max(0, pageHeight - objectHeight);
                obj.left = clampFiniteNumber(obj.left, 0, maxLeft, obj.left);
                obj.top = clampFiniteNumber(obj.top, 0, maxTop, obj.top);

                if (obj.type === 'textbox') {
                    const availableWidth = Math.max(80, pageWidth - obj.left - 8);
                    obj.width = clampFiniteNumber(obj.width, 80, availableWidth, Math.min(availableWidth, obj.width));
                }

                return obj;
            }

            function sanitizeAiFabricObjectStrict(rawObject, context, report) {
                if (!rawObject || typeof rawObject !== 'object') {
                    report.droppedObjects += 1;
                    return null;
                }

                const depth = parseInt(context.depth, 10) || 0;
                if (depth > AI_STRICT_MAX_OBJECT_DEPTH) {
                    report.droppedObjects += 1;
                    return null;
                }

                let type = sanitizeSafeString(rawObject.type || '', 24, '').toLowerCase();
                if (type === 'text' || type === 'i-text') type = 'textbox';
                if (rawObject.oid === 'pageRect' || rawObject.isArtboard) {
                    report.droppedObjects += 1;
                    return null;
                }
                if (!AI_STRICT_ALLOWED_TYPES.has(type)) {
                    report.droppedObjects += 1;
                    return null;
                }

                const pageWidth = parsePositiveInt(context.pageWidth, DEFAULT_PAGE_WIDTH);
                const pageHeight = parsePositiveInt(context.pageHeight, DEFAULT_PAGE_HEIGHT);

                const out = {
                    type,
                    originX: 'left',
                    originY: 'top',
                    left: clampFiniteNumber(rawObject.left, 0, pageWidth, 0),
                    top: clampFiniteNumber(rawObject.top, 0, pageHeight, 0),
                    angle: clampFiniteNumber(rawObject.angle, -360, 360, 0),
                    opacity: clampFiniteNumber(rawObject.opacity, 0, 1, 1)
                };

                const oid = sanitizeSafeString(rawObject.oid, 90, '');
                if (oid) out.oid = oid;
                const name = sanitizeSafeString(rawObject.name, 90, '');
                if (name) out.name = name;
                if (typeof rawObject.locked === 'boolean') out.locked = rawObject.locked;
                if (typeof rawObject.selectable === 'boolean') out.selectable = rawObject.selectable;
                if (typeof rawObject.evented === 'boolean') out.evented = rawObject.evented;

                if (type === 'textbox') {
                    const maxTextWidth = Math.max(80, pageWidth - 16);
                    out.text = sanitizeSafeString(rawObject.text ?? '', AI_STRICT_MAX_TEXT_LENGTH, '');
                    out.width = clampFiniteNumber(rawObject.width, 80, maxTextWidth, Math.min(360, maxTextWidth));
                    out.fontSize = clampFiniteNumber(rawObject.fontSize, 8, 180, 24);
                    out.fontFamily = sanitizeSafeFontFamily(rawObject.fontFamily);
                    out.fill = sanitizeSafeColor(rawObject.fill, '#111827');
                    out.stroke = sanitizeSafeColor(rawObject.stroke, '');
                    out.strokeWidth = out.stroke ? clampFiniteNumber(rawObject.strokeWidth, 0, 16, 0) : 0;
                    out.textAlign = AI_STRICT_ALLOWED_TEXT_ALIGNS.has(String(rawObject.textAlign || '').toLowerCase())
                        ? String(rawObject.textAlign).toLowerCase()
                        : 'left';
                    out.lineHeight = clampFiniteNumber(rawObject.lineHeight, 0.9, 2.4, 1.16);
                    out.charSpacing = clampFiniteNumber(rawObject.charSpacing, -250, 2400, 0);
                    out.styles = Array.isArray(rawObject.styles) ? rawObject.styles : [];
                    out.scaleX = 1;
                    out.scaleY = 1;
                    out.minWidth = clampFiniteNumber(rawObject.minWidth, 20, out.width, 20);
                    out.padding = 0;
                    out.splitByGrapheme = !!rawObject.splitByGrapheme;
                    const baseline = String(rawObject.textBaseline || '').toLowerCase();
                    if (['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom'].includes(baseline)) {
                        out.textBaseline = baseline;
                    }
                    if (rawObject.fontWeight != null) out.fontWeight = sanitizeSafeString(rawObject.fontWeight, 20, '');
                    if (rawObject.fontStyle != null) out.fontStyle = sanitizeSafeString(rawObject.fontStyle, 20, '');
                    if (rawObject.curveAmount != null) {
                        out.curveAmount = clampFiniteNumber(rawObject.curveAmount, -100, 100, 0);
                    }
                } else if (type === 'rect' || type === 'triangle') {
                    out.width = clampFiniteNumber(rawObject.width, 6, pageWidth, 180);
                    out.height = clampFiniteNumber(rawObject.height, 6, pageHeight, 120);
                    out.fill = sanitizeSafeColor(rawObject.fill, '#cbd5e1');
                    out.stroke = sanitizeSafeColor(rawObject.stroke, '');
                    out.strokeWidth = out.stroke ? clampFiniteNumber(rawObject.strokeWidth, 0, 18, 0) : 0;
                    if (type === 'rect') {
                        out.rx = clampFiniteNumber(rawObject.rx ?? rawObject.radius, 0, out.width / 2, 0);
                        out.ry = clampFiniteNumber(rawObject.ry ?? rawObject.radius, 0, out.height / 2, out.rx);
                    }
                } else if (type === 'ellipse') {
                    out.rx = clampFiniteNumber(rawObject.rx, 3, pageWidth / 2, 48);
                    out.ry = clampFiniteNumber(rawObject.ry, 3, pageHeight / 2, 30);
                    out.fill = sanitizeSafeColor(rawObject.fill, '#cbd5e1');
                    out.stroke = sanitizeSafeColor(rawObject.stroke, '');
                    out.strokeWidth = out.stroke ? clampFiniteNumber(rawObject.strokeWidth, 0, 18, 0) : 0;
                    out.width = out.rx * 2;
                    out.height = out.ry * 2;
                } else if (type === 'circle') {
                    out.radius = clampFiniteNumber(rawObject.radius ?? (toFiniteNumber(rawObject.width, 80) / 2), 4, Math.min(pageWidth, pageHeight) / 2, 40);
                    out.fill = sanitizeSafeColor(rawObject.fill, '#cbd5e1');
                    out.stroke = sanitizeSafeColor(rawObject.stroke, '');
                    out.strokeWidth = out.stroke ? clampFiniteNumber(rawObject.strokeWidth, 0, 18, 0) : 0;
                    out.width = out.radius * 2;
                    out.height = out.radius * 2;
                } else if (type === 'line') {
                    const lineWidth = clampFiniteNumber(
                        rawObject.width ?? Math.abs(toFiniteNumber(rawObject.x2, 120) - toFiniteNumber(rawObject.x1, 0)),
                        8,
                        pageWidth,
                        180
                    );
                    const lineHeight = clampFiniteNumber(
                        rawObject.height ?? Math.abs(toFiniteNumber(rawObject.y2, 0) - toFiniteNumber(rawObject.y1, 0)),
                        0,
                        pageHeight,
                        0
                    );
                    out.x1 = 0;
                    out.y1 = 0;
                    out.x2 = lineWidth;
                    out.y2 = lineHeight;
                    out.stroke = sanitizeSafeColor(rawObject.stroke || rawObject.fill, '#334155');
                    out.strokeWidth = clampFiniteNumber(rawObject.strokeWidth, 1, 18, 2);
                    out.fill = 'transparent';
                    out.width = lineWidth;
                    out.height = Math.max(1, lineHeight);
                    const lineCap = sanitizeSafeString(rawObject.strokeLineCap, 16, 'round').toLowerCase();
                    out.strokeLineCap = ['butt', 'round', 'square'].includes(lineCap) ? lineCap : 'round';
                } else if (type === 'path') {
                    const safePath = sanitizeSafePath(rawObject.path);
                    if (!safePath) {
                        report.droppedObjects += 1;
                        return null;
                    }
                    out.path = safePath;
                    out.fill = sanitizeSafeColor(rawObject.fill, 'transparent');
                    out.stroke = sanitizeSafeColor(rawObject.stroke, '#334155');
                    out.strokeWidth = clampFiniteNumber(rawObject.strokeWidth, 0, 18, out.stroke === 'transparent' ? 0 : 2);
                    out.width = clampFiniteNumber(rawObject.width, 8, pageWidth, 180);
                    out.height = clampFiniteNumber(rawObject.height, 8, pageHeight, 80);
                    out.objectCaching = false;
                } else if (type === 'polygon' || type === 'polyline') {
                    const safePoints = sanitizeSafePoints(rawObject.points, { pageWidth, pageHeight });
                    if (safePoints.length < 2) {
                        report.droppedObjects += 1;
                        return null;
                    }
                    out.points = safePoints;
                    out.fill = type === 'polyline' ? 'transparent' : sanitizeSafeColor(rawObject.fill, '#cbd5e1');
                    out.stroke = sanitizeSafeColor(rawObject.stroke, '#334155');
                    out.strokeWidth = clampFiniteNumber(rawObject.strokeWidth, 0, 18, 2);
                    out.width = clampFiniteNumber(rawObject.width, 8, pageWidth, 180);
                    out.height = clampFiniteNumber(rawObject.height, 8, pageHeight, 100);
                } else if (type === 'image') {
                    const src = sanitizeSafeImageSrc(rawObject.src || rawObject._src || rawObject.imageSrc);
                    if (!src) {
                        report.droppedObjects += 1;
                        return null;
                    }
                    out.src = src;
                    out.width = clampFiniteNumber(rawObject.width, 16, pageWidth, Math.min(260, pageWidth));
                    out.height = clampFiniteNumber(rawObject.height, 16, pageHeight, Math.min(220, pageHeight));
                    out.crossOrigin = sanitizeSafeString(rawObject.crossOrigin, 22, 'anonymous') || 'anonymous';
                } else if (type === 'group') {
                    const rawChildren = Array.isArray(rawObject.objects) ? rawObject.objects : [];
                    const limitedChildren = rawChildren.slice(0, AI_STRICT_MAX_GROUP_CHILDREN);
                    const childObjects = limitedChildren
                        .map((child) => sanitizeAiFabricObjectStrict(child, { ...context, depth: depth + 1 }, report))
                        .filter(Boolean);
                    if (!childObjects.length) {
                        report.droppedObjects += 1;
                        return null;
                    }
                    out.objects = childObjects;
                    out.objectCaching = false;
                    out.subTargetCheck = false;
                    out.width = clampFiniteNumber(rawObject.width, 10, pageWidth, 220);
                    out.height = clampFiniteNumber(rawObject.height, 10, pageHeight, 160);
                    if (rawChildren.length > limitedChildren.length) {
                        report.truncatedObjects += rawChildren.length - limitedChildren.length;
                    }
                }

                const dash = sanitizeSafeStrokeDashArray(rawObject.strokeDashArray);
                if (dash) out.strokeDashArray = dash;

                if (out.fill === undefined) out.fill = 'transparent';
                if (out.stroke === undefined) out.stroke = '';
                if (!Number.isFinite(out.strokeWidth)) out.strokeWidth = out.stroke ? 1 : 0;

                if (typeof out.shadow === 'object') delete out.shadow;
                if (out.clipPath) delete out.clipPath;
                if (out.transformMatrix) delete out.transformMatrix;
                if (out.filters) delete out.filters;

                clampStrictObjectToPage(out, { pageWidth, pageHeight });
                report.keptObjects += 1;
                return out;
            }

            function sanitizeAiCanvasStateStrict(rawCanvas, { pageWidth, pageHeight }) {
                const sourceCanvas = rawCanvas && typeof rawCanvas === 'object' ? rawCanvas : {};
                const sourceObjects = Array.isArray(sourceCanvas.objects) ? sourceCanvas.objects : [];
                const limitedObjects = sourceObjects.slice(0, AI_STRICT_MAX_OBJECTS_PER_PAGE);
                const report = {
                    sourceObjects: sourceObjects.length,
                    keptObjects: 0,
                    droppedObjects: 0,
                    truncatedObjects: Math.max(0, sourceObjects.length - limitedObjects.length)
                };
                report.droppedObjects += report.truncatedObjects;

                const usedOids = new Set(['pageRect']);
                const objects = limitedObjects
                    .map((rawObject, index) => {
                        const safeObject = sanitizeAiFabricObjectStrict(rawObject, { pageWidth, pageHeight, depth: 0 }, report);
                        if (!safeObject) return null;
                        const baseOid = sanitizeSafeString(safeObject.oid, 90, '') || `ai_obj_${index + 1}`;
                        let nextOid = baseOid;
                        let seq = 2;
                        while (usedOids.has(nextOid)) {
                            nextOid = `${baseOid}_${seq}`;
                            seq += 1;
                        }
                        usedOids.add(nextOid);
                        safeObject.oid = nextOid;
                        return safeObject;
                    })
                    .filter(Boolean);

                const pageRectPayload = typeof createPageRectPayload === 'function'
                    ? createPageRectPayload(pageWidth, pageHeight)
                    : {
                        type: 'rect',
                        oid: 'pageRect',
                        isArtboard: true,
                        left: 0,
                        top: 0,
                        width: pageWidth,
                        height: pageHeight,
                        fill: '#fff',
                        stroke: '#d1d5db',
                        strokeWidth: 1,
                        originX: 'left',
                        originY: 'top',
                        selectable: false,
                        evented: false
                    };

                const canvasState = {
                    version: '5.3.0',
                    background: 'transparent',
                    objects: [pageRectPayload, ...objects]
                };

                return { canvasState, report };
            }

            function sanitizeAiDataCell(value) {
                if (value == null) return '';
                if (typeof value === 'number' && Number.isFinite(value)) return value;
                if (typeof value === 'boolean') return value;
                if (typeof value === 'string') return value.length > 1800 ? value.slice(0, 1800) : value;
                try {
                    const text = JSON.stringify(value);
                    return text.length > 1800 ? text.slice(0, 1800) : text;
                } catch (_) {
                    return String(value).slice(0, 1800);
                }
            }

            function sanitizeAiTemplatePayloadStrict(templatePayload) {
                const source = templatePayload && typeof templatePayload === 'object' ? templatePayload : {};
                const sourcePages = Array.isArray(source.pages) && source.pages.length
                    ? source.pages
                    : [{
                        width: source?.page?.width ?? DEFAULT_PAGE_WIDTH,
                        height: source?.page?.height ?? DEFAULT_PAGE_HEIGHT,
                        canvas: source.canvas || { version: '5.3.0', background: 'transparent', objects: [] },
                        bindings: source.bindings || [],
                        title: source?.page?.title || 'Page 1'
                    }];
                const rootBindings = Array.isArray(source.bindings) ? source.bindings : [];
                const limitedPages = sourcePages.slice(0, AI_STRICT_MAX_PAGES);
                const report = {
                    sourcePages: sourcePages.length,
                    keptPages: limitedPages.length,
                    truncatedPages: Math.max(0, sourcePages.length - limitedPages.length),
                    sourceObjects: 0,
                    keptObjects: 0,
                    droppedObjects: 0,
                    truncatedObjects: 0,
                    truncatedRows: 0
                };

                const pages = limitedPages.map((rawPage, index) => {
                    const width = parsePositiveInt(rawPage?.width ?? source?.page?.width, DEFAULT_PAGE_WIDTH);
                    const height = parsePositiveInt(rawPage?.height ?? source?.page?.height, DEFAULT_PAGE_HEIGHT);
                    const title = sanitizeSafeString(rawPage?.title, 120, `Page ${index + 1}`) || `Page ${index + 1}`;
                    const { canvasState, report: canvasReport } = sanitizeAiCanvasStateStrict(rawPage?.canvas, { pageWidth: width, pageHeight: height });
                    report.sourceObjects += canvasReport.sourceObjects;
                    report.keptObjects += canvasReport.keptObjects;
                    report.droppedObjects += canvasReport.droppedObjects;
                    report.truncatedObjects += canvasReport.truncatedObjects;

                    const finalCanvas = (typeof sanitizeCanvasStateForEditor === 'function')
                        ? sanitizeCanvasStateForEditor(canvasState, { pageWidth: width, pageHeight: height })
                        : canvasState;
                    const rawBindings = Array.isArray(rawPage?.bindings) ? rawPage.bindings : (index === 0 ? rootBindings : []);
                    const pageBindings = typeof sanitizeBindingsEntries === 'function'
                        ? sanitizeBindingsEntries(rawBindings)
                        : [];

                    return {
                        id: sanitizeSafeString(rawPage?.id, 80, '') || (typeof createUid === 'function' ? createUid('page') : `page_${index + 1}`),
                        title,
                        width,
                        height,
                        canvas: finalCanvas,
                        bindings: pageBindings
                    };
                });

                const selectedIndex = Math.max(
                    0,
                    Math.min(
                        pages.length - 1,
                        parseInt(source.currentPageIndex, 10) || 0
                    )
                );
                const activePage = pages[selectedIndex] || pages[0] || {
                    title: 'Page 1',
                    width: DEFAULT_PAGE_WIDTH,
                    height: DEFAULT_PAGE_HEIGHT,
                    canvas: {
                        version: '5.3.0',
                        background: 'transparent',
                        objects: [
                            typeof createPageRectPayload === 'function'
                                ? createPageRectPayload(DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT)
                                : {
                                    type: 'rect',
                                    oid: 'pageRect',
                                    isArtboard: true,
                                    left: 0,
                                    top: 0,
                                    width: DEFAULT_PAGE_WIDTH,
                                    height: DEFAULT_PAGE_HEIGHT,
                                    fill: '#fff',
                                    stroke: '#d1d5db',
                                    strokeWidth: 1,
                                    originX: 'left',
                                    originY: 'top'
                                }
                        ]
                    },
                    bindings: []
                };

                const rawHeaders = Array.isArray(source?.data?.headers) ? source.data.headers : [];
                const headers = rawHeaders
                    .slice(0, AI_STRICT_MAX_HEADERS)
                    .map((header) => sanitizeSafeString(header, 120, ''))
                    .filter(Boolean);
                const rawRows = Array.isArray(source?.data?.rows) ? source.data.rows : [];
                const rows = rawRows
                    .slice(0, AI_STRICT_MAX_ROWS)
                    .map((row) => {
                        if (Array.isArray(row)) {
                            const next = {};
                            headers.forEach((header, idx) => {
                                next[header] = sanitizeAiDataCell(row[idx]);
                            });
                            return next;
                        }
                        if (row && typeof row === 'object') {
                            const keys = headers.length ? headers : Object.keys(row).slice(0, AI_STRICT_MAX_HEADERS);
                            const next = {};
                            keys.forEach((key) => {
                                next[key] = sanitizeAiDataCell(row[key]);
                            });
                            return next;
                        }
                        return null;
                    })
                    .filter(Boolean);
                report.truncatedRows = Math.max(0, rawRows.length - rows.length);

                let identifier = sanitizeSafeString(source?.data?.identifierColumn, 120, '');
                if (identifier && headers.length && !headers.includes(identifier)) identifier = '';

                return {
                    payload: {
                        version: 'csvlink-template-v2',
                        page: {
                            title: sanitizeSafeString(source?.page?.title, 140, activePage.title) || activePage.title,
                            width: activePage.width,
                            height: activePage.height
                        },
                        canvas: activePage.canvas,
                        bindings: activePage.bindings,
                        pages,
                        currentPageIndex: selectedIndex,
                        data: {
                            headers,
                            rows,
                            identifierColumn: identifier
                        }
                    },
                    report
                };
            }

            function isTextLikeCanvasObject(obj) {
                const type = String(obj?.type || '').toLowerCase();
                return type === 'text' || type === 'i-text' || type === 'textbox';
            }

            function clampNumber(value, minValue, maxValue) {
                const safeMin = Number.isFinite(minValue) ? minValue : value;
                const safeMax = Number.isFinite(maxValue) ? maxValue : value;
                return Math.min(safeMax, Math.max(safeMin, value));
            }

            function translateCanvasObject(obj, dx = 0, dy = 0) {
                if (!obj) return false;
                if (!Number.isFinite(dx) || !Number.isFinite(dy)) return false;
                if (Math.abs(dx) < 0.01 && Math.abs(dy) < 0.01) return false;
                obj.set({
                    left: normalizeNumeric(obj.left, 0) + dx,
                    top: normalizeNumeric(obj.top, 0) + dy
                });
                if (typeof obj.setCoords === 'function') obj.setCoords();
                return true;
            }

            function fitTextObjectWithinFrame(obj, frame, margin = 22) {
                if (!obj || !isTextLikeCanvasObject(obj)) return false;
                let changed = false;
                const maxWidth = Math.max(120, frame.width - margin * 2);
                const maxHeight = Math.max(80, frame.height - margin * 2);
                if (obj.type === 'textbox') {
                    const currentWidth = parseFloat(obj.width);
                    const nextWidth = Number.isFinite(currentWidth)
                        ? Math.min(maxWidth, Math.max(120, currentWidth))
                        : maxWidth;
                    if (!Number.isFinite(currentWidth) || Math.abs(nextWidth - currentWidth) > 0.5) {
                        obj.set({ width: nextWidth });
                        changed = true;
                    }
                }

                for (let i = 0; i < 24; i++) {
                    if (typeof obj.setCoords === 'function') obj.setCoords();
                    const bounds = obj.getBoundingRect(true, true);
                    if (!bounds) break;
                    const tooWide = bounds.width > maxWidth + 0.5;
                    const tooTall = bounds.height > maxHeight + 0.5;
                    if (!tooWide && !tooTall) break;
                    const currentFontSize = parseFloat(obj.fontSize);
                    if (!Number.isFinite(currentFontSize) || currentFontSize <= 10) break;
                    obj.set({ fontSize: Math.max(10, currentFontSize - 1) });
                    changed = true;
                }

                if (typeof obj.setCoords === 'function') obj.setCoords();
                const finalBounds = obj.getBoundingRect(true, true);
                if (
                    finalBounds
                    && obj.type !== 'textbox'
                    && finalBounds.width > maxWidth + 1
                    && Number.isFinite(finalBounds.width)
                    && finalBounds.width > 0
                ) {
                    const factor = Math.max(0.65, maxWidth / finalBounds.width);
                    if (factor < 0.999) {
                        obj.set({
                            scaleX: normalizeNumeric(obj.scaleX, 1) * factor,
                            scaleY: normalizeNumeric(obj.scaleY, 1) * factor
                        });
                        changed = true;
                    }
                }

                if (changed && typeof obj.setCoords === 'function') obj.setCoords();
                return changed;
            }

            function keepObjectInsideFrame(obj, frame, { marginX = 0, marginY = 0 } = {}) {
                if (!obj) return false;
                if (typeof obj.setCoords === 'function') obj.setCoords();
                const bounds = obj.getBoundingRect(true, true);
                if (!bounds) return false;

                const minLeft = frame.left + marginX;
                const minTop = frame.top + marginY;
                const maxLeft = Math.max(minLeft, frame.left + frame.width - marginX - bounds.width);
                const maxTop = Math.max(minTop, frame.top + frame.height - marginY - bounds.height);
                const targetLeft = clampNumber(bounds.left, minLeft, maxLeft);
                const targetTop = clampNumber(bounds.top, minTop, maxTop);
                const dx = targetLeft - bounds.left;
                const dy = targetTop - bounds.top;
                return translateCanvasObject(obj, dx, dy);
            }

            function polishCurrentPageLayoutForProfessionalOutput() {
                const frame = getCurrentPageFrame();
                const objects = getEditableCanvasObjects();
                let changed = false;
                objects.forEach(obj => {
                    if (!obj) return;
                    const textLike = isTextLikeCanvasObject(obj);
                    if (textLike) {
                        if (fitTextObjectWithinFrame(obj, frame, 22)) changed = true;
                    }
                    if (keepObjectInsideFrame(obj, frame, { marginX: textLike ? 20 : 0, marginY: textLike ? 16 : 0 })) {
                        changed = true;
                    }
                });
                if (changed) canvas.requestRenderAll();
                return changed;
            }

            async function runProfessionalLayoutPass({ onProgress = null } = {}) {
                if (!Array.isArray(documentPages) || !documentPages.length) return 0;
                const returnIndex = currentPageIndex;
                let changedPages = 0;
                for (let i = 0; i < documentPages.length; i++) {
                    if (typeof onProgress === 'function') onProgress(`Polishing page ${i + 1}/${documentPages.length}`);
                    if (i !== currentPageIndex) {
                        await switchToCanvasPage(i, { fitView: false, skipSave: true, suppressHistory: true });
                    }
                    if (polishCurrentPageLayoutForProfessionalOutput()) changedPages += 1;
                    syncCurrentPageStateFromCanvas();
                }
                if (currentPageIndex !== returnIndex) {
                    await switchToCanvasPage(returnIndex, { fitView: true, skipSave: true, suppressHistory: true });
                }
                return changedPages;
            }

            async function tryRepairTemplateFromText(
                apiKey,
                userPrompt,
                rawResponse,
                {
                    onProgress = null,
                    timeoutMs = Math.min(AI_TEMPLATE_REQUEST_TIMEOUT_MS, 40000)
                } = {}
            ) {
                if (!rawResponse) return null;
                const repairPrompt = `
Convert the assistant output below into strict JSON ONLY for a CSVLink template.
Return one JSON object and nothing else.

User request:
${userPrompt || '(Attachment-only request)'}

Assistant output:
${rawResponse}
`.trim();
                try {
                    if (typeof onProgress === 'function') onProgress('Repairing template JSON');
                    const repairedText = await requestAiResponseText(
                        apiKey,
                        [{ text: repairPrompt }],
                        { enforceJson: true, onProgress, timeoutMs, responseSchema: null }
                    );
                    const repairedParsed = parseAiJsonResponse(repairedText);
                    return normalizeAiTemplatePayload(repairedParsed);
                } catch (err) {
                    console.warn('Template JSON repair failed:', err);
                    return null;
                }
            }

            async function callAiTemplateEditor(apiKey, promptText, { onProgress = null } = {}) {
                const currentTemplate = getCurrentTemplatePayloadForAi();
                if (typeof onProgress === 'function') onProgress('Preparing template context');
                const primaryContext = buildTemplateContextForAi(currentTemplate, {
                    tight: false,
                    maxChars: AI_MAX_TEMPLATE_CONTEXT_CHARS
                });
                const retryContext = buildTemplateContextForAi(currentTemplate, {
                    tight: true,
                    maxChars: Math.max(16000, Math.floor(AI_MAX_TEMPLATE_CONTEXT_CHARS * 0.7))
                });
                const hasInlineAttachment = aiAttachment?.kind === 'inline';
                const primaryTimeoutMs = hasInlineAttachment || primaryContext.charCount > 30000
                    ? Math.min(AI_TEMPLATE_REQUEST_TIMEOUT_MS, 70000)
                    : Math.min(AI_TEMPLATE_REQUEST_TIMEOUT_MS, 52000);
                const retryTimeoutMs = Math.min(AI_TEMPLATE_RETRY_TIMEOUT_MS, hasInlineAttachment ? 50000 : 42000);

                let responseText = '';
                try {
                    const parts = buildTemplateEditorRequestParts(promptText, primaryContext, { retry: false });
                    if (typeof onProgress === 'function') {
                        onProgress(`Sending template request (${Math.round(primaryContext.charCount / 1000)}k chars context)`);
                    }
                    responseText = await requestAiResponseText(
                        apiKey,
                        parts,
                        {
                            enforceJson: true,
                            onProgress,
                            timeoutMs: primaryTimeoutMs,
                            responseSchema: null
                        }
                    );
                } catch (error) {
                    if (!isAiTimeoutError(error)) throw error;
                    const parts = buildTemplateEditorRequestParts(promptText, retryContext, { retry: true });
                    if (typeof onProgress === 'function') {
                        onProgress(`Timed out, retrying with smaller context (${Math.round(retryContext.charCount / 1000)}k chars)`);
                    }
                    responseText = await requestAiResponseText(
                        apiKey,
                        parts,
                        {
                            enforceJson: true,
                            onProgress,
                            timeoutMs: retryTimeoutMs,
                            responseSchema: null
                        }
                    );
                }

                if (!responseText) throw new Error('No template JSON returned by AI.');

                if (typeof onProgress === 'function') onProgress('Parsing template JSON');
                const parsed = parseAiJsonResponse(responseText);
                let templatePayload = normalizeAiTemplatePayload(parsed);
                if (!templatePayload) {
                    templatePayload = await tryRepairTemplateFromText(apiKey, promptText, responseText, {
                        onProgress,
                        timeoutMs: Math.min(AI_TEMPLATE_RETRY_TIMEOUT_MS, 35000)
                    });
                }
                if (!templatePayload) {
                    throw new Error('AI response was not valid template JSON.');
                }
                return templatePayload;
            }

            async function applyAiTemplatePayload(templatePayload) {
                if (!templatePayload || typeof templatePayload !== 'object') {
                    throw new Error('Invalid AI template payload.');
                }
                const payload = JSON.parse(JSON.stringify(templatePayload));
                const strictResult = sanitizeAiTemplatePayloadStrict(payload);
                const safePayload = strictResult?.payload && typeof strictResult.payload === 'object'
                    ? strictResult.payload
                    : payload;
                const strictReport = strictResult?.report || null;
                if (safePayload.page?.title) {
                    $('#titleInput').value = String(safePayload.page.title);
                }
                if (safePayload.data && typeof safePayload.data === 'object') {
                    headers = Array.isArray(safePayload.data.headers) ? safePayload.data.headers : [];
                    dataRows = Array.isArray(safePayload.data.rows) ? safePayload.data.rows : [];
                    identifierColumn = String(safePayload.data.identifierColumn || '');
                }
                const selectedIndex = Number.isFinite(parseInt(safePayload.currentPageIndex, 10))
                    ? parseInt(safePayload.currentPageIndex, 10)
                    : currentPageIndex;
                await setDocumentPagesFromTemplate(safePayload, { fitView: true, selectedIndex });
                const polishedPages = await runProfessionalLayoutPass();
                bindings = new Map(documentPages[currentPageIndex]?.bindings || safePayload.bindings || []);
                historyStack = [];
                historyIndex = -1;
                lastHistorySig = null;
                requestSaveState();
                renderLayers();
                refreshCanvasPageControlsDebounced();
                return {
                    pageCount: Array.isArray(documentPages) ? documentPages.length : 1,
                    polishedPages,
                    strictReport
                };
            }

            async function callAiCreativeFabricDesigner(
                apiKey,
                promptText,
                {
                    onProgress = null,
                    onRawObject = null
                } = {}
            ) {
                const { width: pageWidth, height: pageHeight } = getCurrentPageDimensionsForAi();
                const primaryParts = buildCreativeAiRequestParts(promptText, { pageWidth, pageHeight, retry: false });
                const retryParts = buildCreativeAiRequestParts(promptText, { pageWidth, pageHeight, retry: true });
                const parser = createStreamingFabricArrayParser();
                let emittedCount = 0;
                let streamError = null;

                const emitRawObjects = (objects = [], source = 'stream') => {
                    if (!Array.isArray(objects) || !objects.length) return;
                    objects.forEach((obj) => {
                        if (!obj || typeof obj !== 'object' || Array.isArray(obj)) return;
                        emittedCount += 1;
                        if (typeof onRawObject === 'function') {
                            try {
                                onRawObject(obj, { index: emittedCount, source });
                            } catch (err) {
                                console.warn('Live AI object callback failed:', err);
                            }
                        }
                    });
                };

                try {
                    if (typeof onProgress === 'function') onProgress('Streaming design objects');
                    const streamText = await requestAiResponseTextStream(
                        apiKey,
                        primaryParts,
                        {
                            onProgress,
                            timeoutMs: AI_CREATIVE_REQUEST_TIMEOUT_MS,
                            onTextChunk: (deltaText) => {
                                const nextObjects = parser.push(deltaText);
                                emitRawObjects(nextObjects, 'stream');
                            },
                            temperature: 0.72
                        }
                    );
                    emitRawObjects(parser.finalize(), 'stream-finalize');
                    if (emittedCount > 0) {
                        return {
                            emittedCount,
                            streamUsed: true,
                            partial: false,
                            rawText: parser.getText() || streamText || ''
                        };
                    }

                    const parsedFromStreamText = parseAiFabricObjectsFromText(streamText || parser.getText());
                    emitRawObjects(parsedFromStreamText, 'stream-full');
                    if (emittedCount > 0) {
                        return {
                            emittedCount,
                            streamUsed: true,
                            partial: false,
                            rawText: parser.getText() || streamText || ''
                        };
                    }
                    throw new Error('Stream completed but returned no Fabric object array.');
                } catch (error) {
                    streamError = error;
                    if (emittedCount > 0) {
                        return {
                            emittedCount,
                            streamUsed: true,
                            partial: true,
                            warning: `Live stream interrupted. Applied ${emittedCount} object${emittedCount === 1 ? '' : 's'} so far.`
                        };
                    }
                }

                if (typeof onProgress === 'function') onProgress('Fallback: requesting object array');
                let responseText = '';
                try {
                    responseText = await requestAiResponseText(
                        apiKey,
                        retryParts,
                        {
                            enforceJson: true,
                            onProgress,
                            timeoutMs: Math.min(AI_CREATIVE_REQUEST_TIMEOUT_MS, 65000),
                            responseSchema: null
                        }
                    );
                } catch (fallbackError) {
                    if (streamError) {
                        throw new Error(`${streamError.message} Fallback failed: ${fallbackError.message}`);
                    }
                    throw fallbackError;
                }

                const fallbackObjects = parseAiFabricObjectsFromText(responseText);
                emitRawObjects(fallbackObjects, 'fallback');
                if (emittedCount <= 0) {
                    const prefix = streamError ? `${streamError.message} ` : '';
                    throw new Error(`${prefix}AI returned no valid Fabric objects.`);
                }
                return {
                    emittedCount,
                    streamUsed: false,
                    partial: false,
                    warning: streamError ? 'Live stream unavailable. Fallback object array applied.' : ''
                };
            }

            async function applyAiRawFabricObjectLive(rawObject, context = {}) {
                const pageWidth = parsePositiveInt(context.pageWidth, DEFAULT_PAGE_WIDTH);
                const pageHeight = parsePositiveInt(context.pageHeight, DEFAULT_PAGE_HEIGHT);
                const pageId = context.pageId || currentCanvasPageId();
                const usedOids = context.usedOids instanceof Set ? context.usedOids : new Set();
                const report = context.report && typeof context.report === 'object'
                    ? context.report
                    : { sourceObjects: 0, keptObjects: 0, droppedObjects: 0, truncatedObjects: 0, appliedObjects: 0, failedEnliven: 0 };
                report.sourceObjects += 1;

                const safeObject = sanitizeAiFabricObjectStrict(
                    rawObject,
                    { pageWidth, pageHeight, depth: 0 },
                    report
                );
                if (!safeObject) return false;

                const baseOid = sanitizeSafeString(safeObject.oid, 90, '') || `ai_gen_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
                let nextOid = baseOid;
                let attempt = 2;
                while (usedOids.has(nextOid)) {
                    nextOid = `${baseOid}_${attempt}`;
                    attempt += 1;
                }
                usedOids.add(nextOid);
                safeObject.oid = nextOid;
                safeObject.pageId = pageId;
                safeObject.name = sanitizeSafeString(safeObject.name, 120, '') || getUniqueName(safeObject.type || 'object');

                const enlivened = await enlivenFabricObjectsSafe([safeObject]);
                if (!enlivened.length) {
                    report.failedEnliven += 1;
                    return false;
                }

                const obj = enlivened[0];
                obj.set({
                    oid: safeObject.oid,
                    name: safeObject.name,
                    pageId,
                    originX: 'left',
                    originY: 'top'
                });

                if (
                    obj.type === 'image'
                    && Number.isFinite(safeObject.width)
                    && Number.isFinite(safeObject.height)
                    && Number.isFinite(obj.width)
                    && Number.isFinite(obj.height)
                    && obj.width > 0
                    && obj.height > 0
                ) {
                    obj.set({
                        scaleX: safeObject.width / obj.width,
                        scaleY: safeObject.height / obj.height
                    });
                }

                canvas.add(obj);
                if (isTextLikeCanvasObject(obj)) {
                    fitTextObjectWithinFrame(obj, getCurrentPageFrame(), 22);
                }
                keepObjectInsideFrame(obj, getCurrentPageFrame(), {
                    marginX: isTextLikeCanvasObject(obj) ? 20 : 0,
                    marginY: isTextLikeCanvasObject(obj) ? 16 : 0
                });
                if (typeof obj.setCoords === 'function') obj.setCoords();
                canvas.requestRenderAll();
                report.appliedObjects += 1;
                return true;
            }

            async function callAiCopilot(apiKey, promptText, {
                onProgress = null,
                phase = 'full',
                appliedActions = []
            } = {}) {
                const normalizedPhase = String(phase || 'full').toLowerCase() === 'draft' ? 'draft' : 'full';
                const isDraft = normalizedPhase === 'draft';
                const requestTimeoutMs = isDraft ? 22000 : AI_REQUEST_TIMEOUT_MS;
                const parts = [{
                    text: buildCopilotPrompt(promptText, {
                        phase: normalizedPhase,
                        includeConversation: !isDraft,
                        appliedActions
                    })
                }];

                if (typeof onProgress === 'function') onProgress(isDraft ? 'Drafting actions' : 'Preparing request');
                if (!isDraft) {
                    if (typeof onProgress === 'function') onProgress('Collecting canvas JSON');
                    const canvasJsonPart = buildCanvasJsonContextPart();
                    if (canvasJsonPart) parts.push(canvasJsonPart);
                }
                if (!isDraft && shouldIncludeCanvasSnapshot(promptText)) {
                    if (typeof onProgress === 'function') onProgress('Capturing canvas');
                    const snapshotPart = buildCanvasSnapshotPart();
                    if (snapshotPart) {
                        parts.push({ text: 'Current canvas snapshot:' });
                        parts.push(snapshotPart);
                    }
                }

                if (aiAttachment) {
                    if (aiAttachment.kind === 'inline') {
                        parts.push({ text: `Reference attachment: ${aiAttachment.name}. Use this to recreate the layout with canvas actions.` });
                        parts.push({
                            inline_data: {
                                mime_type: aiAttachment.mimeType || 'application/octet-stream',
                                data: aiAttachment.inlineData
                            }
                        });
                    } else if (aiAttachment.kind === 'text') {
                        parts.push({ text: `Attached file: ${aiAttachment.name}\n\n${aiAttachment.text}` });
                    }
                }

                const responseText = await requestAiResponseText(
                    apiKey,
                    parts,
                    { enforceJson: true, onProgress, timeoutMs: requestTimeoutMs }
                );
                if (!responseText) return { reply: 'No response text was returned.', actions: [] };

                if (typeof onProgress === 'function') onProgress('Parsing actions');
                const parsed = parseAiJsonResponse(responseText);
                if (parsed) {
                    const normalized = normalizeAiParsedPayload(parsed, 'Done.');
                    if (!Array.isArray(normalized.actions) || !normalized.actions.length) {
                        normalized.actions = extractActionsFromPlainText(`${normalized.reply}\n${promptText}`)
                            .map(normalizeAiAction)
                            .filter(Boolean);
                    }
                    return normalized;
                }

                const repaired = await tryRepairActionsFromText(
                    apiKey,
                    promptText,
                    responseText,
                    { onProgress, timeoutMs: Math.min(requestTimeoutMs, 22000) }
                );
                if (repaired) return repaired;

                const heuristicActions = extractActionsFromPlainText(`${responseText}\n${promptText}`)
                    .map(normalizeAiAction)
                    .filter(Boolean);
                return {
                    reply: responseText,
                    actions: heuristicActions
                };
            }

            async function handleAiSend() {
                const apiKey = aiApiKeyInput.value.trim();
                const prompt = aiPromptInput.value.trim();
                if (!apiKey) {
                    alert('Please enter your Google AI Studio API key.');
                    return;
                }
                if (!prompt && !aiAttachment) {
                    alert('Please enter a message or attach a file.');
                    return;
                }

                localStorage.setItem('googleAiApiKey', apiKey);

                const userLine = prompt || '(Attachment only)';
                appendAiChatMessage('user', userLine);
                aiConversation.push({ role: 'user', text: userLine });
                aiPromptInput.value = '';

                const thinkingEl = appendAiChatMessage('status', 'Thinking...');
                const thinkingTicker = createAiThinkingTicker(thinkingEl);
                setAiBusy(true);

                try {
                    const replaceCanvas = shouldReplaceCurrentCanvasForAi(prompt, !!aiAttachment);
                    const pageInfo = getCurrentPageDimensionsForAi();
                    const pageId = currentCanvasPageId();
                    const usedOids = new Set(
                        canvas.getObjects()
                            .map((obj) => sanitizeSafeString(obj?.oid, 90, ''))
                            .filter(Boolean)
                    );
                    const liveReport = {
                        sourceObjects: 0,
                        keptObjects: 0,
                        droppedObjects: 0,
                        truncatedObjects: 0,
                        appliedObjects: 0,
                        failedEnliven: 0
                    };

                    if (replaceCanvas) {
                        thinkingTicker.setStage('Clearing current canvas');
                        clearCurrentPageDrawableObjects();
                        bindings = new Map();
                        syncCurrentPageStateFromCanvas();
                    }

                    let applyQueue = Promise.resolve();
                    const enqueueRawObject = (rawObject, meta = {}) => {
                        applyQueue = applyQueue.then(async () => {
                            try {
                                const nextLabel = liveReport.appliedObjects + 1;
                                thinkingTicker.setStage(`Drawing object ${nextLabel}`);
                                await applyAiRawFabricObjectLive(rawObject, {
                                    pageWidth: pageInfo.width,
                                    pageHeight: pageInfo.height,
                                    pageId,
                                    usedOids,
                                    report: liveReport
                                });
                                if (liveReport.appliedObjects > 0 && liveReport.appliedObjects % 3 === 0) {
                                    syncCurrentPageStateFromCanvas();
                                    renderLayers();
                                    refreshCanvasPageControlsDebounced();
                                }
                                if (meta?.source === 'stream') {
                                    await delayMs(AI_LIVE_RENDER_DELAY_MS);
                                }
                            } catch (err) {
                                console.warn('Live object apply failed:', err);
                            }
                        });
                    };

                    const creativeSummary = await callAiCreativeFabricDesigner(
                        apiKey,
                        prompt,
                        {
                            onProgress: (stage) => thinkingTicker.setStage(stage),
                            onRawObject: enqueueRawObject
                        }
                    );
                    await applyQueue;

                    if (liveReport.appliedObjects <= 0) {
                        throw new Error('AI returned no drawable objects after validation.');
                    }

                    const polished = polishCurrentPageLayoutForProfessionalOutput() ? 1 : 0;
                    syncCurrentPageStateFromCanvas();
                    requestSaveState();
                    renderLayers();
                    refreshCanvasPageControlsDebounced();

                    thinkingTicker.stop();
                    thinkingEl.className = 'ai-chat-message assistant';
                    const filtered = Math.max(0, parseInt(liveReport.droppedObjects, 10) || 0);
                    const failedEnliven = Math.max(0, parseInt(liveReport.failedEnliven, 10) || 0);
                    const streamFlag = creativeSummary?.streamUsed ? ' (live stream)' : ' (fallback mode)';
                    const partialNote = creativeSummary?.partial ? ' Partial result preserved.' : '';
                    const warningNote = creativeSummary?.warning ? ` ${creativeSummary.warning}` : '';
                    const polishNote = polished > 0 ? ' Professional polish applied.' : '';
                    const filterNote = (filtered > 0 || failedEnliven > 0)
                        ? ` Sanitizer filtered ${filtered} and skipped ${failedEnliven}.`
                        : '';
                    const finalMsg = `Applied ${liveReport.appliedObjects} AI object${liveReport.appliedObjects === 1 ? '' : 's'}${streamFlag}.${polishNote}${filterNote}${partialNote}${warningNote}`;
                    thinkingEl.textContent = finalMsg;
                    aiConversation.push({ role: 'assistant', text: finalMsg });
                } catch (error) {
                    thinkingTicker.stop();
                    console.error('AI Copilot Error:', error);
                    thinkingEl.textContent = `Error: ${error.message}`;
                    thinkingEl.className = 'ai-chat-message status';
                } finally {
                    thinkingTicker.stop();
                    setAiBusy(false);
                    clearAiAttachment();
                }
            }

            aiSendBtn.addEventListener('click', () => {
                handleAiSend().catch(err => {
                    console.error('AI send failed:', err);
                    appendAiChatMessage('status', `Error: ${err.message}`);
                    setAiBusy(false);
                });
            });

            aiPromptInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    aiSendBtn.click();
                }
            });

            aiPromptInput.addEventListener('paste', async (e) => {
                const items = (e.clipboardData || window.clipboardData)?.items;
                if (!items) return;
                for (const item of items) {
                    if (item.kind === 'file' && item.type?.startsWith('image/')) {
                        const file = item.getAsFile();
                        if (!file) continue;
                        try {
                            aiAttachment = await toAttachmentPayload(file);
                            updateAttachmentMeta();
                        } catch (err) {
                            showNotification(`Attachment error: ${err.message}`, 'error');
                        }
                        break;
                    }
                }
            });

            aiFileInput.addEventListener('change', async (e) => {
                const file = e.target.files?.[0];
                if (!file) {
                    clearAiAttachment();
                    return;
                }
                try {
                    aiAttachment = await toAttachmentPayload(file);
                    updateAttachmentMeta();
                } catch (err) {
                    clearAiAttachment();
                    showNotification(`Attachment error: ${err.message}`, 'error');
                }
            });

            aiClearFileBtn.addEventListener('click', () => clearAiAttachment());
            aiResetChatBtn.addEventListener('click', resetAiChat);

            resetAiChat();
        }


// components/07-panels-tour-bootstrap.js
        // --- LEFT PANEL TABS & ELEMENTS ---
        function initializeLeftPanelTabs() {
            const tabButtons = document.querySelectorAll('.panel-tab-btn');
            const tabContents = document.querySelectorAll('.panel-tab-content');

            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Deactivate all tabs and content panels
                    tabButtons.forEach(b => b.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));

                    // Activate the clicked tab
                    btn.classList.add('active');

                    // Find and activate the correct content panel using the robust data-target attribute
                    const targetId = btn.dataset.target;
                    const targetContent = document.getElementById(targetId);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    } else {
                        console.error(`Tab content panel with ID "${targetId}" not found.`);
                    }
                });
            });

            const searchInput = $('#element-search');
            if (searchInput) {
                const debouncedSearch = debounce(searchElements, 300);
                searchInput.addEventListener('input', () => debouncedSearch(searchInput.value));
            }

            // Initial load of elements
            searchElements('');
        }
        let currentPage = 0;
        let isLoading = false; // Prevents fetching multiple pages at once
        let currentQuery = ''; // Tracks the active search query

        const ELEMENTS_PER_PAGE = 50;

        /**
         * A helper function to shuffle an array in place using the Fisher-Yates algorithm.
         * @param {Array} array The array to be shuffled.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
        }

        /**
         * Fetches and displays elements from Supabase with infinite scroll and randomization.
         * @param {string} query The search query.
         * @param {boolean} isNewSearch If true, resets pagination and clears the grid.
         */
        async function searchElements(query, isNewSearch = true) {
            if (!supabase || isLoading) return;

            const grid = document.getElementById('elements-grid');
            if (!grid) return;

            // --- Reset for a new search ---
            if (isNewSearch) {
                currentQuery = query;
                currentPage = 0;
                grid.innerHTML = '';
                // Clean up any existing IntersectionObserver
                if (grid.observer) {
                    grid.observer.disconnect();
                }
            }

            isLoading = true;

            // --- Loading Indicator ---
            const loadingIndicator = document.createElement('p');
            loadingIndicator.className = 'muted';
            loadingIndicator.textContent = 'Loading...';
            grid.appendChild(loadingIndicator);

            // --- Supabase Query with Pagination ---
            const from = currentPage * ELEMENTS_PER_PAGE;
            const to = from + ELEMENTS_PER_PAGE - 1;

            let queryBuilder = supabase.from('elements').select('id, name, image_url, tags');
            if (currentQuery) {
                queryBuilder = queryBuilder.or(`name.ilike.%${currentQuery}%,tags.cs.{${currentQuery}}`);
            }

            // Fetch in a consistent order (e.g., by ID) for stable pagination results.
            const { data, error } = await queryBuilder.order('id').range(from, to);

            // Always remove the loading indicator after the fetch attempt.
            grid.removeChild(loadingIndicator);
            isLoading = false;

            if (error) {
                console.error('Element search error:', error);
                grid.innerHTML = '<p class="muted">Error loading elements.</p>';
                return;
            }

            // Handle no results
            if (!data || data.length === 0) {
                if (isNewSearch) {
                    grid.innerHTML = '<p class="muted">No elements found.</p>';
                }
                // Stop here; no more data to load.
                return;
            }

            // --- RANDOMIZE THE BATCH ---
            shuffleArray(data);

            // --- Element Rendering Loop ---
            for (const el of data) {
                const chip = document.createElement('div');
                chip.className = 'element-chip';
                chip.draggable = true;

                const img = document.createElement('img');
                img.alt = el.name;
                img.loading = 'lazy'; // Defer loading off-screen images

                const isSvg = el.image_url.toLowerCase().endsWith('.svg');
                const imageUrlWithCacheBust = `${el.image_url}?t=${Date.now()}`;

                // Asynchronously load the image to avoid blocking the loop
                (async () => {
                    try {
                        if (isSvg) {
                            const response = await fetch(imageUrlWithCacheBust);
                            const blob = await response.blob();
                            const svgBlob = blob.type === 'image/svg+xml' ?
                                blob :
                                new Blob([await blob.text()], { type: 'image/svg+xml' });
                            img.src = URL.createObjectURL(svgBlob);
                        } else {
                            img.src = imageUrlWithCacheBust;
                        }
                    } catch (err) {
                        console.error(`Failed to load image for ${el.name}:`, err);
                        chip.innerHTML = `<span class="muted" style="font-size: 10px; text-align: center;">Load Error</span>`;
                        chip.draggable = false;
                    }
                })();

                img.onerror = () => {
                    chip.innerHTML = `<span class="muted" style="font-size: 10px; text-align: center;">Load Error</span>`;
                    chip.title = `Error loading: ${el.name}`;
                    chip.draggable = false;
                };

                chip.appendChild(img);

                // --- Drag Support (Handles all image types) ---
                chip.addEventListener('dragend', e => {
                    if (!(img.complete && img.naturalHeight !== 0)) return;

                    // Get mouse position relative to the canvas
                    const canvasRect = canvas.upperCanvasEl.getBoundingClientRect();
                    const mouseX = e.clientX - canvasRect.left;
                    const mouseY = e.clientY - canvasRect.top;

                    // Convert to Fabric coordinates considering zoom/pan
                    const pointer = canvas.getPointer({ clientX: e.clientX, clientY: e.clientY });

                    if (isSvg) {
                        adders.svg(pointer.x, pointer.y, img.src, { oid: el.id });
                    } else {
                        adders.image(pointer.x, pointer.y, img.src, { oid: el.id });
                    }
                });

                // --- Click Support ---
                chip.addEventListener('click', () => {
                    if (img.complete && img.naturalHeight !== 0) {
                        const { x, y } = canvas.getVpCenter();
                        // Logic correctly distinguishes between SVG and raster images
                        if (isSvg) {
                            adders.svg(x, y, img.src, { oid: el.id }); // img.src is the blob URL here
                        } else {
                            adders.image(x, y, img.src, { oid: el.id });
                        }
                    }
                });

                grid.appendChild(chip);
            }

            // Prepare for the next page
            currentPage++;

            // --- Intersection Observer Setup ---
            // If we loaded a full page, there might be more results.
            // Set up the observer on the last element to trigger loading the next page.
            if (data.length === ELEMENTS_PER_PAGE) {
                const lastElement = grid.lastElementChild;
                if (lastElement) {
                    const observer = new IntersectionObserver((entries) => {
                        if (entries[0].isIntersecting) {
                            observer.disconnect(); // Important: Stop observing the current last element
                            // Load the next page for the same query
                            searchElements(currentQuery, false);
                        }
                    }, { threshold: 0.5 }); // Trigger when 50% of the element is visible

                    observer.observe(lastElement);
                    grid.observer = observer; // Store for cleanup
                }
            }
        }

        // --- INTERACTIVE TOUR ---
        const tourModal = $('#tour-modal');
        const tourHighlight = $('#tour-highlight');
        let currentTourStep = 0;
        const tourSteps = [
            {
                title: "How to Structure Your Data",
                content: `<p>Before importing, make sure your data is structured correctly in a .csv or .xlsx file.</p><img src="assets/images/data-structure-example.png" alt="Example data structure" style="max-width:100%; margin-bottom:1rem;" /><ul><li>Column names should start in cell <b>A1</b>.</li><li>Each new row will be treated as a different file or page.</li></ul>`,
                element: null
            },
            {
                title: "How to Import Your Data",
                content: `<p>Press the <b>Load Data</b> button to open the file picker.</p><p>Valid formats are <b>.xlsx</b> and <b>.csv</b>.</p>`,
                element: 'label[for="csvInput"]'
            },
            {
                title: "AI Copilot",
                content: `<p>The assistant now lives in the lower half of the left panel.</p><p>Use it for iterative edits instead of one-shot generation.</p>`,
                element: '#aiAssistantPanel'
            },
            {
                title: "AI Setup",
                content: `You will need a <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio API key</a>.</p><ul><li>Login to your Google Account.</li><li>Create an API key.</li><li>Paste it in the AI panel.</li></ul>`,
                element: '#aiApiKeyPanel'
            },
            {
                title: "AI Prompting",
                content: `Now enter your request in the chat box and press <b>Send</b>.</p><p><b>Tips:</b></p><ul><li>Ask in small iterative steps.</li><li>You can attach files and keep refining.</li></ul>`,
                element: '#aiChatPrompt'
            },
            {
                title: "How to Link Your Data",
                content: `<p>First, make sure you have imported your data.</p><p>Press <b>Data Links</b> to open the manager.</p>`,
                element: '#openDataLinksManagerBtn',
                action: () => { $('#dataLinksManagerModal').style.display = 'none'; }
            },
            {
                title: "How to Link Your Data",
                content: `<p>From there, you can select an object, choose a column from your data, and link it to a property like 'Text Content' or 'Color'.</p>`,
                element: '.objects-list-container',
                action: () => { $('#dataLinksManagerModal').style.display = 'flex'; }
            },
            {
                title: "Tour Complete!",
                content: `<p>You now know the basics! Start creating your templates.</p>`,
                element: null,
                action: () => { $('#dataLinksManagerModal').style.display = 'none'; }
            }
        ];
        function startTour() { currentTourStep = 0; tourModal.style.display = 'flex'; goToStep(currentTourStep); } function endTour() { tourModal.style.display = 'none'; tourHighlight.style.display = 'none'; localStorage.setItem('hasSeenTour', 'true'); }
        function goToStep(stepIndex) {
            const step = tourSteps[stepIndex];
            if (!step) {
                endTour();
                return;
            }

            // Execute the action first to ensure the element is visible
            if (step.action) {
                step.action();
            }

            if (!step.action) {
                document.querySelectorAll('.modal-backdrop').forEach(m => m.style.display = 'none');
            }

            $('#tour-modal-title').textContent = step.title;
            $('#tour-modal-content').innerHTML = step.content;
            $('#tour-step-counter').textContent = `${stepIndex + 1} / ${tourSteps.length}`;
            $('#tour-prev-btn').disabled = stepIndex === 0;
            $('#tour-next-btn').style.display = stepIndex === tourSteps.length - 1 ? 'none' : 'inline-flex';
            $('#tour-finish-btn').style.display = stepIndex === tourSteps.length - 1 ? 'inline-flex' : 'none';

            const targetEl = step.element ? $(step.element) : null;
            if (targetEl) {
                // Now getBoundingClientRect will have the correct dimensions
                const rect = targetEl.getBoundingClientRect();
                tourHighlight.style.display = 'block';
                tourHighlight.style.width = `${rect.width + 10}px`;
                tourHighlight.style.height = `${rect.height + 10}px`;
                tourHighlight.style.top = `${rect.top - 5}px`;
                tourHighlight.style.left = `${rect.left - 5}px`;

                const modalRect = tourModal.getBoundingClientRect();
                let modalTop = rect.top + 30,
                    modalLeft = rect.right + modalRect.width;

                if (modalLeft + modalRect.width > window.innerWidth) {
                    modalLeft = rect.left - modalRect.width + 100;
                }
                if (modalTop + modalRect.height > window.innerHeight) {
                    modalTop = window.innerHeight - modalRect.height - 30;
                }

                modalTop = Math.max(15, modalTop);
                modalLeft = Math.max(15, modalLeft);

                tourModal.style.top = `${modalTop}px`;
                tourModal.style.left = `${modalLeft}px`;
            } else {
                tourHighlight.style.display = 'none';
                tourModal.style.top = '50%';
                tourModal.style.left = '50%';
                tourModal.style.transform = 'translate(-50%, -50%)';
            }
        }
        on('#start-tour-btn', 'click', startTour); on('#tour-close-btn', 'click', endTour); on('#tour-finish-btn', 'click', endTour); on('#tour-next-btn', 'click', () => { currentTourStep++; goToStep(currentTourStep); }); on('#tour-prev-btn', 'click', () => { currentTourStep--; goToStep(currentTourStep); });

        // 5. Enhanced Template Loader
        const templateLoaderModal = $('#template-loader-modal');
        async function toggleTemplateLoader(button) {
            if (templateLoaderModal.style.display === 'block') {
                templateLoaderModal.style.display = 'none';
                return;
            }
            const rect = button.getBoundingClientRect();
            const maxW = 420;
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            let left = rect.left;
            let top = rect.bottom + 8;
            if (left + maxW > vw - 12) left = Math.max(12, vw - maxW - 12);
            if (top > vh - 120) top = Math.max(12, rect.top - 8);
            templateLoaderModal.style.top = `${top}px`;
            templateLoaderModal.style.left = `${left}px`;
            templateLoaderModal.style.display = 'block';
            templateLoaderModal.innerHTML = '<p class="muted" style="padding: 24px; text-align: center;">Loading templates...</p>';

            const [publicTemplates, purchasedTemplates, myTemplates] = await Promise.all([
                supabase.from('public_templates').select('id, title, template_data'),
                currentUser ? supabase.from('purchased_templates').select('store_templates(id, title, template_data)').eq('user_id', currentUser.id) : Promise.resolve({ data: [] }),
                currentUser ? supabase.from('templates').select('id, title, template_data').eq('user_id', currentUser.id).order('created_at', { ascending: false }) : Promise.resolve({ data: [] })
            ]);

            templateLoaderModal.innerHTML = `
        <div class="template-modal-tabs">
            <button class="template-modal-tab active" data-tab="public">Public</button>
            <button class="template-modal-tab" data-tab="mine">My Templates</button>
            <button class="template-modal-tab" data-tab="purchased">Library</button>
        </div>
        <div id="public-templates" class="template-grid"></div>
        <div id="my-templates" class="template-grid" style="display:none;"></div>
        <div id="purchased-templates" class="template-grid" style="display:none;"></div>
        <div style="padding: 12px; border-top: 1px solid var(--border); background: var(--panel-2); display: flex; gap: 8px;">
            <button id="loadJsonBtn" class="btn ghost" style="flex: 1; font-size: 11px;">Upload JSON</button>
        </div>
        <input type="file" id="jsonUpload" accept=".json" style="display:none;">
    `;

            const publicGrid = $('#public-templates');
            publicGrid.innerHTML = '';
            (publicTemplates.data || []).forEach(t => publicGrid.appendChild(createTemplateItem(t, true)));

            const myGrid = $('#my-templates');
            myGrid.innerHTML = '';
            if (myTemplates.data && myTemplates.data.length > 0) {
                myTemplates.data.forEach(t => myGrid.appendChild(createTemplateItem(t, false)));
            } else {
                myGrid.innerHTML = `<div style="grid-column: 1 / -1; padding: 32px 16px; text-align: center;">
            <p class="muted" style="font-size: 12px; margin-bottom: 12px;">You haven't saved any templates yet.</p>
            <button onclick="templateLoaderModal.style.display='none'" class="btn primary" style="height: 28px; font-size: 11px;">Start Creating</button>
        </div>`;
            }

            const purchasedGrid = $('#purchased-templates');
            purchasedGrid.innerHTML = '';
            if (purchasedTemplates.data && purchasedTemplates.data.length > 0) {
                purchasedTemplates.data.forEach(t => purchasedGrid.appendChild(createTemplateItem(t.store_templates, false, true)));
            } else {
                purchasedGrid.innerHTML = '<p class="muted" style="font-size: 12px; text-align: center; grid-column: 1 / -1; padding: 32px 16px;">No purchased templates found.</p>';
            }

            document.querySelectorAll('.template-modal-tab').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.template-modal-tab').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    publicGrid.style.display = btn.dataset.tab === 'public' ? 'grid' : 'none';
                    myGrid.style.display = btn.dataset.tab === 'mine' ? 'grid' : 'none';
                    purchasedGrid.style.display = btn.dataset.tab === 'purchased' ? 'grid' : 'none';
                });
            });

            on('#loadJsonBtn', 'click', () => $('#jsonUpload').click());
        }

        function createTemplateItem(template, isPublic, isPurchased = false) {
            const item = document.createElement('div');
            item.className = 'template-item';

            const thumb = document.createElement('div');
            thumb.className = 'template-thumb';
            thumb.style.backgroundColor = '#111';
            thumb.innerHTML = '<div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; opacity:0.1;"><svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg></div>';

            const title = document.createElement('div');
            title.className = 'template-title';
            title.textContent = template.title || 'Untitled Template';

            item.append(thumb, title);

            // Lightweight preview generation
            setTimeout(() => {
                try {
                    const data = template.template_data;
                    const previewCanvas = data?.canvas || data?.pages?.[0]?.canvas;
                    if (previewCanvas) {
                        const off = document.createElement('canvas');
                        off.width = 320;
                        off.height = 240;
                        const c2 = new fabric.StaticCanvas(off); // Use StaticCanvas for better performance
                        c2.loadFromJSON(previewCanvas, () => {
                            const pr = c2.getObjects().find(o => o.oid === 'pageRect');
                            if (pr) {
                                pr.set({ strokeWidth: 0, shadow: null });
                                const zoom = Math.min(off.width / pr.width, off.height / pr.height) * 0.95;
                                c2.setZoom(zoom);
                                c2.viewportTransform[4] = (off.width - pr.width * zoom) / 2;
                                c2.viewportTransform[5] = (off.height - pr.height * zoom) / 2;
                            }
                            c2.renderAll();
                            const dataUrl = off.toDataURL('image/jpeg', 0.8);
                            thumb.innerHTML = ''; // Clear placeholder
                            thumb.style.backgroundImage = `url(${dataUrl})`;
                            c2.dispose();
                        });
                    }
                } catch (e) {
                    console.error('Preview failed:', e);
                }
            }, 50);

            item.onclick = () => {
                loadTemplateFromDB(template.id, { public: isPublic, purchased: isPurchased });
                templateLoaderModal.style.display = 'none';
            };
            return item;
        }

        on('#jsonUpload', 'change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const json = JSON.parse(event.target.result);
                    if (json && (json.pages || json.canvas || json.page || json.bindings)) {
                        if (json.page?.title) $('#titleInput').value = json.page.title;
                        if (json.data) {
                            headers = json.data.headers || [];
                            dataRows = json.data.rows || [];
                        }
                        await setDocumentPagesFromTemplate(json, { fitView: true, selectedIndex: json.currentPageIndex });
                        bindings = new Map(documentPages[currentPageIndex]?.bindings || json.bindings || []);
                    } else if (json && json.objects) {
                        const activePage = documentPages[currentPageIndex] || { width: DEFAULT_PAGE_WIDTH, height: DEFAULT_PAGE_HEIGHT };
                        await setDocumentPagesFromTemplate({
                            page: {
                                title: $('#titleInput').value || 'Untitled_Template',
                                width: parsePositiveInt(activePage.width, DEFAULT_PAGE_WIDTH),
                                height: parsePositiveInt(activePage.height, DEFAULT_PAGE_HEIGHT)
                            },
                            canvas: json,
                            bindings: []
                        }, { fitView: true });
                    } else {
                        throw new Error('Unsupported JSON format.');
                    }

                    historyStack = [];
                    historyIndex = -1;
                    lastHistorySig = null;
                    requestSaveState();
                    templateLoaderModal.style.display = 'none';
                } catch (err) {
                    alert('Invalid JSON file.');
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset input
        });

        window.addEventListener('click', (e) => {
            if (!templateLoaderModal.contains(e.target) &&
                !e.target.closest('#loadTemplateBtnPage') &&
                !e.target.closest('#openLoaderFromSidebar') &&
                !e.target.closest('#toolbarLoadTemplateBtn')) {
                templateLoaderModal.style.display = 'none';
            }
        });

        // --- INITIALIZE ---
        window.addEventListener('DOMContentLoaded', initializeEditor);

    


delete globalThis.__csvlink_supabase;

