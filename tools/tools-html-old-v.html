@ -16,1389 +16,7 @@
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <!-- jsPDF -->
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        :root {
            /* -- ANTIGRAVITY DARK THEME (Deepest Blue) -- */
            --bg: #030508;
            /* Almost black blue */
            --fg: #e2e8f0;
            /* Light cool gray */
            --muted: #64748b;
            /* Muted cool gray */

            --panel: #0b1121;
            /* Very dark deep blue */
            --panel-2: #151e32;
            /* Lighter deep blue for secondary inputs/hover */

            --border: #1e293b;
            /* Subtle blue-gray border */

            --accent: #3b82f6;
            /* Electric Blue */
            --accent-hover: #2563eb;
            --accent-fg: #151d58;

            --success: #10b981;
            --danger: #ef4444;

            --font: 'Inter', system-ui, -apple-system, sans-serif;
            --radius: 8px;
            /* Slightly rounder for modern feel */
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.3);
        }

        body.light-mode {
            --bg: #f8fafc;
            --fg: #0f172a;
            --muted: #64748b;
            --panel: #ffffff;
            --panel-2: #f1f5f9;
            --border: #e2e8f0;
            --accent: #2563eb;
            --accent-hover: #1d4ed8;
            --accent-fg: #ffffff;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        * {
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            margin: 0;
            color: var(--fg);
            background: var(--bg);
            font-family: var(--font);
            font-size: 13px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
        }

        /* Typography */
        h3,
        h4,
        h5 {
            margin: 0 0 10px;
            font-weight: 600;
            color: var(--fg);
            letter-spacing: -0.01em;
        }

        h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted);
            font-weight: 700;
        }

        p {
            margin: 0 0 10px;
        }

        label {
            font-size: 11px;
            color: var(--muted);
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
        }

        /* Buttons & Inputs */
        .btn {
            appearance: none;
            background: var(--panel-2);
            color: var(--fg);
            border: 1px solid var(--border);
            padding: 0 14px;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all .2s ease;
            text-decoration: none;
            height: 32px;
            white-space: nowrap;
            user-select: none;
        }

        .btn:hover {
            background: var(--border);
            border-color: var(--muted);
            color: #fff;
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            pointer-events: none;
        }

        .btn.primary {
            background: var(--accent);
            color: var(--accent-fg);
            border-color: transparent;
            box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }

        .btn.primary:hover {
            background: var(--accent-hover);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.4);
        }

        .btn.ghost {
            background: transparent;
            border-color: transparent;
            color: var(--muted);
        }

        .btn.ghost:hover {
            background: var(--panel-2);
            color: var(--fg);
        }

        .btn.ghost.active {
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent);
        }

        input[type="text"],
        input[type="search"],
        input[type="number"],
        input[type="password"],
        select,
        textarea {
            background: var(--bg);
            color: var(--fg);
            border: 1px solid var(--border);
            padding: 0 10px;
            border-radius: var(--radius);
            outline: none;
            font-family: inherit;
            font-size: 13px;
            transition: all .2s;
            width: 100%;
            height: 32px;
        }

        input:focus,
        select:focus,
        textarea:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        textarea {
            height: auto;
            padding: 8px;
            resize: vertical;
        }

        /* Layout */
        .app {
            display: grid;
            grid-template-rows: auto 1fr auto;
            flex-grow: 1;
            min-height: 0;
        }

        .main {
            display: grid;
            grid-template-columns: 260px 1fr 280px;
            gap: 0;
            padding: 0;
            min-height: 0;
            overflow: hidden;
            background: var(--bg);
        }

        /* Header */
        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 16px;
            height: 56px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            backdrop-filter: blur(8px);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 700;
            color: var(--fg);
            text-decoration: none;
            font-size: 16px;
            letter-spacing: -0.02em;
        }

        .logo-icon {
            width: 24px;
            height: 24px;
            object-fit: contain;
        }

        .nav-links {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .nav-links a {
            color: var(--muted);
            text-decoration: none;
            font-weight: 500;
            transition: color .15s;
            font-size: 13px;
        }

        .nav-links a:hover {
            color: var(--fg);
        }

        /* Toolbar */
        header {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 6px 12px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            height: 44px;
            flex-shrink: 0;
        }

        .toolbar {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .toolbar-group {
            display: flex;
            gap: 4px;
            padding: 2px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg);
            align-items: center;
        }

        /* Panels */
        .panel {
            background: var(--panel);
            display: flex;
            flex-direction: column;
            min-width: 0;
            position: relative;
            z-index: 10;
        }

        /* BORDERS: Only minimal separator lines */
        .panel.left {
            border-right: 1px solid var(--border);
        }

        .panel.right {
            border-left: 1px solid var(--border);
        }

        /* Panel Content - FIXED SCROLLING */
        .left-panel-content,
        #inspectorWrap {
            padding: 12px;
            overflow-y: auto;
            flex: 1 1 0;
            min-height: 0;
            /* Critical for flex scroll */
        }

        /* Tabs */
        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin: 0 -16px 16px;
            padding: 0 16px;
            gap: 20px;
        }

        .panel-tab-btn {
            background: none;
            border: none;
            padding: 12px 0;
            color: var(--muted);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            cursor: pointer;
            letter-spacing: 0.02em;
            border-bottom: 2px solid transparent;
            transition: all .2s;
        }

        .panel-tab-btn:hover {
            color: var(--fg);
        }

        .panel-tab-btn.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .panel-tab-content {
            display: none;
            flex-direction: column;
            animation: fadeIn 0.2s ease;
        }

        .panel-tab-content.active {
            display: flex;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Canvas Area */
        .canvas-container-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-wrap {
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            background-color: #242c44;
            background-image: radial-gradient(rgba(59, 130, 246, 0.12) 1px, transparent 0);
            background-size: 20px 20px;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .table-cell-editor {
            position: fixed;
            z-index: 12000;
            border: 1px solid var(--accent);
            border-radius: 4px;
            padding: 0 6px;
            outline: none;
            background: #ffffff;
            color: #111111;
            box-shadow: var(--shadow);
        }

        .btn .inspector-icon {
            width: 14px;
            height: 14px;
            flex: 0 0 14px;
            display: block;
        }

        /* Footer */
        footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background: var(--panel);
            border-top: 1px solid var(--border);
            font-size: 12px;
            height: 48px;
            color: var(--muted);
        }

        /* Sidebar Toggles Improved */
        .panel-toggle {
            position: absolute;
            top: 50%;
            width: 24px;
            height: 48px;
            background: var(--panel);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 50;
            color: var(--muted);
            transform: translateY(-50%);
            transition: all 0.2s;
        }

        .panel-toggle:hover {
            color: var(--accent);
            background: var(--panel-2);
        }

        #left-panel-toggle {
            right: -24px;
            left: auto;
            border-left: none;
            border-radius: 0 8px 8px 0;
            box-shadow: 4px 0 8px rgba(0, 0, 0, 0.1);
        }

        #right-panel-toggle {
            left: -24px;
            right: auto;
            border-right: none;
            border-radius: 8px 0 0 8px;
            box-shadow: -4px 0 8px rgba(0, 0, 0, 0.1);
        }

        /* Floating Linker Modernized */
        #floating-linker {
            position: fixed !important;
            z-index: 9999;
            background: rgba(11, 17, 33, 0.95);
            /* Semi-transparent background */
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            display: none;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            animation: popIn 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .floating-linker-actions {
            display: flex;
            gap: 8px;
        }

        /* Components Grid */
        .components-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .shape-chip {
            background: var(--panel-2);
            border: 1px solid transparent;
            border-radius: var(--radius);
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            cursor: grab;
            transition: all .2s;
        }

        .shape-chip:hover {
            border-color: var(--accent);
            background: #1e293b;
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .shape-chip svg {
            width: 28px;
            height: 28px;
            stroke: var(--fg);
            stroke-width: 1.5;
            fill: none;
            opacity: 0.8;
        }

        .shape-chip:hover svg {
            stroke: var(--accent);
            opacity: 1;
        }

        .shape-chip span {
            font-size: 11px;
            color: var(--muted);
            font-weight: 500;
        }

        /* Layers List - Compact & Draggable */
        .layers-list {
            min-height: 100px;
        }

        .layers-list .layer-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid transparent;
            margin-bottom: 2px;
            cursor: grab;
            font-size: 11px;
            transition: all .15s;
            background: var(--panel-2);
            min-height: 28px;
        }

        .layers-list .layer-item:hover {
            background: var(--border);
        }

        .layers-list .layer-item.active {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.4);
            color: var(--accent);
        }

        .layers-list .layer-item.dragging {
            opacity: 0.4;
            border: 1px dashed var(--accent);
        }

        .layers-list .layer-item.drag-over {
            border-top: 2px solid var(--accent);
        }

        .layer-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-transform: capitalize;
        }

        .layer-actions {
            display: flex;
            gap: 2px;
        }

        .layer-actions .btn {
            padding: 2px;
            height: 20px;
            width: 20px;
        }

        /* Toast Notification */
        #toast-container {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            background: var(--panel);
            color: var(--fg);
            padding: 12px 20px;
            border-radius: 10px;
            border: 1px solid var(--border);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: toastIn 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            pointer-events: auto;
            min-width: 250px;
        }

        .toast.success {
            border-left: 4px solid var(--success);
        }

        .toast.error {
            border-left: 4px solid var(--danger);
        }

        .toast.info {
            border-left: 4px solid var(--accent);
        }

        @keyframes toastIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .toast.fade-out {
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
        }

        /* AI Bubble */
        .ai-bubble {
            position: absolute;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, var(--accent), #60a5fa);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 24px rgba(37, 99, 235, 0.4);
            cursor: pointer;
            transition: transform .2s;
            z-index: 20;
        }

        .ai-bubble:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 32px rgba(37, 99, 235, 0.6);
        }

        /* Modals - HIGH z-index to be above everything */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            color: var(--fg);
            z-index: 10001;
            animation: popIn 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .modal h2,
        .modal h3 {
            margin: 0 0 16px;
            font-size: 16px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--muted);
            cursor: pointer;
            font-size: 20px;
        }

        .modal-close:hover {
            color: var(--fg);
        }

        /* Column list (Data linking) */
        .col-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 360px;
            overflow: auto;
            padding: 2px;
        }

        .col-item {
            background: var(--panel-2);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 10px 12px;
            cursor: pointer;
        }

        .col-item:hover {
            border-color: var(--accent);
        }

        .col-item[aria-selected="true"] {
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.25);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--muted);
        }

        /* Utils */
        .hidden {
            display: none !important;
        }

        .muted {
            color: var(--muted);
        }

        /* Save status - golden yellow instead of orange */
        #saveStatus {
            color: #fbbf24 !important;
            font-weight: 500;
        }

        .stack {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .prop-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 12px;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        #noSelection {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 32px 16px;
            text-align: center;
            background: rgba(255, 255, 255, 0.01);
        }

        /* Color Picker Fix */
        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 4px;
        }

        /* Align Buttons Grid */
        .align-buttons {
            display: grid;
            grid-template-columns: repeat(6, 32px);
            gap: 4px;
            background: var(--bg);
            padding: 4px;
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .align-buttons .btn {
            border: none;
            background: transparent;
            padding: 4px;
            height: 28px;
            color: var(--muted);
        }

        .align-buttons .btn:hover {
            background: var(--panel-2);
            color: var(--fg);
        }


        /* --- Restored Tutorial Styles --- */
        #tour-modal {
            position: fixed;
            z-index: 30000;
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            width: 320px;
            box-shadow: var(--shadow-lg);
            display: none;
            flex-direction: column;
            transition: all 0.3s ease;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            /* Default centered, but moved by JS */
        }

        #tour-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            cursor: move;
        }

        #tour-modal-header h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: var(--fg);
        }

        #tour-modal-controls button {
            padding: 4px;
            line-height: 0;
        }

        #tour-modal-content {
            padding: 16px;
            font-size: 13px;
            line-height: 1.6;
            color: var(--fg);
        }

        #tour-modal-content p {
            margin: 0 0 12px;
        }

        #tour-modal-content ul {
            margin: 0;
            padding-left: 18px;
        }

        #tour-modal-content li {
            margin-bottom: 6px;
        }

        #tour-modal-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            margin-top: auto;
            border-top: 1px solid var(--border);
            background: var(--panel-2);
            border-radius: 0 0 12px 12px;
        }

        #tour-step-counter {
            font-size: 11px;
            font-weight: 500;
        }

        #tour-highlight {
            position: fixed;
            z-index: 1000;
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid var(--accent);
            border-radius: 6px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7);
            pointer-events: none;
            display: none;
            transition: all 0.3s ease-in-out;
        }

        /* --- Restored Loader Modal Grid --- */
        #template-loader-modal {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            z-index: 10002;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        .template-modal-tabs {
            display: flex;
            background: var(--panel-2);
            border-bottom: 1px solid var(--border);
            padding: 4px;
            gap: 4px;
        }

        .template-modal-tab {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--muted);
            padding: 8px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .template-modal-tab:hover {
            color: var(--fg);
            background: rgba(255, 255, 255, 0.05);
        }

        .template-modal-tab.active {
            background: var(--panel);
            color: var(--accent);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        #template-loader-modal .template-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
            padding: 12px;
        }

        #template-loader-modal .template-item {
            background: var(--panel-2);
            border: 1px solid var(--border);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            aspect-ratio: 4/3;
        }

        #template-loader-modal .template-item:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .template-thumb {
            flex: 1;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-color: #000;
            border-bottom: 1px solid var(--border);
            position: relative;
        }

        .template-thumb::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(to bottom, transparent 60%, rgba(0, 0, 0, 0.6));
            opacity: 0;
            transition: opacity 0.2s;
        }

        .template-item:hover .template-thumb::after {
            opacity: 1;
        }

        .template-title {
            padding: 8px 10px;
            font-size: 12px;
            font-weight: 500;
            color: var(--fg);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            background: var(--panel-2);
        }

        /* --- Restored Visual Crop Styles --- */
        #visualCropModal .modal {
            width: 90vw;
            height: 90vh;
            max-width: 1400px;
            display: flex;
            flex-direction: column;
        }

        #visualCropContainer {
            flex-grow: 1;
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            margin: 16px 0;
        }

        /* --- FIX: Toolbar Layout --- */
        .toolbar {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        #pageWidth,
        #pageHeight {
            width: 65px !important;
            text-align: center;
            height: 28px !important;
        }

        #titleInput {
            width: 130px !important;
            height: 28px !important;
        }

        #canvasPageSelect {
            width: 190px;
            height: 28px;
            font-size: 12px;
        }

        #addCanvasBtn,
        #duplicateCanvasBtn,
        #deleteCanvasBtn {
            font-size: 11px;
            padding: 0 10px;
            height: 28px;
        }

        /* Elements Grid */
        #elements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 8px;
            padding: 8px 0;
        }

        #elements-grid .element-chip {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--panel-2);
            border: 1px solid transparent;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.15s;
            padding: 8px;
        }

        #elements-grid .element-chip:hover {
            border-color: var(--accent);
            background: var(--border);
        }

        #elements-grid .element-chip svg,
        #elements-grid .element-chip img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* --- COMPACT INSPECTOR STYLES --- */
        #inspector,
        #multiSelectInspector {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #inspector h3,
        #multiSelectInspector h3 {
            margin: 0 0 4px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
            font-size: 10px;
        }

        /* Reduce stack gaps */
        .stack {
            gap: 6px !important;
            margin-bottom: 8px;
        }

        .prop-grid {
            gap: 6px;
            margin-bottom: 8px;
        }

        /* Compact prop rows */
        .prop-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 4px;
        }

        .prop-row label {
            flex: 0 0 60px;
            font-size: 10px;
            color: var(--muted);
            margin: 0;
        }

        .prop-row input,
        .prop-row select {
            flex: 1;
            height: 26px;
            font-size: 11px;
        }

        /* Slider rows */
        .slider-wrapper {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .slider-wrapper input[type="range"] {
            flex: 1;
            height: 3px;
            border-radius: 2px;
            accent-color: var(--accent);
        }

        .slider-wrapper input[type="number"] {
            width: 44px;
            text-align: center;
            height: 24px;
        }

        /* Section dividers - more compact */
        .inspector-section {
            padding: 8px;
            background: var(--bg);
            border-radius: 6px;
            border: 1px solid var(--border);
            margin-bottom: 6px;
        }

        .inspector-section h4 {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            color: var(--muted);
            margin: 0 0 8px;
        }

        /* Color picker compact */
        .color-picker-wrapper {
            height: 26px;
        }

        .color-picker-wrapper input[type="color"] {
            width: 22px;
            height: 22px;
            padding: 0;
            border: none;
            cursor: pointer;
        }

        .color-picker-wrapper input[type="text"] {
            height: 22px;
            border: none;
            background: transparent;
            padding: 0 4px;
            font-size: 11px;
        }

        /* Buttons in inspector */
        #inspector .btn,
        #multiSelectInspector .btn {
            height: 28px;
            font-size: 11px;
            padding: 0 10px;
        }

        /* noSelection compact */
        #noSelection {
            padding: 16px 12px;
        }

        #noSelection h4 {
            font-size: 12px;
            margin-bottom: 8px;
        }

        #noSelection p {
            font-size: 11px;
            margin-bottom: 8px;
        }



        /* --- UI/UX polish patch (2026-01-16) --- */
        :root {
            --canvas-bg: #3b455a;
            --canvas-dot: rgba(243, 98, 30, 0.712);
            --page-outline: rgba(0, 0, 0, 0.1);
        }

        body.light-mode {
            --canvas-bg: #cfd5dd;
            --canvas-dot: rgba(243, 98, 30, 0.712);
            --page-outline: rgba(15, 23, 42, .12);
        }

        .canvas-wrap {
            background-color: var(--canvas-bg) !important;
            background-image: radial-gradient(var(--canvas-dot) 1.5px, transparent 0) !important;
        }

        /* Make number inputs look modern (hide default spinners) */
        input[type="number"] {
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
            background: transparent;
        }

        /* Modern color picker */
        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            height: 32px;
            padding: 0 8px;
            background: var(--panel-2);
            border: 1px solid var(--border);
            border-radius: var(--radius);
        }

        .color-picker-wrapper input[type="text"] {
            height: 28px;
            border: none;
            background: transparent;
            padding: 0;
            font-size: 12px;
        }

        .color-picker-wrapper input[type="color"] {
            width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            padding: 0;
            border-radius: 8px;
            cursor: pointer;
        }

        .color-picker-wrapper input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker-wrapper input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 8px;
        }

        /* Tutorial always above everything */
        #tour-highlight {
            z-index: 10050 !important;
        }

        #tour-modal {
            z-index: 10060 !important;
        }

        /* Template loader should float */
        #template-loader-modal {
            position: fixed !important;
            z-index: 10040 !important;
        }

        /* Page outline visible even on white */

        /* Smaller align buttons */
        .align-btn {
            width: 32px !important;
            height: 32px !important;
            padding: 0 !important;
        }

        /* Ensure hidden panels don't peek */
        .panel.left,
        .panel.right {
            overflow: hidden;
        }

        .panel.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            border: none !important;
        }
    </style>
    <link rel="stylesheet" href="tools/tool.css?v=20260219g" />
</head>

<body>
@ -1421,13 +39,12 @@
    <div class="app">
        <header>
            <input id="titleInput" type="text" placeholder="Untitled" value="Untitled_Template" />
            <select id="canvasPageSelect" title="Canvas"></select>
            <button id="addCanvasBtn" class="btn ghost" title="Add Canvas">+ Canvas</button>
            <button id="duplicateCanvasBtn" class="btn ghost" title="Duplicate Canvas">Duplicate</button>
            <button id="deleteCanvasBtn" class="btn ghost" title="Delete Canvas">Delete</button>
            <input id="pageWidth" type="number" value="768" min="100" max="10000" title="Width" />
            <span class="muted">×</span>
            <input id="pageHeight" type="number" value="1024" min="100" max="10000" title="Height" />
            <div class="toolbar-group" id="globalPageSizeGroup" title="General size (updates matching pages only)">
                <span class="muted toolbar-label">General</span>
                <input id="pageWidth" type="number" value="768" min="100" max="10000" title="General Width" />
                <span class="muted">×</span>
                <input id="pageHeight" type="number" value="1024" min="100" max="10000" title="General Height" />
            </div>

            <div class="toolbar-group">
                <button id="undoBtn" class="btn ghost" title="Undo"><svg width="14" height="14" viewBox="0 0 24 24"
@ -1494,98 +111,167 @@
                        <polyline points="15 18 9 12 15 6"></polyline>
                    </svg></button>
                <div class="left-panel-content">
                    <div class="panel-tabs">
                        <button id="components-tab-btn" class="panel-tab-btn active"
                            data-target="components-content">Components</button>
                        <button id="layers-tab-btn" class="panel-tab-btn" data-target="layers-content">Layers</button>
                        <button id="elements-tab-btn" class="panel-tab-btn"
                            data-target="elements-content">Elements</button>
                    </div>

                    <div id="components-content" class="panel-tab-content active">
                        <div class="components-grid">
                            <div class="shape-chip" draggable="true" data-add="text"><svg viewBox="0 0 24 24">
                                    <path d="M5 4h14M12 4v16M8 20h8" fill="none" stroke-linecap="round"
                                        stroke-linejoin="round"></path>
                                </svg><span>Text</span></div>
                            <div class="shape-chip" draggable="true" data-add="image"><svg viewBox="0 0 24 24">
                                    <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                                    <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                    <path d="M21 15l-5-5L5 21" fill="none"></path>
                                </svg><span>Image</span></div>
                            <div class="shape-chip" draggable="true" data-add="square"><svg viewBox="0 0 24 24">
                                    <rect x="5" y="5" width="14" height="14" rx="1"></rect>
                                </svg><span>Square</span></div>
                            <div class="shape-chip" draggable="true" data-add="circle"><svg viewBox="0 0 24 24">
                                    <circle cx="12" cy="12" r="8"></circle>
                                </svg><span>Circle</span></div>
                            <div class="shape-chip" draggable="true" data-add="triangle"><svg viewBox="0 0 24 24">
                                    <path d="M12 2L2 22h20L12 2z"></path>
                                </svg><span>Triangle</span></div>
                            <div class="shape-chip" draggable="true" data-add="star"><svg viewBox="0 0 24 24">
                                    <path
                                        d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z">
                                    </path>
                                </svg><span>Star</span></div>
                            <div class="shape-chip" draggable="true" data-add="arrow"><svg viewBox="0 0 24 24">
                                    <path d="M5 12h14M12 5l7 7-7 7" fill="none"></path>
                                </svg><span>Arrow</span></div>
                            <div class="shape-chip" draggable="true" data-add="table"><svg viewBox="0 0 24 24"
                                    fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                    stroke-linejoin="round">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                    <line x1="3" y1="9" x2="21" y2="9"></line>
                                    <line x1="3" y1="15" x2="21" y2="15"></line>
                                    <line x1="9" y1="3" x2="9" y2="21"></line>
                                    <line x1="15" y1="3" x2="15" y2="21"></line>
                                </svg><span>Table</span></div>
                            <div class="shape-chip" draggable="true" data-add="line"><svg viewBox="0 0 24 24">
                                    <path d="M4 12h16" fill="none"></path>
                                </svg> <span>Line</span></div>
                    <div class="left-panel-split">
                        <div class="left-panel-top">
                            <div class="panel-tabs">
                                <button id="components-tab-btn" class="panel-tab-btn active"
                                    data-target="components-content">Components</button>
                                <button id="layers-tab-btn" class="panel-tab-btn"
                                    data-target="layers-content">Layers</button>
                                <button id="elements-tab-btn" class="panel-tab-btn"
                                    data-target="elements-content">Elements</button>
                            </div>

                            <div class="left-panel-top-body">
                                <div id="components-content" class="panel-tab-content active">
                                    <div class="components-grid">
                                        <div class="shape-chip" draggable="true" data-add="text"><svg
                                                viewBox="0 0 24 24">
                                                <path d="M5 4h14M12 4v16M8 20h8" fill="none" stroke-linecap="round"
                                                    stroke-linejoin="round"></path>
                                            </svg><span>Text</span></div>
                                        <div class="shape-chip" draggable="true" data-add="image"><svg
                                                viewBox="0 0 24 24">
                                                <rect x="3" y="3" width="18" height="18" rx="2"></rect>
                                                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                                                <path d="M21 15l-5-5L5 21" fill="none"></path>
                                            </svg><span>Image</span></div>
                                        <div class="shape-chip" draggable="true" data-add="square"><svg
                                                viewBox="0 0 24 24">
                                                <rect x="5" y="5" width="14" height="14" rx="1"></rect>
                                            </svg><span>Square</span></div>
                                        <div class="shape-chip" draggable="true" data-add="circle"><svg
                                                viewBox="0 0 24 24">
                                                <circle cx="12" cy="12" r="8"></circle>
                                            </svg><span>Circle</span></div>
                                        <div class="shape-chip" draggable="true" data-add="triangle"><svg
                                                viewBox="0 0 24 24">
                                                <path d="M12 2L2 22h20L12 2z"></path>
                                            </svg><span>Triangle</span></div>
                                        <div class="shape-chip" draggable="true" data-add="star"><svg
                                                viewBox="0 0 24 24">
                                                <path
                                                    d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z">
                                                </path>
                                            </svg><span>Star</span></div>
                                        <div class="shape-chip" draggable="true" data-add="arrow"><svg
                                                viewBox="0 0 24 24">
                                                <path d="M5 12h14M12 5l7 7-7 7" fill="none"></path>
                                            </svg><span>Arrow</span></div>
                                        <div class="shape-chip" draggable="true" data-add="table"><svg
                                                viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                                                stroke-linecap="round" stroke-linejoin="round">
                                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                                                <line x1="3" y1="9" x2="21" y2="9"></line>
                                                <line x1="3" y1="15" x2="21" y2="15"></line>
                                                <line x1="9" y1="3" x2="9" y2="21"></line>
                                                <line x1="15" y1="3" x2="15" y2="21"></line>
                                            </svg><span>Table</span></div>
                                        <div class="shape-chip" draggable="true" data-add="line"><svg
                                                viewBox="0 0 24 24">
                                                <path d="M4 12h16" fill="none"></path>
                                            </svg> <span>Line</span></div>
                                    </div>
                                </div>

                                <div id="templates-content" class="panel-tab-content">
                                    <div id="sidebar-templates-grid" class="stack" style="gap:12px; padding: 4px;">
                                        <p class="muted" style="font-size: 11px; text-align: center; padding: 20px;">
                                            Open the
                                            template library to browse and load professional designs.</p>
                                        <button id="openLoaderFromSidebar" class="btn primary" style="width: 100%;">Open
                                            Template
                                            Library</button>
                                    </div>
                                </div>

                                <div id="layers-content" class="panel-tab-content">
                                    <div id="layersList" class="layers-list stack"></div>
                                </div>

                                <div id="elements-content" class="panel-tab-content">
                                    <input type="search" id="element-search" placeholder="Search elements...">
                                    <div id="elements-grid"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="templates-content" class="panel-tab-content">
                        <div id="sidebar-templates-grid" class="stack" style="gap:12px; padding: 4px;">
                            <p class="muted" style="font-size: 11px; text-align: center; padding: 20px;">Open the
                                template library to browse and load professional designs.</p>
                            <button id="openLoaderFromSidebar" class="btn primary" style="width: 100%;">Open Template
                                Library</button>
                        <div class="left-panel-bottom">
                            <div id="aiAssistantPanel" class="ai-chat-panel">
                                <div class="ai-chat-header">
                                    <h4>AI Copilot</h4>
                                    <button id="aiResetChatBtn" class="btn ghost" type="button">Reset Chat</button>
                                </div>

                                <div class="stack" style="gap:8px;">
                                    <label for="aiApiKeyPanel">Google AI Studio API Key</label>
                                    <input type="password" id="aiApiKeyPanel" placeholder="Paste API key" />
                                </div>

                                <div id="aiChatLog" class="ai-chat-log">
                                    <div class="ai-chat-empty muted">
                                        Ask for layout ideas, canvas changes, dimensions, icons, and iterative edits.
                                    </div>
                                </div>

                                <div id="aiAttachmentMeta" class="ai-attachment-meta muted"></div>

                                <div class="stack" style="gap:8px;">
                                    <label for="aiChatPrompt">Message</label>
                                    <div class="ai-prompt-wrap">
                                        <textarea id="aiChatPrompt" rows="4"
                                            placeholder="Example: create 3 canvases, set each to 1080x1350, and design a clean inbox UI."></textarea>
                                        <div class="ai-prompt-tools">
                                            <label for="aiChatFile" class="btn ghost icon-only ai-attach-btn"
                                                title="Attach file" aria-label="Attach file">
                                                <svg viewBox="0 0 24 24" aria-hidden="true">
                                                    <path
                                                        d="M21.44 11.05 12.25 20.24a6 6 0 0 1-8.49-8.49l9.2-9.19a4 4 0 0 1 5.65 5.66l-9.2 9.19a2 2 0 1 1-2.83-2.83l8.49-8.48">
                                                    </path>
                                                </svg>
                                            </label>
                                            <button id="aiClearFileBtn" class="btn ghost ai-clear-inline"
                                                type="button">Clear</button>
                                        </div>
                                    </div>
                                    <input id="aiChatFile" type="file" accept="image/*,.txt,.md,.csv,.json,.svg,.pdf"
                                        style="display:none;" />
                                </div>

                                <div class="row" style="justify-content:flex-end;">
                                    <button id="aiChatSendBtn" class="btn primary" type="button">
                                        <span id="aiChatSendText">Send</span>
                                        <span id="aiChatSpinner"
                                            style="display:none;"><span>.</span><span>.</span><span>.</span></span>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="layers-content" class="panel-tab-content">
                        <div id="layersList" class="layers-list stack"></div>
                    </div>

                    <div id="elements-content" class="panel-tab-content">
                        <input type="search" id="element-search" placeholder="Search elements...">
                        <div id="elements-grid"></div>
                    </div>
                </div>
            </div>
            <div class="resizer" id="left-resizer"></div>

            <div class="canvas-container-wrapper">
                <div class="canvas-wrap"><canvas id="c"></canvas></div>
                <button id="openDataLinksManagerBtn" class="btn"
                    style="position: absolute; top: 16px; right: 16px; z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,.3);"><svg
                        width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                        <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                    </svg><span>Data Links</span></button>
                <div id="ai-bubble" class="ai-bubble" title="AI Template Assistant"><svg
                        xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                        class="lucide lucide-sparkles">
                        <path
                            d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z" />
                        <path d="M5 3v4" />
                        <path d="M19 17v4" />
                        <path d="M3 5h4" />
                        <path d="M17 19h4" />
                    </svg></div>
                <div id="canvasPagesPanel" class="canvas-pages-panel">
                    <div class="canvas-pages-header">
                        <span class="label">Canvases</span>
                        <button id="toggleCanvasPagesPanelBtn" class="btn ghost" type="button"
                            style="height: 24px; font-size: 10px; padding: 0 8px;">Collapse</button>
                    </div>
                    <div id="canvasPagesStrip" class="canvas-pages-strip"></div>
                </div>
                <div class="canvas-editor-stage">
                    <div class="canvas-wrap"><canvas id="c"></canvas></div>
                    <div id="pageActionToolbar" class="page-action-toolbar hidden"></div>
                    <button id="openDataLinksManagerBtn" class="btn"
                        style="position: absolute; top: 12px; right: 12px; z-index: 10; box-shadow: 0 4px 12px rgba(0,0,0,.3);"><svg
                            width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path>
                            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path>
                        </svg><span>Data Links</span></button>
                </div>
            </div>
            <div class="resizer" id="right-resizer"></div>
            <div class="panel right" id="right-panel">
@ -1768,58 +454,6 @@
        </div>
    </div>

    <!-- AI Assistant Modal -->
    <div id="aiModalBackdrop" class="modal-backdrop">
        <div class="modal" style="width: 500px;">
            <div class="row" style="justify-content:space-between;align-items:center;gap:12px;">
                <h3>AI Template Assistant</h3><button id="aiCloseModal" class="btn ghost"
                    style="padding: 4px 8px; line-height: 1;">&times;</button>
            </div>
            <div class="stack" style="margin-top: 16px; gap: 12px;">
                <div class="stack"><label for="aiApiKey">Google AI Studio API Key <a
                            href="https://aistudio.google.com/apikey" target="_blank" id="get-it-btn">(Get
                            it)</a></label>
                    <form autocomplete="off" onsubmit="return false;"><input type="password" id="aiApiKey"
                            placeholder="Enter your API key"></form>
                </div>
                <div class="stack"><label>Mode</label>
                    <div class="row" style="gap:8px"><label
                            style="display:flex; gap:6px; align-items:center; font-size:12px; color:var(--fg)"><input
                                id="aiModeNew" type="radio" name="aiMode" value="new" checked> New
                            template</label><label
                            style="display:flex; gap:6px; align-items:center; font-size:12px; color:var(--fg)"><input
                                id="aiModeModify" type="radio" name="aiMode" value="modify"> Modify current</label>
                    </div>
                </div>
                <div class="stack"><label for="aiPrompt">Request</label><textarea id="aiPrompt" rows="4"
                        placeholder="e.g., 'Create an invoice template with fields for item, quantity, price, and total.'"></textarea>
                </div>
                <div class="row" style="gap:8px; align-items:center;">
                    <label for="aiImageUpload" class="btn ghost" style="height:30px;">Attach Image</label>
                    <input id="aiImageUpload" type="file" accept="image/*" style="display:none;">
                    <span id="aiImageName" class="muted"
                        style="font-size:11px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width:280px;"></span>
                </div>
                <div id="pasted-image-container"
                    style="display: none; text-align: center; border: 1px solid var(--border); border-radius: 8px; padding: 8px;">
                    <div class="row" style="justify-content:space-between; align-items:center;">
                        <label id="aiImagePreviewLabel" style="margin:0;">Image Preview:</label>
                        <button id="clearAiImageBtn" type="button" class="btn ghost"
                            style="padding:2px 8px; height:24px; line-height:1;" title="Remove image">&times;</button>
                    </div>
                    <img id="pasted-image"
                        src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
                        alt="Attached Image"
                        style="max-width: 100%; max-height: 150px; border: 1px solid #ccc; padding: 5px; margin-top: 5px; object-fit: contain;">
                </div>
            </div>
            <div class="row" style="margin-top:16px; justify-content:flex-end;"><button id="aiSendBtn" class="btn"
                    style="background-color: white; color: black;"><span id="aiSendBtnText">Send Request</span><span
                        id="aiLoadingSpinner"
                        style="display: none;"><span>.</span><span>.</span><span>.</span></span></button></div>
        </div>
    </div>

    <div id="settingsModal" class="modal-backdrop">
        <div class="modal" style="width: 550px;">
            <div class="row" style="justify-content:space-between;align-items:center;gap:12px;">
@ -1923,5797 +557,7 @@

    <script type="module" src="assets/js/supabase-client.js"></script>
    <script type="module" src="assets/js/auth.js"></script>

    <script type="module">
        // --- Supabase and Auth Integration ---
        import { supabase } from './assets/js/supabase-client.js';

        // --- UTILITIES & SETUP ---
        const $ = (sel) => document.querySelector(sel);
        const $$ = (sel) => Array.from(document.querySelectorAll(sel));
        const on = (sel, evt, handler, opts) => { const el = $(sel); if (!el) return null; el.addEventListener(evt, handler, opts); return el; };
        const onClick = (sel, handler) => { const el = $(sel); if (!el) return null; el.addEventListener('click', handler); return el; };
        const setText = (sel, value) => { const el = $(sel); if (el) el.textContent = value; };

        const { jsPDF } = window.jspdf;

        // --- STATE ---
        const canvasWrapper = $('.canvas-wrap');
        // 9. Preserve layer stacking
        const canvas = new fabric.Canvas('c', { backgroundColor: 'transparent', selection: true, preserveObjectStacking: true });
        // High-quality rendering (avoid blurry output)
        canvas.enableRetinaScaling = true;
        canvas.imageSmoothingEnabled = true;

        function getDefaultSpawnPoint() {
            if (pageRect && typeof pageRect.getCenterPoint === 'function') {
                const center = pageRect.getCenterPoint();
                if (center && Number.isFinite(center.x) && Number.isFinite(center.y)) return center;
            }
            const vpCenter = canvas.getVpCenter();
            return new fabric.Point(vpCenter.x, vpCenter.y);
        }
        const DEFAULT_PAGE_WIDTH = 768;
        const DEFAULT_PAGE_HEIGHT = 1024;
        const CAMERA_BOUND_PADDING = 600;
        const SERIALIZE_PROPS = ['oid', 'name', 'isTable', 'isSvgGroup', 'rows', 'cols', 'colWidths', 'rowHeights', 'locked', 'pageId', 'headerRows', 'headerFill', 'bodyFill', 'borderColor', 'borderWidth', 'cellData', 'isArtboard'];
        let pageRect;
        let documentPages = [];
        let currentPageIndex = 0;
        let isPageSwitching = false;
        let bindings = new Map();
        let workbook, worksheet, headers = [], dataRows = [];
        let identifierColumn = '';
        let gridEnabled = false, snapEnabled = true;
        let gridCellSize = 32;
        let historyStack = [];// history snapshots
        let lastHistorySig = null;
        let historyIndex = -1;
        let historyLocked = false;
        let isRestoringHistory = false;
        let _clipboard = null;
        const FONT_LIST = ["Arial", "Helvetica", "Times New Roman", "Georgia", "Courier New", "Verdana", "Impact", "Comic Sans MS"];
        let editingFillObject = null;
        let cropCanvas, croppingImage = null;
        let currentUser = null, currentTemplateId = null, userRole = 'free';
        let pendingGuestTemplateRestore = false;
        const saveStatusEl = $('#saveStatus');
        let activeTableCellEditor = null;

        const createUid = (prefix = 'id') => `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
        const deepClone = (value) => JSON.parse(JSON.stringify(value));

        function parsePositiveInt(value, fallback) {
            const n = parseInt(value, 10);
            return Number.isFinite(n) && n > 0 ? n : fallback;
        }

        function createPageRectPayload(width = DEFAULT_PAGE_WIDTH, height = DEFAULT_PAGE_HEIGHT) {
            return {
                type: 'rect',
                version: '5.3.0',
                originX: 'left',
                originY: 'top',
                left: 0,
                top: 0,
                width,
                height,
                fill: '#ffffff',
                stroke: 'rgba(0,0,0,0.25)',
                strokeWidth: 1,
                selectable: false,
                evented: false,
                hasControls: false,
                hasBorders: false,
                lockMovementX: true,
                lockMovementY: true,
                lockScalingX: true,
                lockScalingY: true,
                lockRotation: true,
                oid: 'pageRect',
                isArtboard: true
            };
        }

        function createBlankPageState(index = 0, width = DEFAULT_PAGE_WIDTH, height = DEFAULT_PAGE_HEIGHT) {
            return {
                id: createUid('page'),
                title: `Page ${index + 1}`,
                width,
                height,
                canvas: {
                    version: '5.3.0',
                    background: 'transparent',
                    objects: [createPageRectPayload(width, height)]
                },
                bindings: []
            };
        }

        const VALID_ORIGIN_X = new Set(['left', 'center', 'right']);
        const VALID_ORIGIN_Y = new Set(['top', 'center', 'bottom']);

        function normalizeNumeric(value, fallback) {
            const n = parseFloat(value);
            return Number.isFinite(n) ? n : fallback;
        }

        function sanitizeCanvasObject(rawObject, { pageWidth = DEFAULT_PAGE_WIDTH, pageHeight = DEFAULT_PAGE_HEIGHT, depth = 0 } = {}) {
            if (!rawObject || typeof rawObject !== 'object') return null;
            const obj = { ...rawObject };

            if (!VALID_ORIGIN_X.has(obj.originX)) obj.originX = 'center';
            if (!VALID_ORIGIN_Y.has(obj.originY)) obj.originY = 'center';
            obj.left = normalizeNumeric(obj.left, pageWidth / 2);
            obj.top = normalizeNumeric(obj.top, pageHeight / 2);
            obj.scaleX = normalizeNumeric(obj.scaleX, 1) || 1;
            obj.scaleY = normalizeNumeric(obj.scaleY, 1) || 1;
            obj.angle = normalizeNumeric(obj.angle, 0);

            if (Array.isArray(obj.objects)) {
                obj.objects = obj.objects
                    .map(child => sanitizeCanvasObject(child, { pageWidth, pageHeight, depth: depth + 1 }))
                    .filter(Boolean);
            }

            if (obj.oid === 'pageRect' || obj.isArtboard) {
                obj.oid = 'pageRect';
                obj.isArtboard = true;
                obj.originX = 'left';
                obj.originY = 'top';
                obj.left = 0;
                obj.top = 0;
                obj.width = parsePositiveInt(Math.round(normalizeNumeric(obj.width, pageWidth)), pageWidth);
                obj.height = parsePositiveInt(Math.round(normalizeNumeric(obj.height, pageHeight)), pageHeight);
                obj.selectable = false;
                obj.evented = false;
                obj.hasControls = false;
                obj.hasBorders = false;
                obj.lockMovementX = true;
                obj.lockMovementY = true;
                obj.lockScalingX = true;
                obj.lockScalingY = true;
                obj.lockRotation = true;
            } else {
                if (depth === 0) {
                    const isLocked = !!obj.locked;
                    obj.locked = isLocked;
                    obj.selectable = !isLocked;
                    obj.evented = !isLocked;
                    obj.hasControls = !isLocked;
                    obj.hasBorders = !isLocked;
                    obj.lockMovementX = isLocked;
                    obj.lockMovementY = isLocked;
                    obj.lockScalingX = isLocked;
                    obj.lockScalingY = isLocked;
                    obj.lockRotation = isLocked;
                }
            }

            // Prevent accidental clipping/teleporting from AI-generated transforms.
            if (obj.clipPath) delete obj.clipPath;
            if (obj.transformMatrix) delete obj.transformMatrix;

            if (obj.type === 'textbox') {
                if (typeof obj.text !== 'string') obj.text = String(obj.text ?? '');
                if (!Number.isFinite(obj.fontSize) || obj.fontSize <= 0) obj.fontSize = 24;
                if (!Number.isFinite(obj.width) || obj.width <= 0) obj.width = 240;
                if (!obj.fontFamily) obj.fontFamily = 'Arial';
                obj.padding = 0;
            }

            if (obj.type === 'path' || obj.isSvgGroup || obj.type === 'group') {
                obj.objectCaching = false;
            }

            return obj;
        }

        function sanitizeCanvasStateForEditor(rawCanvas, { pageWidth = DEFAULT_PAGE_WIDTH, pageHeight = DEFAULT_PAGE_HEIGHT } = {}) {
            const canvasState = (rawCanvas && typeof rawCanvas === 'object') ? { ...rawCanvas } : { version: '5.3.0', background: 'transparent', objects: [] };
            if (!Array.isArray(canvasState.objects)) canvasState.objects = [];
            canvasState.version = canvasState.version || '5.3.0';
            canvasState.background = 'transparent';

            const sanitizedObjects = canvasState.objects
                .map(obj => sanitizeCanvasObject(obj, { pageWidth, pageHeight }))
                .filter(Boolean);

            let pageRectObj = sanitizedObjects.find(obj => obj.oid === 'pageRect');
            if (!pageRectObj) {
                pageRectObj = createPageRectPayload(pageWidth, pageHeight);
            } else {
                pageRectObj.width = pageWidth;
                pageRectObj.height = pageHeight;
                pageRectObj.left = 0;
                pageRectObj.top = 0;
                pageRectObj.originX = 'left';
                pageRectObj.originY = 'top';
                pageRectObj.selectable = false;
                pageRectObj.evented = false;
                pageRectObj.hasControls = false;
                pageRectObj.hasBorders = false;
                pageRectObj.lockMovementX = true;
                pageRectObj.lockMovementY = true;
                pageRectObj.lockScalingX = true;
                pageRectObj.lockScalingY = true;
                pageRectObj.lockRotation = true;
                pageRectObj.isArtboard = true;
                pageRectObj.oid = 'pageRect';
            }

            canvasState.objects = [pageRectObj, ...sanitizedObjects.filter(obj => obj.oid !== 'pageRect')];
            return canvasState;
        }

        function sanitizeBindingsEntries(rawBindings) {
            if (!Array.isArray(rawBindings)) return [];
            return rawBindings
                .filter(entry => Array.isArray(entry) && entry.length === 2)
                .map(([oid, bindingList]) => {
                    const safeOid = String(oid || '').trim();
                    if (!safeOid) return null;
                    const safeBindings = Array.isArray(bindingList)
                        ? bindingList
                            .filter(b => b && typeof b === 'object')
                            .map(b => {
                                const property = String(b.property || '').trim();
                                const column = String(b.column || '').trim();
                                if (!property) return null;
                                const next = { ...b, property, column };
                                if (property === 'Cell Text') {
                                    next.cellIndex = Number.isFinite(parseInt(next.cellIndex, 10)) ? parseInt(next.cellIndex, 10) : 0;
                                } else {
                                    delete next.cellIndex;
                                }
                                return next;
                            })
                            .filter(Boolean)
                        : [];
                    return [safeOid, safeBindings];
                })
                .filter(Boolean);
        }

        function lineEndpointPositionHandler(dim, finalMatrix, fabricObject, currentControl) {
            if (!fabricObject || fabricObject.type !== 'line') return new fabric.Point(0, 0);
            const pointKey = currentControl?.pointKey || this?.pointKey || 'end';
            const canvasPoint = getLineCanvasPoint(fabricObject, pointKey);
            if (!canvasPoint) return new fabric.Point(0, 0);
            return fabric.util.transformPoint(
                canvasPoint,
                fabricObject.canvas?.viewportTransform || [1, 0, 0, 1, 0, 0]
            );
        }

        function getLineLocalPoint(line, pointKey) {
            if (!line || line.type !== 'line') return null;
            if (typeof line.calcLinePoints === 'function') {
                const points = line.calcLinePoints();
                if (
                    points &&
                    Number.isFinite(points.x1) &&
                    Number.isFinite(points.y1) &&
                    Number.isFinite(points.x2) &&
                    Number.isFinite(points.y2)
                ) {
                    return pointKey === 'start'
                        ? new fabric.Point(points.x1, points.y1)
                        : new fabric.Point(points.x2, points.y2);
                }
            }

            const x1 = Number.isFinite(line.x1) ? line.x1 : 0;
            const y1 = Number.isFinite(line.y1) ? line.y1 : 0;
            const x2 = Number.isFinite(line.x2) ? line.x2 : x1;
            const y2 = Number.isFinite(line.y2) ? line.y2 : y1;
            const pathOffset = line.pathOffset || { x: 0, y: 0 };
            const offsetX = Number.isFinite(pathOffset.x) ? pathOffset.x : 0;
            const offsetY = Number.isFinite(pathOffset.y) ? pathOffset.y : 0;
            return pointKey === 'start'
                ? new fabric.Point(x1 - offsetX, y1 - offsetY)
                : new fabric.Point(x2 - offsetX, y2 - offsetY);
        }

        function getLineCanvasPoint(line, pointKey) {
            if (!line || line.type !== 'line') return null;
            const localPoint = getLineLocalPoint(line, pointKey);
            if (!localPoint) return null;
            const matrix = line.calcTransformMatrix();
            return fabric.util.transformPoint(localPoint, matrix);
        }

        function normalizeLineFromCanvasEndpoints(line, startPoint, endPoint) {
            if (!line || line.type !== 'line') return false;
            if (!startPoint || !endPoint) return false;
            if (!Number.isFinite(startPoint.x) || !Number.isFinite(startPoint.y) || !Number.isFinite(endPoint.x) || !Number.isFinite(endPoint.y)) return false;

            const left = Math.min(startPoint.x, endPoint.x);
            const top = Math.min(startPoint.y, endPoint.y);
            const x1 = startPoint.x;
            const y1 = startPoint.y;
            const x2 = endPoint.x;
            const y2 = endPoint.y;

            line.set({
                originX: 'center',
                originY: 'center',
                angle: 0,
                scaleX: 1,
                scaleY: 1,
                x1,
                y1,
                x2,
                y2
            });

            if (typeof line._setWidthHeight === 'function') line._setWidthHeight();
            line.setCoords();
            return true;
        }

        function snapLineEndpoint(anchorPoint, pointerPoint, enableSnap = false) {
            if (!enableSnap) return pointerPoint;
            if (!anchorPoint || !pointerPoint) return pointerPoint;

            const dx = pointerPoint.x - anchorPoint.x;
            const dy = pointerPoint.y - anchorPoint.y;
            if (!Number.isFinite(dx) || !Number.isFinite(dy)) return pointerPoint;
            if (Math.abs(dx) < 1e-6 && Math.abs(dy) < 1e-6) return pointerPoint;

            const candidates = [
                { x: dx, y: 0 },      // horizontal
                { x: 0, y: dy }       // vertical
            ];

            // slope +1 diagonal
            const t1 = (dx + dy) / 2;
            candidates.push({ x: t1, y: t1 });

            // slope -1 diagonal
            const t2 = (dx - dy) / 2;
            candidates.push({ x: t2, y: -t2 });

            let best = candidates[0];
            let bestDist = Infinity;
            for (const c of candidates) {
                const dist = (c.x - dx) * (c.x - dx) + (c.y - dy) * (c.y - dy);
                if (dist < bestDist) {
                    bestDist = dist;
                    best = c;
                }
            }

            return new fabric.Point(anchorPoint.x + best.x, anchorPoint.y + best.y);
        }

        function lineEndpointActionHandler(eventData, transform, x, y) {
            const line = transform?.target;
            if (!line || line.type !== 'line') return false;

            const canvas = line.canvas;
            if (!canvas) return false;

            const control = line.controls?.[transform.corner];
            const pointKey = control?.pointKey === 'start' ? 'start' : 'end';
            const anchorKey = pointKey === 'start' ? 'end' : 'start';
            const anchorPoint = getLineCanvasPoint(line, anchorKey);
            if (!anchorPoint) return false;

            let pointerPoint = null;
            if (Number.isFinite(x) && Number.isFinite(y)) {
                pointerPoint = new fabric.Point(x, y);
            } else {
                const pointer = canvas.getPointer(eventData);
                pointerPoint = new fabric.Point(pointer.x, pointer.y);
            }
            if (!Number.isFinite(pointerPoint.x) || !Number.isFinite(pointerPoint.y)) return false;
            pointerPoint = snapLineEndpoint(anchorPoint, pointerPoint, !!eventData?.shiftKey);

            const startPoint = pointKey === 'start' ? pointerPoint : anchorPoint;
            const endPoint = pointKey === 'start' ? anchorPoint : pointerPoint;
            normalizeLineFromCanvasEndpoints(line, startPoint, endPoint);
            line._endpointDragDirty = true;
            if (typeof requestSaveState === 'function') requestSaveState();
            line.setCoords();
            canvas.requestRenderAll();
            return true;
        }

        const LINE_ENDPOINT_CONTROLS = {
            start: new fabric.Control({
                pointKey: 'start',
                positionHandler: lineEndpointPositionHandler,
                actionHandler: lineEndpointActionHandler,
                actionName: 'modifyLineEndpoint',
                cursorStyle: 'crosshair'
            }),
            end: new fabric.Control({
                pointKey: 'end',
                positionHandler: lineEndpointPositionHandler,
                actionHandler: lineEndpointActionHandler,
                actionName: 'modifyLineEndpoint',
                cursorStyle: 'crosshair'
            })
        };

        function applyLineEndpointControls(line) {
            if (!line || line.type !== 'line' || line.excludeFromExport || line.isSnapLine) return;
            let startPoint = getLineCanvasPoint(line, 'start');
            let endPoint = getLineCanvasPoint(line, 'end');
            if (!startPoint || !endPoint) {
                const center = (typeof line.getCenterPoint === 'function')
                    ? line.getCenterPoint()
                    : new fabric.Point(
                        Number.isFinite(line.left) ? line.left : 0,
                        Number.isFinite(line.top) ? line.top : 0
                    );
                startPoint = new fabric.Point(center.x - 75, center.y);
                endPoint = new fabric.Point(center.x + 75, center.y);
            }
            if (Math.abs(startPoint.x - endPoint.x) < 0.0001 && Math.abs(startPoint.y - endPoint.y) < 0.0001) {
                endPoint = new fabric.Point(startPoint.x + 150, startPoint.y);
            }
            normalizeLineFromCanvasEndpoints(line, startPoint, endPoint);

            line.controls = LINE_ENDPOINT_CONTROLS;
            line.set({
                hasBorders: false,
                padding: 0,
                objectCaching: false,
                perPixelTargetFind: true
            });
            line.setCoords();
        }

        function applyLockStateToObject(obj) {
            if (!obj || obj.oid === 'pageRect' || obj.isArtboard) return;
            const isLocked = !!obj.locked;
            const isEditableLine = obj.type === 'line' && !obj.excludeFromExport && !obj.isSnapLine;
            obj.set({
                selectable: !isLocked,
                evented: !isLocked,
                hasControls: !isLocked,
                hasBorders: isEditableLine ? false : !isLocked,
                lockMovementX: isLocked,
                lockMovementY: isLocked,
                lockScalingX: isLocked,
                lockScalingY: isLocked,
                lockRotation: isLocked
            });
            if (isEditableLine && !isLocked) applyLineEndpointControls(obj);
        }

        function stabilizeObjectAfterLoad(obj) {
            if (!obj || obj.oid === 'pageRect' || obj.isArtboard) return;

            if (!Number.isFinite(obj.left) || !Number.isFinite(obj.top)) {
                const fallback = pageRect ? pageRect.getCenterPoint() : new fabric.Point(DEFAULT_PAGE_WIDTH / 2, DEFAULT_PAGE_HEIGHT / 2);
                obj.set({
                    left: Number.isFinite(obj.left) ? obj.left : fallback.x,
                    top: Number.isFinite(obj.top) ? obj.top : fallback.y
                });
            }
            if (!Number.isFinite(obj.scaleX) || obj.scaleX === 0) obj.scaleX = 1;
            if (!Number.isFinite(obj.scaleY) || obj.scaleY === 0) obj.scaleY = 1;

            if (obj.type === 'path') {
                obj.set({ objectCaching: false });
            }
            if (obj.type === 'line' && !obj.excludeFromExport && !obj.isSnapLine) {
                applyLineEndpointControls(obj);
            }
            if (obj.type === 'textbox') {
                obj.set({ padding: 0 });
            }

            if (obj.type === 'group' && !obj.isTable) {
                const center = obj.getCenterPoint();
                if (typeof obj.addWithUpdate === 'function') obj.addWithUpdate();
                obj.setPositionByOrigin(center, 'center', 'center');
                obj.set({ objectCaching: false });
            }

            if (obj.isSvgGroup && typeof obj.forEachObject === 'function') {
                obj.set({ objectCaching: false });
                obj.forEachObject(child => {
                    if (!child) return;
                    child.set({ objectCaching: false });
                });
            }

            applyLockStateToObject(obj);
            obj.setCoords();
        }

        function ensurePageRectInCanvasState(pageState) {
            if (!pageState.canvas || typeof pageState.canvas !== 'object') {
                pageState.canvas = { version: '5.3.0', background: 'transparent', objects: [] };
            }
            if (!Array.isArray(pageState.canvas.objects)) pageState.canvas.objects = [];
            let pr = pageState.canvas.objects.find(o => o && o.oid === 'pageRect');
            if (!pr) {
                pr = createPageRectPayload(pageState.width, pageState.height);
                pageState.canvas.objects.unshift(pr);
            } else {
                pr.width = pageState.width;
                pr.height = pageState.height;
                pr.oid = 'pageRect';
                pr.isArtboard = true;
                pr.selectable = false;
                pr.evented = false;
                pr.hasControls = false;
                pr.hasBorders = false;
                pr.lockMovementX = true;
                pr.lockMovementY = true;
                pr.lockScalingX = true;
                pr.lockScalingY = true;
                pr.lockRotation = true;
                if (pr.stroke == null) pr.stroke = 'rgba(0,0,0,0.25)';
                if (pr.strokeWidth == null) pr.strokeWidth = 1;
            }
            pageState.canvas = sanitizeCanvasStateForEditor(pageState.canvas, {
                pageWidth: pageState.width,
                pageHeight: pageState.height
            });
        }

        function normalizePageState(rawPage = {}, index = 0) {
            const width = parsePositiveInt(rawPage.width ?? rawPage.page?.width, DEFAULT_PAGE_WIDTH);
            const height = parsePositiveInt(rawPage.height ?? rawPage.page?.height, DEFAULT_PAGE_HEIGHT);
            const pageState = {
                id: rawPage.id || createUid('page'),
                title: rawPage.title || `Page ${index + 1}`,
                width,
                height,
                canvas: sanitizeCanvasStateForEditor(rawPage.canvas || { version: '5.3.0', background: 'transparent', objects: [] }, { pageWidth: width, pageHeight: height }),
                bindings: sanitizeBindingsEntries(rawPage.bindings)
            };
            ensurePageRectInCanvasState(pageState);
            return pageState;
        }

        function normalizeTemplatePages(templateData = {}) {
            if (Array.isArray(templateData.pages) && templateData.pages.length > 0) {
                const rootBindings = Array.isArray(templateData.bindings) ? templateData.bindings : [];
                const pages = templateData.pages.map((p, i) => normalizePageState({
                    ...p,
                    bindings: Array.isArray(p?.bindings) ? p.bindings : (i === 0 ? rootBindings : [])
                }, i));
                const selectedIndex = Math.min(
                    pages.length - 1,
                    Math.max(0, parseInt(templateData.currentPageIndex, 10) || 0)
                );
                return { pages, selectedIndex };
            }

            const width = parsePositiveInt(templateData.page?.width, DEFAULT_PAGE_WIDTH);
            const height = parsePositiveInt(templateData.page?.height, DEFAULT_PAGE_HEIGHT);
            const page = normalizePageState({
                id: createUid('page'),
                title: templateData.page?.title || 'Page 1',
                width,
                height,
                canvas: templateData.canvas,
                bindings: templateData.bindings
            }, 0);
            return { pages: [page], selectedIndex: 0 };
        }

        function refreshCanvasPageControls() {
            const select = $('#canvasPageSelect');
            if (!select) return;

            select.innerHTML = '';
            documentPages.forEach((page, index) => {
                const option = document.createElement('option');
                option.value = String(index);
                option.textContent = `${index + 1}. ${page.title || `Page ${index + 1}`} (${page.width}x${page.height})`;
                select.appendChild(option);
            });
            select.value = String(Math.min(currentPageIndex, Math.max(0, documentPages.length - 1)));

            const deleteBtn = $('#deleteCanvasBtn');
            if (deleteBtn) deleteBtn.disabled = documentPages.length <= 1;
        }

        function syncCurrentPageStateFromCanvas() {
            if (isPageSwitching || !documentPages[currentPageIndex]) return;
            const pageState = documentPages[currentPageIndex];
            pageState.title = pageState.title || `Page ${currentPageIndex + 1}`;
            if (pageRect) {
                pageState.width = parsePositiveInt(Math.round(pageRect.width), pageState.width || DEFAULT_PAGE_WIDTH);
                pageState.height = parsePositiveInt(Math.round(pageRect.height), pageState.height || DEFAULT_PAGE_HEIGHT);
            } else {
                pageState.width = parsePositiveInt($('#pageWidth')?.value, pageState.width || DEFAULT_PAGE_WIDTH);
                pageState.height = parsePositiveInt($('#pageHeight')?.value, pageState.height || DEFAULT_PAGE_HEIGHT);
            }
            pageState.canvas = canvas.toJSON(SERIALIZE_PROPS);
            pageState.bindings = Array.from(bindings.entries());
            ensurePageRectInCanvasState(pageState);
        }

        function pageHasRenderableObjects(pageState) {
            const objects = pageState?.canvas?.objects || [];
            return objects.some(o => o && o.oid !== 'pageRect' && !o.excludeFromExport && !o.isSnapLine);
        }

        function buildTemplatePayload() {
            syncCurrentPageStateFromCanvas();
            if (!documentPages.length) {
                documentPages = [createBlankPageState(0, DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT)];
                currentPageIndex = 0;
            }

            const clonedPages = deepClone(documentPages);
            const activePage = clonedPages[currentPageIndex] || clonedPages[0];

            return {
                page: {
                    title: $('#titleInput').value || 'Untitled_Template',
                    width: activePage?.width || DEFAULT_PAGE_WIDTH,
                    height: activePage?.height || DEFAULT_PAGE_HEIGHT
                },
                canvas: activePage?.canvas || { version: '5.3.0', background: 'transparent', objects: [] },
                bindings: activePage?.bindings || [],
                pages: clonedPages,
                currentPageIndex,
                data: { headers, rows: dataRows, identifierColumn: identifierColumn || '' }
            };
        }

        function switchToCanvasPage(index, { fitView = false, skipSave = false, suppressHistory = false } = {}) {
            return new Promise((resolve) => {
                if (!documentPages[index]) {
                    resolve(false);
                    return;
                }

                if (!skipSave) syncCurrentPageStateFromCanvas();

                const nextPage = documentPages[index];
                const priorHistoryLock = historyLocked;
                currentPageIndex = index;
                isPageSwitching = true;
                historyLocked = true;
                bindings = new Map(nextPage.bindings || []);

                const finalizeSwitch = (ok) => {
                    historyLocked = priorHistoryLock;
                    isPageSwitching = false;
                    resolve(!!ok);
                };

                canvas.discardActiveObject();
                try {
                    canvas.loadFromJSON(nextPage.canvas, () => {
                        try {
                            restoreCanvasStateAfterLoad(() => {
                                pageRect = canvas.getObjects().find(o => o.oid === 'pageRect');
                                if (pageRect) {
                                    pageRect.set({
                                        width: nextPage.width,
                                        height: nextPage.height,
                                        selectable: false,
                                        evented: false,
                                        hasControls: false,
                                        hasBorders: false,
                                        lockMovementX: true,
                                        lockMovementY: true,
                                        lockScalingX: true,
                                        lockScalingY: true,
                                        lockRotation: true,
                                        isArtboard: true
                                    });
                                    pageRect.setCoords();
                                }

                                $('#pageWidth').value = nextPage.width;
                                $('#pageHeight').value = nextPage.height;
                                refreshCanvasPageControls();
                                keepPageRectAtBack();
                                drawGrid();
                                renderLayers();
                                renderPageInspector();

                                if (fitView) centerAndFitPage();
                                else {
                                    clampViewportTransform(canvas.viewportTransform);
                                    canvas.requestRenderAll();
                                }

                                finalizeSwitch(true);
                            });
                        } catch (error) {
                            console.error('Failed during page restore:', error);
                            finalizeSwitch(false);
                        }
                    });
                } catch (error) {
                    console.error('Failed to load page JSON:', error);
                    finalizeSwitch(false);
                }
            });
        }

        async function addCanvasPage() {
            syncCurrentPageStateFromCanvas();
            const baseW = parsePositiveInt($('#pageWidth').value, DEFAULT_PAGE_WIDTH);
            const baseH = parsePositiveInt($('#pageHeight').value, DEFAULT_PAGE_HEIGHT);
            const newPage = createBlankPageState(documentPages.length, baseW, baseH);
            documentPages.push(newPage);
            refreshCanvasPageControls();
            await switchToCanvasPage(documentPages.length - 1, { fitView: true, skipSave: true, suppressHistory: true });
            requestSaveState();
        }

        async function duplicateCanvasPage() {
            syncCurrentPageStateFromCanvas();
            if (!documentPages[currentPageIndex]) return;

            const clone = deepClone(documentPages[currentPageIndex]);
            clone.id = createUid('page');
            clone.title = `${clone.title || `Page ${currentPageIndex + 1}`} Copy`;
            const insertAt = currentPageIndex + 1;
            documentPages.splice(insertAt, 0, normalizePageState(clone, insertAt));
            refreshCanvasPageControls();
            await switchToCanvasPage(insertAt, { fitView: true, skipSave: true, suppressHistory: true });
            requestSaveState();
        }

        async function deleteCanvasPage() {
            if (documentPages.length <= 1) return;
            if (!confirm('Delete the current canvas page?')) return;

            syncCurrentPageStateFromCanvas();
            const nextIndex = Math.max(0, currentPageIndex - 1);
            documentPages.splice(currentPageIndex, 1);
            refreshCanvasPageControls();
            await switchToCanvasPage(nextIndex, { fitView: true, skipSave: true, suppressHistory: true });
            requestSaveState();
        }

        async function setDocumentPagesFromTemplate(templateData = {}, options = {}) {
            const normalized = normalizeTemplatePages(templateData);
            documentPages = normalized.pages;
            currentPageIndex = typeof options.selectedIndex === 'number'
                ? Math.min(documentPages.length - 1, Math.max(0, options.selectedIndex))
                : normalized.selectedIndex;
            refreshCanvasPageControls();
            await switchToCanvasPage(currentPageIndex, {
                fitView: options.fitView !== false,
                skipSave: true,
                suppressHistory: true
            });
        }

        window.createLemonSqueezy();
        LemonSqueezy.Setup({ eventHandler: (event) => { if (event.event === 'Checkout.Success') console.log('Checkout successful!', event.data); } });

        // --- DEBOUNCE UTILITY ---
        function debounce(func, delay = 1500) {
            let timeout = null;
            let lastArgs = null;
            let lastThis = null;
            const debounced = function (...args) {
                lastArgs = args;
                lastThis = this;
                if (timeout) clearTimeout(timeout);
                timeout = setTimeout(() => {
                    timeout = null;
                    const argsToUse = lastArgs || [];
                    const thisToUse = lastThis;
                    lastArgs = null;
                    lastThis = null;
                    func.apply(thisToUse, argsToUse);
                }, delay);
            };
            debounced.clear = () => {
                if (timeout) clearTimeout(timeout);
                timeout = null;
                lastArgs = null;
                lastThis = null;
            };
            debounced.flush = () => {
                if (!timeout) return false;
                clearTimeout(timeout);
                timeout = null;
                const argsToUse = lastArgs || [];
                const thisToUse = lastThis;
                lastArgs = null;
                lastThis = null;
                func.apply(thisToUse, argsToUse);
                return true;
            };
            debounced.pending = () => !!timeout;
            return debounced;
        }

        const escapeHtml = (str) => {
            if (typeof str !== 'string') return str;
            return str.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]));
        };

        function renderCsvView(filterText = '') {
            const wrap = $('#csvViewContent');
            const dropZone = $('#csvDropZone');
            const meta = $('#csvViewMeta');
            if (!wrap) return;

            if (!headers || headers.length === 0 || !dataRows || dataRows.length === 0) {
                wrap.style.display = 'none';
                if (dropZone) dropZone.style.display = 'flex';
                if (meta) meta.textContent = '';
                return;
            }

            if (dropZone) dropZone.style.display = 'none';
            wrap.style.display = 'block';

            const q = (filterText || '').toLowerCase().trim();
            const visibleIndices = [];
            dataRows.forEach((r, i) => {
                if (!q || headers.some(h => String(r[h] ?? '').toLowerCase().includes(q))) visibleIndices.push(i);
            });

            if (meta) meta.textContent = `${dataRows.length.toLocaleString()} row(s) • ${headers.length} column(s)`;

            const maxRows = Math.min(200, visibleIndices.length);
            let html = `<table style="width:100%; border-collapse:collapse; font-size:12px; border-style: hidden;">`;

            // Headers
            html += '<thead><tr>';
            headers.forEach((h, i) => {
                html += `<th style="position:sticky; top:0; background:var(--panel-2); border-bottom:1px solid var(--border); border-right:1px solid var(--border); padding:0; text-align:left; min-width:140px; z-index: 10;">
        <div style="display:flex; align-items:center; group">
          <div contenteditable="true" onblur="updateHeader(${i}, this.innerText)" style="flex:1; padding:12px; outline:none; font-weight: 600; color: var(--fg); overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${escapeHtml(String(h))}</div>
          <button onclick="deleteColumn(${i})" style="background:none; border:none; color:var(--muted); cursor:pointer; padding:8px 12px; font-size:16px; transition: color 0.2s;" onmouseover="this.style.color='var(--danger)'" onmouseout="this.style.color='var(--muted)'" title="Delete Column">&times;</button>
        </div>
      </th>`;
            });
            // Add column button in header
            html += `<th style="position:sticky; top:0; background:var(--panel-2); border-bottom:1px solid var(--border); width:50px; text-align:center; z-index: 10;">
    <button onclick="document.getElementById('addColBtn').click()" class="btn ghost" style="width:32px; height:32px; padding:0; border-radius:50%; border: 1px dashed var(--border); color: var(--muted);" title="Add Column">+</button>
  </th>`;
            html += '</tr></thead>';

            html += '<tbody>';
            for (let i = 0; i < maxRows; i++) {
                const dataIndex = visibleIndices[i];
                const row = dataRows[dataIndex] || {};
                html += `<tr style="transition: background 0.1s;" onmouseover="this.style.background='rgba(59,130,246,0.03)'" onmouseout="this.style.background='transparent'">` + headers.map((h, colIndex) => {
                    const val = escapeHtml(String(row[h] ?? ''));
                    return `<td contenteditable="true" 
            data-row-index="${dataIndex}" data-col-index="${colIndex}"
            onblur="updateCsvCell(${dataIndex}, '${escapeHtml(h)}', this.innerText)" 
            style="border-bottom:1px solid var(--border); border-right:1px solid var(--border); padding:10px 12px; color:var(--fg); outline:none; max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; cursor: text; user-select: text;">${val}</td>`;
                }).join('') + `
      <td style="border-bottom:1px solid var(--border); text-align:center;">
        <button onclick="deleteRow(${dataIndex})" style="background:none; border:none; color:var(--muted); cursor:pointer; font-size:18px; padding: 4px 10px; transition: color 0.2s;" onmouseover="this.style.color='var(--danger)'" onmouseout="this.style.color='var(--muted)'" title="Delete Row">&times;</button>
      </td>
    </tr>`;
            }

            // Last row for "Add Row" button
            html += `<tr>
    <td colspan="${headers.length}" style="padding: 0; border-bottom:1px solid var(--border);">
      <button onclick="document.getElementById('addRowBtn').click()" style="width:100%; height:44px; background:transparent; border:none; color:var(--muted); cursor:pointer; font-size:13px; font-weight:500; transition: all 0.2s; display: flex; align-items:center; justify-content:center; gap: 8px;" onmouseover="this.style.background='rgba(59,130,246,0.05)'; this.style.color='var(--accent)'" onmouseout="this.style.background='transparent'; this.style.color='var(--muted)'"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg> Add Row</button>
    </td>
    <td style="border-bottom:1px solid var(--border);"></td>
  </tr>`;

            html += '</tbody></table>';

            if (visibleIndices.length > maxRows) {
                html += `<div class="muted" style="padding:16px; text-align:center; background: var(--panel); border-top: 1px solid var(--border);">Showing first ${maxRows} rows of ${visibleIndices.length.toLocaleString()}. Use search to refine.</div>`;
            }
            wrap.innerHTML = html;

            // Add paste listener for Excel support
            wrap.querySelectorAll('td[contenteditable="true"]').forEach(cell => {
                cell.addEventListener('paste', handleCsvCellPaste);
            });
        }

        async function handleCsvCellPaste(e) {
            const text = e.clipboardData.getData('text/plain');
            if (!text || (!text.includes('\t') && !text.includes('\n'))) return;

            e.preventDefault();
            const rows = text.split(/\r?\n/).filter(line => line.length > 0).map(line => line.split('\t'));
            const startCell = e.target;
            const startRowIndex = parseInt(startCell.dataset.rowIndex);
            const startColIndex = parseInt(startCell.dataset.colIndex);

            if (isNaN(startRowIndex) || isNaN(startColIndex)) return;

            rows.forEach((row, rOffset) => {
                const targetRowIndex = startRowIndex + rOffset;
                if (targetRowIndex >= dataRows.length) return;

                row.forEach((value, cOffset) => {
                    const targetColIndex = startColIndex + cOffset;
                    if (targetColIndex >= headers.length) return;
                    const colKey = headers[targetColIndex];
                    dataRows[targetRowIndex][colKey] = value.trim();
                });
            });

            renderCsvView($('#csvViewSearch')?.value);
            requestSaveState();
        }

        window.updateCsvCell = (rowIndex, colKey, newVal) => {
            if (dataRows[rowIndex]) {
                dataRows[rowIndex][colKey] = newVal;
                requestSaveState();
            }
        };

        window.updateHeader = (index, newVal) => {
            const oldVal = headers[index];
            if (oldVal === newVal || !newVal.trim()) return;
            newVal = newVal.trim();
            headers[index] = newVal;
            dataRows.forEach(row => {
                row[newVal] = row[oldVal];
                delete row[oldVal];
            });
            bindings.forEach((b) => { if (b.column === oldVal) b.column = newVal; });
            renderCsvView();
            requestSaveState();
        };

        window.deleteRow = (index) => {
            dataRows.splice(index, 1);
            renderCsvView($('#csvViewSearch')?.value);
            requestSaveState();
        };

        window.deleteColumn = (index) => {
            const colName = headers[index];
            if (confirm(`Delete column "${colName}" and all its data?`)) {
                headers.splice(index, 1);
                dataRows.forEach(row => delete row[colName]);
                // Also remove bindings
                bindings.forEach((bArr, oid) => {
                    const filtered = bArr.filter(b => b.column !== colName);
                    bindings.set(oid, filtered);
                });
                renderCsvView($('#csvViewSearch')?.value);
                requestSaveState();
            }
        };

        on('#addRowBtn', 'click', () => {
            if (!headers.length) headers = ['Column 1', 'Column 2', 'Column 3'];
            const newRow = {};
            headers.forEach(h => newRow[h] = '');
            dataRows.push(newRow);
            renderCsvView($('#csvViewSearch')?.value);
            requestSaveState();
        });

        on('#addColBtn', 'click', () => {
            const newColName = prompt('Enter new column name:', `Column ${headers.length + 1}`);
            if (!newColName) return;
            if (headers.includes(newColName)) { alert('Column already exists.'); return; }
            headers.push(newColName);
            dataRows.forEach(r => r[newColName] = '');
            renderCsvView($('#csvViewSearch')?.value);
            requestSaveState();
        });

        on('#clearDataBtn', 'click', () => {
            if (confirm('Are you sure you want to clear all data? This will also remove your column headers.')) {
                headers = [];
                dataRows = [];
                renderCsvView();
                requestSaveState();
            }
        });

        on('#csvViewSearch', 'input', (e) => {
            renderCsvView(e.target.value);
        });

        // Paste Handler for CSV Modal
        window.addEventListener('paste', (e) => {
            if ($('#csvViewModal').style.display !== 'flex') return;
            if (e.target.tagName === 'INPUT' || e.target.contentEditable === 'true') return;

            e.preventDefault();
            const clipboardData = e.clipboardData || window.clipboardData;
            const pastedData = clipboardData.getData('Text');
            if (!pastedData) return;

            const rows = pastedData.trim().split('\n').map(r => r.split('\t'));
            if (rows.length === 0) return;

            if (headers.length === 0) {
                headers = rows[0].map((h, i) => h.trim() || `Col ${i + 1}`);
                const count = {};
                headers = headers.map(h => { count[h] = (count[h] || 0) + 1; return count[h] > 1 ? `${h}_${count[h]}` : h; });
                rows.shift();
            }

            rows.forEach(r => {
                const rowObj = {};
                headers.forEach((h, i) => { rowObj[h] = r[i] ? r[i].trim() : ''; });
                dataRows.push(rowObj);
            });

            renderCsvView($('#csvViewSearch')?.value);
            requestSaveState();
            showNotification(`Imported ${rows.length} rows from clipboard.`);
        });

        // Drag & Drop Handler for CSV Modal
        on('#csvViewModal', 'dragover', (e) => {
            e.preventDefault();
            $('#csvDropZone').style.borderColor = 'var(--accent)';
            $('#csvDropZone').style.background = 'rgba(59, 130, 246, 0.05)';
        });
        on('#csvViewModal', 'dragleave', (e) => {
            e.preventDefault();
            $('#csvDropZone').style.borderColor = 'var(--border)';
            $('#csvDropZone').style.background = 'rgba(255, 255, 255, 0.02)';
        });
        on('#csvViewModal', 'drop', async (e) => {
            e.preventDefault();
            $('#csvDropZone').style.borderColor = 'var(--border)';
            $('#csvDropZone').style.background = 'rgba(255, 255, 255, 0.02)';
            const file = e.dataTransfer.files[0];
            if (file && (file.name.endsWith('.csv') || file.name.endsWith('.xlsx') || file.name.endsWith('.xls'))) {
                const data = await file.arrayBuffer();
                processFileData(data, file.name);
                await cacheDataFile(file);
            } else {
                showNotification('Please drop a valid CSV or Excel file.', 'error');
            }
        });

        function openCsvView() {
            const modal = $('#csvViewModal');
            if (!modal) return;
            modal.style.display = 'flex';
            renderCsvView($('#csvViewSearch')?.value);
        }

        function closeCsvView() { $('#csvViewModal').style.display = 'none'; }
        // --- AUTH & DATA LOADING ---
        async function initializeEditor() {
            applyTheme(localStorage.getItem('csvlink-theme') || 'dark');
            const { data: { session } } = await supabase.auth.getSession();
            currentUser = session?.user;

            const navLinks = $('#nav-links');
            if (currentUser) {
                const { data: profile } = await supabase.from('profiles').select('role').eq('id', currentUser.id).single();
                if (profile) userRole = profile.role || 'free';
                // 6. Add "Become Pro" button
                if (userRole === 'free' && !navLinks.querySelector('a[href="/#pricing"]')) {
                    const proButton = document.createElement('a');
                    proButton.href = '/#pricing';
                    proButton.className = 'btn ghost';
                    proButton.innerHTML = '★ Pricing';
                    navLinks.insertBefore(proButton, navLinks.firstChild);
                }
            } else {
                if (!navLinks.querySelector('a[href="/#pricing"]')) {
                    const proButton = document.createElement('a');
                    proButton.href = '/#pricing';
                    proButton.className = 'btn ghost';
                    proButton.innerHTML = '★ Pricing';
                    navLinks.insertBefore(proButton, navLinks.firstChild);
                }
            }
            updateExportUI();

            const urlParams = new URLSearchParams(window.location.search);
            const templateId = urlParams.get('id');

            initializeCanvas();
            updateHistoryButtons();
            initializeVisualCropper();
            renderPageInspector();
            await loadCachedData();

            const guestTemplate = localStorage.getItem('csvlink-guest-template');

            /* 1) PRIORITY: Template ID from URL always wins */
            if (templateId) {
                await loadTemplateFromDB(templateId);
                centerAndFitPage();
            }

            /* 2) User logged in â†’ try restore guest work */
            else if (currentUser && guestTemplate) {
                try {
                    const template = JSON.parse(guestTemplate);
                    $('#titleInput').value = template.title || template.page?.title || 'Untitled_Template';
                    if (template.data) {
                        headers = template.data.headers || [];
                        dataRows = template.data.rows || [];
                    }
                    await setDocumentPagesFromTemplate(template, { fitView: true });
                    historyStack = [];
                    historyIndex = -1;
                    lastHistorySig = null;
                    renderCsvView();
                    updateExportUI();
                    pendingGuestTemplateRestore = true;
                    requestSaveState();
                    saveStatusEl.textContent = 'Restored from guest session. Saving...';
                } catch (err) {
                    console.error('Failed to restore guest template:', err);
                }
            }

            /* 3) Guest user with no templateId â†’ autosave guest mode */
            else if (!currentUser) {
                showGuestWarning();
                centerAndFitPage();
                setInterval(saveGuestTemplate, 10000);
            }

            /* 4) Logged in user, blank editor */
            else {
                centerAndFitPage();
            }

            /* Other UI initialization */
            if (!localStorage.getItem('hasSeenTour')) startTour();
            initializeLeftPanelTabs();

            // Bind Load Template buttons
            const bindLoader = (id) => on(id, 'click', (e) => toggleTemplateLoader(e.currentTarget));
            bindLoader('#loadTemplateBtnPage');
            bindLoader('#openLoaderFromSidebar');
            bindLoader('#toolbarLoadTemplateBtn');
        }

        function showGuestWarning() { saveStatusEl.textContent = "Log in to save your work."; saveStatusEl.style.color = '#ff9800'; }

        function saveGuestTemplate() {
            if (currentUser) return; // Only save if guest
            const payload = buildTemplatePayload();
            const hasAnyContent = payload.pages.some(page => pageHasRenderableObjects(page));
            if (!hasAnyContent) return;

            const guestTemplate = {
                title: $('#titleInput').value,
                ...payload
            };

            try {
                localStorage.setItem('csvlink-guest-template', JSON.stringify(guestTemplate));
                saveStatusEl.textContent = "Guest work auto-saved locally. Log in to save to cloud.";
            } catch (err) {
                console.error('Failed to save guest template:', err);
            }
        }
        async function loadTemplateFromDB(templateId, options = {}) {
            saveStatusEl.textContent = 'Loading...';
            const isPublic = options.public;
            let data = null;

            if (isPublic) {
                const { data: publicData, error: publicError } = await supabase.from('public_templates').select('id, title, template_data').eq('id', templateId).single();
                if (publicError) { console.error('Error loading public template:', publicError); return; }
                data = publicData;
                currentTemplateId = null;
            } else {
                if (!currentUser) { return; }
                const sourceTable = options.purchased ? 'purchased_templates' : 'templates';
                const query = options.purchased
                    ? supabase.from(sourceTable).select('store_templates(id, title, template_data)').eq('user_id', currentUser.id).eq('template_id', templateId).single()
                    : supabase.from(sourceTable).select('id, title, template_data').eq('id', templateId).eq('user_id', currentUser.id).single();

                const { data: privateData, error: privateError } = await query;

                if (privateError) { console.error('Error or template not found:', privateError); return; }
                data = options.purchased ? privateData.store_templates : privateData;
                currentTemplateId = options.purchased ? null : data.id;
            }

            if (data && data.template_data) {
                const template = data.template_data;
                if (template.data) {
                    headers = template.data.headers || [];
                    dataRows = template.data.rows || [];
                    identifierColumn = template.data.identifierColumn || '';
                    refreshIdentifierDropdown();
                }
                $('#titleInput').value = isPublic || options.purchased
                    ? `Copy of ${data.title}`
                    : (data.title || template.page?.title || 'Untitled Template');
                await setDocumentPagesFromTemplate(template, { fitView: true, selectedIndex: template.currentPageIndex });
                bindings = new Map(documentPages[currentPageIndex]?.bindings || template.bindings || []);
                historyStack = [];
                historyIndex = -1;
                lastHistorySig = null;
                requestSaveState();
                renderCsvView();
                updateExportUI();
                if (headers.length > 0) {
                    $('#fileName').textContent = 'Saved Data';
                    $('#unloadDataBtn').style.display = 'inline';
                }
                saveStatusEl.textContent = 'Template loaded.';
            }
        }


        const debouncedSave = debounce(async () => {
            if (!currentUser || historyLocked) return;
            const fullTemplateData = buildTemplatePayload();
            if (!fullTemplateData.pages.some(page => pageHasRenderableObjects(page))) {
                saveStatusEl.textContent = 'Cannot save empty template.';
                return;
            }

            saveStatusEl.textContent = 'Saving...';

            if (currentTemplateId) {
                const { error } = await supabase.from('templates').update({ title: $('#titleInput').value, template_data: fullTemplateData }).eq('id', currentTemplateId);
                if (error) { saveStatusEl.textContent = 'Error saving.'; } else { saveStatusEl.textContent = 'All changes saved.'; }
            } else {
                if (userRole === 'free') { const { count } = await supabase.from('templates').select('*', { count: 'exact', head: true }).eq('user_id', currentUser.id); if (count >= 5) { saveStatusEl.textContent = 'Free account limit (5 templates) reached.'; return; } }
                const { data, error } = await supabase.from('templates').insert({ user_id: currentUser.id, title: $('#titleInput').value, template_data: fullTemplateData }).select('id').single();
                if (error) { saveStatusEl.textContent = 'Error creating template.'; }
                else {
                    currentTemplateId = data.id;
                    if (pendingGuestTemplateRestore) {
                        localStorage.removeItem('csvlink-guest-template');
                        pendingGuestTemplateRestore = false;
                    }
                    const newUrl = `${window.location.pathname}?id=${currentTemplateId}`;
                    window.history.replaceState({ path: newUrl }, '', newUrl);
                    saveStatusEl.textContent = 'Template saved to your account.';
                }
            }
        });

        function flushPendingSaves() {
            if (typeof requestSaveState.flush === 'function') requestSaveState.flush();
            if (currentUser && typeof debouncedSave.flush === 'function') debouncedSave.flush();
        }

        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState !== 'hidden') return;
            commitPendingLineEndpointEdits();
            flushPendingSaves();
        });
        window.addEventListener('pagehide', () => {
            commitPendingLineEndpointEdits();
            flushPendingSaves();
        });

        function updateHistoryButtons() {
            const undoBtn = $('#undoBtn');
            const redoBtn = $('#redoBtn');
            if (undoBtn) undoBtn.disabled = historyIndex <= 0;
            if (redoBtn) redoBtn.disabled = historyIndex >= historyStack.length - 1;
        }

        function undo() {
            if (historyLocked) return;
            if (typeof requestSaveState.flush === 'function') requestSaveState.flush();
            if (historyIndex <= 0 || historyLocked) return;
            if (typeof requestSaveState.clear === 'function') requestSaveState.clear();
            historyLocked = true;
            isRestoringHistory = true;
            historyIndex--;
            const state = historyStack[historyIndex];

            // Safety timeout to prevent lockup
            const lockTimeout = setTimeout(() => {
                historyLocked = false;
                isRestoringHistory = false;
            }, 3000);

            restoreFullState(state, () => {
                clearTimeout(lockTimeout);
                historyLocked = false;
                setTimeout(() => { isRestoringHistory = false; }, 0);
                updateHistoryButtons();
            });
        }

        function redo() {
            if (historyLocked) return;
            if (historyIndex >= historyStack.length - 1 || historyLocked) return;
            if (typeof requestSaveState.clear === 'function') requestSaveState.clear();
            historyLocked = true;
            isRestoringHistory = true;
            historyIndex++;
            const state = historyStack[historyIndex];

            // Safety timeout to prevent lockup
            const lockTimeout = setTimeout(() => {
                historyLocked = false;
                isRestoringHistory = false;
            }, 3000);

            restoreFullState(state, () => {
                clearTimeout(lockTimeout);
                historyLocked = false;
                setTimeout(() => { isRestoringHistory = false; }, 0);
                updateHistoryButtons();
            });
        }

        function restoreFullState(state, callback) {
            if (!state) {
                if (typeof callback === 'function') callback();
                return;
            }
            headers = [...(state.data?.headers || [])];
            dataRows = JSON.parse(JSON.stringify(state.data?.rows || []));
            identifierColumn = state.data?.identifierColumn || '';
            if (state.title !== undefined) $('#titleInput').value = state.title;

            const legacyState = {
                page: {
                    title: state.title || $('#titleInput').value,
                    width: state.page?.width || DEFAULT_PAGE_WIDTH,
                    height: state.page?.height || DEFAULT_PAGE_HEIGHT
                },
                canvas: state.canvas,
                bindings: state.bindings || []
            };

            const payload = state.pages
                ? {
                    page: legacyState.page,
                    pages: state.pages,
                    currentPageIndex: state.currentPageIndex || 0
                }
                : legacyState;

            setDocumentPagesFromTemplate(payload, {
                fitView: false,
                selectedIndex: state.currentPageIndex || 0
            }).then(() => {
                bindings = new Map(documentPages[currentPageIndex]?.bindings || state.bindings || []);
                renderLayers();
                renderCsvView();
                updateExportUI();

                lastHistorySig = JSON.stringify(state);
                if (typeof callback === 'function') callback();
            }).catch((error) => {
                console.error('Failed to restore history state:', error);
                if (typeof callback === 'function') callback();
            });
        }

        const requestSaveState = debounce(() => {
            if (historyLocked || isRestoringHistory) return;
            syncCurrentPageStateFromCanvas();
            if (!documentPages.length) return;

            const activePage = documentPages[currentPageIndex];
            const snap = {
                canvas: deepClone(activePage.canvas),
                data: {
                    headers: [...headers],
                    rows: JSON.parse(JSON.stringify(dataRows)),
                    identifierColumn: identifierColumn || ''
                },
                bindings: deepClone(activePage.bindings || Array.from(bindings.entries())),
                pages: deepClone(documentPages),
                currentPageIndex,
                title: $('#titleInput').value,
                page: { width: activePage.width, height: activePage.height }
            };

            const sig = JSON.stringify(snap);
            if (sig === lastHistorySig) {
                updateHistoryButtons();
                return;
            }

            if (historyIndex < historyStack.length - 1) {
                historyStack.splice(historyIndex + 1);
            }

            lastHistorySig = sig;
            historyStack.push(snap);
            const MAX_HISTORY = 40;
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }
            historyIndex = historyStack.length - 1;
            updateHistoryButtons();

            if (currentUser) {
                saveStatusEl.textContent = 'Unsaved changes...';
                debouncedSave();
            }

            // Persist data edits to localStorage for session persistence
            cacheLocalDataState();
        }, 500);

        function commitPendingLineEndpointEdits() {
            let hadPendingEndpointEdit = false;
            canvas.getObjects('line').forEach(line => {
                if (line && line._endpointDragDirty) {
                    delete line._endpointDragDirty;
                    hadPendingEndpointEdit = true;
                }
            });
            if (!hadPendingEndpointEdit) return;
            requestSaveState();
            if (typeof requestSaveState.flush === 'function') requestSaveState.flush();
            if (currentUser && typeof debouncedSave.flush === 'function') debouncedSave.flush();
        }

        // --- CANVAS & PAGE SETUP ---
        function initializeCanvas() {
            fabric.Object.prototype.set({ transparentCorners: false, cornerStyle: 'circle', cornerColor: '#000000', cornerSize: 10, borderColor: '#000000', borderScaleFactor: 1, padding: 0, strokeUniform: true });
            fabric.ActiveSelection.prototype.set({ cornerStyle: 'circle', cornerColor: '#000000', borderColor: 'black', padding: 0 });
            const resizeCanvas = () => {
                const { width, height } = canvasWrapper.getBoundingClientRect();
                canvas.setWidth(width);
                canvas.setHeight(height);
                clampViewportTransform(canvas.viewportTransform);
                canvas.renderAll();
            };
            pageRect = new fabric.Rect({
                left: 0,
                top: 0,
                width: DEFAULT_PAGE_WIDTH,
                height: DEFAULT_PAGE_HEIGHT,
                fill: '#fff',
                stroke: 'rgba(0,0,0,0.25)',
                strokeWidth: 1,
                selectable: false,
                evented: false,
                hasControls: false,
                hasBorders: false,
                lockMovementX: true,
                lockMovementY: true,
                lockScalingX: true,
                lockScalingY: true,
                lockRotation: true,
                oid: 'pageRect',
                isArtboard: true
            });
            canvas.add(pageRect);
            resizeCanvas();
            drawGrid();
            new ResizeObserver(resizeCanvas).observe(canvasWrapper);

            documentPages = [normalizePageState({
                id: createUid('page'),
                title: 'Page 1',
                width: DEFAULT_PAGE_WIDTH,
                height: DEFAULT_PAGE_HEIGHT,
                canvas: canvas.toJSON(SERIALIZE_PROPS),
                bindings: []
            }, 0)];
            currentPageIndex = 0;
            refreshCanvasPageControls();

            canvas.on({
                'object:added': () => { requestSaveState(); renderLayers(); },
                'object:removed': () => { requestSaveState(); renderLayers(); },
                'object:modified': (e) => { requestSaveState(); if (e.target) { refreshInspector({ target: e.target }); } },
                'object:moving': (e) => {
                    if (e?.transform?.action !== 'modifyLineEndpoint') handleSmartSnapping(e);
                    updateFloatingLinkerPosition(e.target);
                },
                'object:scaling': (e) => {
                    const obj = e.target;
                    if (obj && obj.type === 'textbox') {
                        const newFontSize = Math.round(obj.fontSize * obj.scaleX);
                        const newWidth = obj.width * obj.scaleX;
                        obj.set({
                            fontSize: newFontSize,
                            width: newWidth,
                            scaleX: 1,
                            scaleY: 1
                        });
                    }
                    updateLiveInspector(e);
                    updateFloatingLinkerPosition(e.target);
                },
                'object:rotating': (e) => { updateLiveInspector(e); updateFloatingLinkerPosition(e.target); },
                'mouse:up': () => {
                    clearSnapLines();
                    commitPendingLineEndpointEdits();
                } // 7. Clear guides on mouse up
            });
            requestSaveState(); renderLayers();
            addWheelPanFix();

            onClick('#undoBtn', undo);
            onClick('#redoBtn', redo);
            on('#canvasPageSelect', 'change', async (e) => {
                const targetIndex = parseInt(e.target.value, 10);
                if (Number.isNaN(targetIndex) || targetIndex === currentPageIndex) return;
                await switchToCanvasPage(targetIndex, { fitView: true });
                requestSaveState();
            });
            onClick('#addCanvasBtn', () => { addCanvasPage(); });
            onClick('#duplicateCanvasBtn', () => { duplicateCanvasPage(); });
            onClick('#deleteCanvasBtn', () => { deleteCanvasPage(); });
        }

        function keepPageRectAtBack() {
            if (!pageRect) return;
            canvas.sendToBack(pageRect);
        }

        window.addEventListener('paste', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return; const items = e.clipboardData.items; if (!items) return;
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type.indexOf('image') !== -1) { e.preventDefault(); const blob = item.getAsFile(); const reader = new FileReader(); reader.onload = (event) => { const spawn = getDefaultSpawnPoint(); adders.image(spawn.x, spawn.y, event.target.result); }; reader.readAsDataURL(blob); break; }
                if (item.type.indexOf('text/plain') !== -1) { e.preventDefault(); item.getAsString((text) => { const spawn = getDefaultSpawnPoint(); adders.text(spawn.x, spawn.y, text); }); break; }
            }
        });
        const setPageDimensions = debounce(() => {
            if (!pageRect) return;
            const w = parsePositiveInt($('#pageWidth').value, DEFAULT_PAGE_WIDTH);
            const h = parsePositiveInt($('#pageHeight').value, DEFAULT_PAGE_HEIGHT);
            pageRect.set({ width: w, height: h });
            canvas.centerObject(pageRect);
            pageRect.setCoords();
            if (documentPages[currentPageIndex]) {
                documentPages[currentPageIndex].width = w;
                documentPages[currentPageIndex].height = h;
            }
            refreshCanvasPageControls();
            drawGrid();
            clampViewportTransform(canvas.viewportTransform);
            canvas.renderAll();
            requestSaveState();
        }, 300);
        on('#titleInput', 'input', () => { requestSaveState(); }); on('#pageWidth', 'input', setPageDimensions); on('#pageHeight', 'input', setPageDimensions);
        function drawGrid() { canvas.remove(...canvas.getObjects('line').filter(o => o.excludeFromExport)); if (!gridEnabled || !pageRect) { canvas.renderAll(); return; } const { width, height, left, top } = pageRect; const gridLines = []; const lineOption = { stroke: 'rgba(0,0,0,0.1)', selectable: false, evented: false, excludeFromExport: true }; const step = gridCellSize; for (let i = 1; i < (width / step); i++) gridLines.push(new fabric.Line([left + i * step, top, left + i * step, top + height], lineOption)); for (let i = 1; i < (height / step); i++) gridLines.push(new fabric.Line([left, top + i * step, left + width, top + i * step], lineOption)); canvas.add(...gridLines); gridLines.forEach(line => canvas.sendToBack(line)); canvas.sendToBack(pageRect); canvas.renderAll(); }
        on('#toggleGridBtn', 'click', () => { gridEnabled = !gridEnabled; $('#toggleGridBtn').classList.toggle('active', gridEnabled); drawGrid(); });
        on('#toggleSnapBtn', 'click', () => { snapEnabled = !snapEnabled; $('#toggleSnapBtn').classList.toggle('active', snapEnabled); });
        const gridSizeInput = $('#gridSizeInput'); gridSizeInput.value = gridCellSize; gridSizeInput.addEventListener('input', (e) => { const newSize = Math.max(12, Math.min(64, parseInt(e.target.value, 10))); if (!isNaN(newSize) && gridCellSize !== newSize) { gridCellSize = newSize; drawGrid(); } });
        on('#closeColumnSelectModal', 'click', () => $('#columnSelectModal').style.display = 'none');

        // --- CANVAS PANNING & ZOOM ---
        function getWorkspaceBounds() {
            const artboards = canvas.getObjects().filter(o => o && (o.isArtboard || o.oid === 'pageRect'));
            if (!artboards.length) {
                return { minX: 0, minY: 0, maxX: DEFAULT_PAGE_WIDTH, maxY: DEFAULT_PAGE_HEIGHT };
            }

            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            artboards.forEach(board => {
                board.setCoords();
                const rect = board.getBoundingRect(true, true);
                minX = Math.min(minX, rect.left);
                minY = Math.min(minY, rect.top);
                maxX = Math.max(maxX, rect.left + rect.width);
                maxY = Math.max(maxY, rect.top + rect.height);
            });

            return { minX, minY, maxX, maxY };
        }

        function clampViewportTransform(vpt = canvas.viewportTransform) {
            if (!vpt) return;
            const wrapperRect = canvasWrapper.getBoundingClientRect();
            const viewportW = wrapperRect.width || canvas.getWidth() || 1;
            const viewportH = wrapperRect.height || canvas.getHeight() || 1;
            const zoom = canvas.getZoom() || 1;
            const bounds = getWorkspaceBounds();

            const minTx = viewportW - (bounds.maxX + CAMERA_BOUND_PADDING) * zoom;
            const maxTx = -((bounds.minX - CAMERA_BOUND_PADDING) * zoom);
            const minTy = viewportH - (bounds.maxY + CAMERA_BOUND_PADDING) * zoom;
            const maxTy = -((bounds.minY - CAMERA_BOUND_PADDING) * zoom);

            if (minTx > maxTx) vpt[4] = (minTx + maxTx) / 2;
            else vpt[4] = Math.min(maxTx, Math.max(minTx, vpt[4]));

            if (minTy > maxTy) vpt[5] = (minTy + maxTy) / 2;
            else vpt[5] = Math.min(maxTy, Math.max(minTy, vpt[5]));
        }

        function updateZoomLabel() {
            $('#zoomLevel').textContent = `Zoom: ${Math.round(canvas.getZoom() * 100)}%`;
        }

        function panViewportBy(dx, dy) {
            const vpt = canvas.viewportTransform;
            vpt[4] += dx;
            vpt[5] += dy;
            clampViewportTransform(vpt);
            canvas.setViewportTransform(vpt);
            canvas.requestRenderAll();
        }

        // Ensure wheel events are captured and do not scroll the page
        try {
            canvas.upperCanvasEl.addEventListener('wheel', (ev) => { ev.preventDefault(); }, { passive: false });
        } catch (e) { }

        let isPanning = false;
        let isMiddleMousePanning = false;
        let lastPosX = 0;
        let lastPosY = 0;
        let isSpaceDown = false;

        function beginPan(clientX, clientY) {
            isPanning = true;
            canvas.selection = false;
            lastPosX = clientX;
            lastPosY = clientY;
            canvas.setCursor('grabbing');
        }

        function endPan() {
            if (!isPanning && !isMiddleMousePanning) return;
            isPanning = false;
            isMiddleMousePanning = false;
            canvas.selection = true;
            canvas.setViewportTransform(canvas.viewportTransform);
            if (isSpaceDown) canvas.setCursor('grab');
            else canvas.setCursor('default');
        }

        function addWheelPanFix() {
            const el = canvas.upperCanvasEl;
            if (!el) return;

            // Prevent browser swipe/back behavior while interacting in-canvas.
            el.style.overscrollBehavior = 'contain';

            el.addEventListener('mousedown', (e) => {
                if (e.button !== 1) return;
                e.preventDefault();
                e.stopPropagation();
                isMiddleMousePanning = true;
                beginPan(e.clientX, e.clientY);
            }, true);

            window.addEventListener('mousemove', (e) => {
                if (!isMiddleMousePanning) return;
                e.preventDefault();
                panViewportBy(e.clientX - lastPosX, e.clientY - lastPosY);
                lastPosX = e.clientX;
                lastPosY = e.clientY;
            }, { passive: false });

            window.addEventListener('mouseup', (e) => {
                if (e.button !== 1 || !isMiddleMousePanning) return;
                e.preventDefault();
                endPan();
            });
        }

        window.addEventListener('keydown', e => {
            if (e.code !== 'Space') return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            e.preventDefault();
            isSpaceDown = true;
            canvas.defaultCursor = 'grab';
            canvas.setCursor('grab');
        });

        window.addEventListener('keyup', e => {
            if (e.code !== 'Space') return;
            e.preventDefault();
            isSpaceDown = false;
            canvas.defaultCursor = 'default';
            if (!isPanning && !isMiddleMousePanning) canvas.setCursor('default');
        });

        canvas.on('mouse:wheel', function (opt) {
            const e = opt.e;
            e.preventDefault();
            e.stopPropagation();

            let zoom = canvas.getZoom();
            zoom *= 0.999 ** e.deltaY;
            if (zoom > 20) zoom = 20;
            if (zoom < 0.05) zoom = 0.05;

            const pointer = canvas.getPointer(e);
            canvas.zoomToPoint(new fabric.Point(pointer.x, pointer.y), zoom);
            clampViewportTransform(canvas.viewportTransform);
            canvas.setViewportTransform(canvas.viewportTransform);
            canvas.requestRenderAll();

            updateZoomLabel();
        });

        canvas.on('mouse:down', function (opt) {
            const e = opt.e;
            if (!isSpaceDown || e.button !== 0) return;
            beginPan(e.clientX, e.clientY);
            e.preventDefault();
        });

        canvas.on('mouse:move', function (opt) {
            if (!isPanning || isMiddleMousePanning) return;
            const e = opt.e;
            panViewportBy(e.clientX - lastPosX, e.clientY - lastPosY);
            lastPosX = e.clientX;
            lastPosY = e.clientY;
        });

        canvas.on('mouse:up', function () {
            if (!isMiddleMousePanning) endPan();
        });


        // --- DATA HANDLING ---
        // 4. In-app notification
        // 4. Modern Toast notification
        function showNotification(message, type = 'info', duration = 3000) {
            const container = $('#toast-container');
            if (!container) return;

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const icon = type === 'success' ? '✓' : type === 'error' ? '!' : 'i';
            toast.innerHTML = `<span class="toast-icon">${icon}</span><span class="toast-message">${message}</span>`;

            container.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('fade-out');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        async function cacheDataFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                localStorage.setItem('cachedFileName', file.name);
                localStorage.setItem('cachedFileData', e.target.result);
                cacheLocalDataState();
            };
            reader.readAsDataURL(file);
        }

        function cacheLocalDataState() {
            try {
                if (headers.length > 0) {
                    localStorage.setItem('cachedHeaders', JSON.stringify(headers));
                    localStorage.setItem('cachedDataRows', JSON.stringify(dataRows));
                    if (identifierColumn) localStorage.setItem('cachedIdentifierColumn', identifierColumn);
                    else localStorage.removeItem('cachedIdentifierColumn');
                } else {
                    localStorage.removeItem('cachedHeaders');
                    localStorage.removeItem('cachedDataRows');
                    localStorage.removeItem('cachedIdentifierColumn');
                }
            } catch (e) {
                console.warn('Failed to cache data to localStorage:', e);
            }
        }

        function processFileData(arrayBuffer, fileName, opts = {}) {
            try {
                workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                worksheet = workbook.Sheets[sheetName];
                const json = XLSX.utils.sheet_to_json(worksheet, { defval: '', raw: false });
                if (!json.length) { showNotification('No data found in the sheet.'); return; }
                // Ensure headers are extracted from the first row keys
                headers = Object.keys(json[0]);
                dataRows = json; // Keep the full array of objects
                console.log('Processed Data:', { headers, rowCount: dataRows.length, sample: dataRows[0] });
                $('#fileName').textContent = fileName;
                $('#unloadDataBtn').style.display = 'inline';
                showNotification(`Loaded "${sheetName}" with ${dataRows.length} rows.`);
                refreshInspector({ target: canvas.getActiveObject() });
                updateExportUI();
                updateFloatingLinker(canvas.getActiveObject());
                renderCsvView(); // Update view if open
                refreshIdentifierDropdown();
                requestSaveState(); // Trigger save with new data
                cacheLocalDataState(); // Persist to local storage

                // Show identifier column modal on fresh file load
                if (!opts.skipIdentifierModal) {
                    showIdentifierColumnModal();
                }
            } catch (err) {
                showNotification('Error reading file.');
                unloadData();
            }
        }
        // 5. Unload data function
        function unloadData() {
            workbook = null; worksheet = null; headers = []; dataRows = []; identifierColumn = '';
            $('#fileName').textContent = 'No file selected';
            $('#unloadDataBtn').style.display = 'none';
            localStorage.removeItem('cachedFileName');
            localStorage.removeItem('cachedFileData');
            localStorage.removeItem('cachedHeaders');
            localStorage.removeItem('cachedDataRows');
            localStorage.removeItem('cachedIdentifierColumn');
            $('#csvInput').value = '';
            $('#csvViewBtn').style.display = 'none';
            updateExportUI();
            updateFloatingLinker(null);
            showNotification('Data unloaded.');
        }
        on('#unloadDataBtn', 'click', unloadData);

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64.split(',')[1]);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        async function loadCachedData() {
            const cachedHeaders = localStorage.getItem('cachedHeaders');
            const cachedRows = localStorage.getItem('cachedDataRows');
            const cachedIdCol = localStorage.getItem('cachedIdentifierColumn');
            const fileName = localStorage.getItem('cachedFileName');

            if (cachedHeaders && cachedRows) {
                try {
                    headers = JSON.parse(cachedHeaders);
                    dataRows = JSON.parse(cachedRows);
                    identifierColumn = cachedIdCol || '';
                    $('#fileName').textContent = fileName || 'Restored Data';
                    $('#unloadDataBtn').style.display = 'inline';
                    $('#csvViewBtn').style.display = 'inline-flex';
                    refreshIdentifierDropdown();
                    renderCsvView();
                    updateExportUI();
                    updateFloatingLinker(canvas.getActiveObject());
                    return;
                } catch (e) {
                    console.error('Failed to parse cached data:', e);
                }
            }

            const fileData = localStorage.getItem('cachedFileData');
            if (fileName && fileData) {
                const arrayBuffer = base64ToArrayBuffer(fileData);
                processFileData(arrayBuffer, fileName, { skipIdentifierModal: true });
            }
        }
        on('#csvInput', 'change', async (e) => {
            const file = e.target.files?.[0];
            if (!file) { unloadData(); return; }
            await cacheDataFile(file);
            const data = await file.arrayBuffer();
            processFileData(data, file.name);
        });

        // Font Loading
        async function loadFont(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const fontName = file.name.split('.')[0];
                    const fontFace = new FontFace(fontName, e.target.result);
                    await fontFace.load();
                    document.fonts.add(fontFace);
                    if (!FONT_LIST.includes(fontName)) {
                        FONT_LIST.push(fontName);
                        FONT_LIST.sort();
                    }
                    refreshInspector({ target: canvas.getActiveObject() });
                    showNotification(`Font "${fontName}" loaded.`);
                } catch (err) {
                    console.error(err);
                    showNotification('Error loading font.', 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        on('#fontUpload', 'change', (e) => loadFont(e.target.files[0]));


        // --- COMPONENT ADDITION ---
        function getUniqueName(baseName) {
            const existingNames = canvas.getObjects().map(o => o.name).filter(Boolean);
            if (!existingNames.includes(baseName)) { return baseName; }
            let i = 1;
            while (existingNames.includes(`${baseName} ${i}`)) { i++; }
            return `${baseName} ${i}`;
        }

        function currentCanvasPageId() {
            return documentPages[currentPageIndex]?.id || 'page_1';
        }

        const TABLE_TEXT_PADDING = 6;

        function getDefaultTableCellData(table, row, col) {
            const isHeader = row < (table.headerRows || 0);
            return {
                row,
                col,
                text: '',
                fill: isHeader ? (table.headerFill || '#f3f4f6') : (table.bodyFill || '#ffffff'),
                textColor: '#111111',
                fontSize: 14,
                textAlign: 'left',
                textVAlign: 'top',
                borderColor: table.borderColor || '#333333',
                borderWidth: Math.max(0.5, parseFloat(table.borderWidth) || 1),
                borders: { top: true, right: true, bottom: true, left: true }
            };
        }

        function normalizeTableCellData(raw, table, row, col) {
            const base = getDefaultTableCellData(table, row, col);
            const merged = { ...base, ...(raw || {}) };
            merged.row = row;
            merged.col = col;
            merged.text = typeof merged.text === 'string' ? merged.text : '';
            merged.fill = merged.fill ?? base.fill;
            merged.textColor = merged.textColor || base.textColor;
            merged.fontSize = Math.max(6, parseFloat(merged.fontSize) || base.fontSize);
            merged.textAlign = ['left', 'center', 'right', 'justify'].includes(merged.textAlign) ? merged.textAlign : base.textAlign;
            merged.textVAlign = ['top', 'middle', 'bottom'].includes(merged.textVAlign) ? merged.textVAlign : base.textVAlign;
            merged.borderColor = merged.borderColor || table.borderColor || base.borderColor;
            merged.borderWidth = Math.max(0.5, parseFloat(merged.borderWidth) || table.borderWidth || base.borderWidth);
            const borders = merged.borders || {};
            merged.borders = {
                top: borders.top !== false,
                right: borders.right !== false,
                bottom: borders.bottom !== false,
                left: borders.left !== false
            };
            return merged;
        }

        function ensureTableCellData(table) {
            if (!table || !table.isTable) return;
            const rows = Math.max(1, parseInt(table.rows, 10) || 1);
            const cols = Math.max(1, parseInt(table.cols, 10) || 1);
            table.rows = rows;
            table.cols = cols;
            table.headerRows = Math.max(0, Math.min(rows, parseInt(table.headerRows, 10) || 0));
            table.borderColor = table.borderColor || '#333333';
            table.borderWidth = Math.max(0.5, parseFloat(table.borderWidth) || 1);
            table.headerFill = table.headerFill || '#f3f4f6';
            table.bodyFill = table.bodyFill || '#ffffff';

            const baseW = Math.max(25, parseFloat(table.colWidths?.[0]) || 120);
            const baseH = Math.max(25, parseFloat(table.rowHeights?.[0]) || 50);
            table.colWidths = Array.from({ length: cols }, (_, i) => Math.max(25, parseFloat(table.colWidths?.[i]) || baseW));
            table.rowHeights = Array.from({ length: rows }, (_, i) => Math.max(25, parseFloat(table.rowHeights?.[i]) || baseH));

            const old = Array.isArray(table.cellData) ? table.cellData : [];
            const next = [];
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const idx = r * cols + c;
                    next.push(normalizeTableCellData(old[idx], table, r, c));
                }
            }
            table.cellData = next;
            if (!(table._selectedCells instanceof Set)) {
                table._selectedCells = new Set(Array.isArray(table.selectedCells) ? table.selectedCells : []);
            }
        }

        function resizeTableCellData(table, nextRows, nextCols) {
            ensureTableCellData(table);
            const prevRows = table.rows;
            const prevCols = table.cols;
            const previous = table.cellData.slice();
            const resized = [];

            for (let r = 0; r < nextRows; r++) {
                for (let c = 0; c < nextCols; c++) {
                    if (r < prevRows && c < prevCols) {
                        const oldIdx = r * prevCols + c;
                        resized.push(normalizeTableCellData(previous[oldIdx], table, r, c));
                    } else {
                        resized.push(getDefaultTableCellData(table, r, c));
                    }
                }
            }

            table.rows = nextRows;
            table.cols = nextCols;
            table.cellData = resized;
            table.headerRows = Math.max(0, Math.min(table.rows, table.headerRows || 0));
        }

        function getTableCellGroupParts(cellGroup) {
            const objs = cellGroup.getObjects();
            return {
                fillRect: objs[0],
                textObj: objs[1],
                topLine: objs[2],
                rightLine: objs[3],
                bottomLine: objs[4],
                leftLine: objs[5],
                selectionRect: objs[6]
            };
        }

        function createTableCellGroup({ width, height, cellData, cellIndex, row, col }) {
            const fillRect = new fabric.Rect({
                left: -width / 2,
                top: -height / 2,
                originX: 'left',
                originY: 'top',
                width,
                height,
                fill: cellData.fill,
                stroke: null,
                selectable: false,
                evented: false
            });

            const textObj = new fabric.Textbox(cellData.text || '', {
                left: -width / 2 + TABLE_TEXT_PADDING,
                top: -height / 2 + TABLE_TEXT_PADDING,
                originX: 'left',
                originY: 'top',
                width: Math.max(8, width - TABLE_TEXT_PADDING * 2),
                fontSize: cellData.fontSize || 14,
                fill: cellData.textColor || '#111111',
                textAlign: cellData.textAlign || 'left',
                lineHeight: 1.2,
                selectable: false,
                evented: false,
                editable: false
            });

            const makeBorderRect = (visible = true) => new fabric.Rect({
                left: -width / 2,
                top: -height / 2,
                originX: 'left',
                originY: 'top',
                width: 1,
                height: 1,
                fill: cellData.borderColor || '#333333',
                selectable: false,
                evented: false,
                visible
            });

            const topLine = makeBorderRect(cellData.borders?.top !== false);
            const rightLine = makeBorderRect(cellData.borders?.right !== false);
            const bottomLine = makeBorderRect(cellData.borders?.bottom !== false);
            const leftLine = makeBorderRect(cellData.borders?.left !== false);

            const selectionRect = new fabric.Rect({
                left: -width / 2,
                top: -height / 2,
                originX: 'left',
                originY: 'top',
                width,
                height,
                fill: 'rgba(59,130,246,0.12)',
                stroke: '#3b82f6',
                strokeWidth: 1,
                selectable: false,
                evented: false,
                excludeFromExport: true,
                visible: false
            });

            return new fabric.Group([fillRect, textObj, topLine, rightLine, bottomLine, leftLine, selectionRect], {
                left: 0,
                top: 0,
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false,
                hasControls: false,
                hasBorders: false,
                objectCaching: false,
                isTableCellGroup: true,
                cellIndex,
                row,
                col
            });
        }

        function updateTableCellGroupVisual(cellGroup, width, height, cellData, selected = false) {
            const { fillRect, textObj, topLine, rightLine, bottomLine, leftLine, selectionRect } = getTableCellGroupParts(cellGroup);
            const clampedWidth = Math.max(1, width);
            const clampedHeight = Math.max(1, height);
            const localLeft = -clampedWidth / 2;
            const localTop = -clampedHeight / 2;

            fillRect.set({
                left: localLeft,
                top: localTop,
                width: clampedWidth,
                height: clampedHeight,
                fill: cellData.fill
            });

            textObj.set({
                left: localLeft + TABLE_TEXT_PADDING,
                top: localTop + TABLE_TEXT_PADDING,
                width: Math.max(8, clampedWidth - TABLE_TEXT_PADDING * 2),
                text: cellData.text || '',
                fill: cellData.textColor || '#111111',
                fontSize: Math.max(6, cellData.fontSize || 14),
                textAlign: cellData.textAlign || 'left'
            });
            textObj.initDimensions();
            const availableTextHeight = Math.max(0, clampedHeight - TABLE_TEXT_PADDING * 2);
            const measuredTextHeight = Math.min(availableTextHeight, textObj.height || 0);
            let textTop = localTop + TABLE_TEXT_PADDING;
            if (cellData.textVAlign === 'middle') {
                textTop = localTop + TABLE_TEXT_PADDING + Math.max(0, (availableTextHeight - measuredTextHeight) / 2);
            } else if (cellData.textVAlign === 'bottom') {
                textTop = localTop + clampedHeight - TABLE_TEXT_PADDING - measuredTextHeight;
            }
            textObj.set({ top: textTop });

            const borderColor = cellData.borderColor || '#333333';
            const borderWidth = Math.max(0.5, cellData.borderWidth || 1);
            const clampedBorder = Math.min(Math.max(0.5, borderWidth), Math.min(clampedWidth, clampedHeight));
            topLine.set({ left: localLeft, top: localTop, width: clampedWidth, height: clampedBorder, fill: borderColor, visible: cellData.borders?.top !== false });
            rightLine.set({ left: localLeft + clampedWidth - clampedBorder, top: localTop, width: clampedBorder, height: clampedHeight, fill: borderColor, visible: cellData.borders?.right !== false });
            bottomLine.set({ left: localLeft, top: localTop + clampedHeight - clampedBorder, width: clampedWidth, height: clampedBorder, fill: borderColor, visible: cellData.borders?.bottom !== false });
            leftLine.set({ left: localLeft, top: localTop, width: clampedBorder, height: clampedHeight, fill: borderColor, visible: cellData.borders?.left !== false });

            selectionRect.set({
                left: localLeft,
                top: localTop,
                width: clampedWidth,
                height: clampedHeight,
                visible: !!selected
            });

            cellGroup.set({ width, height, dirty: true });
            cellGroup.setCoords();
        }

        function refreshTableSelectionVisual(table) {
            if (!table?.isTable) return;
            const selected = table._selectedCells instanceof Set ? table._selectedCells : new Set();
            const cells = table.getObjects().filter(obj => obj.isTableCellGroup);
            cells.forEach((cellGroup, index) => {
                const parts = getTableCellGroupParts(cellGroup);
                if (parts.selectionRect) parts.selectionRect.set({ visible: selected.has(index) });
            });
            table.selectedCells = Array.from(selected);
        }

        function clearTableCellSelections(exceptTable = null) {
            canvas.getObjects().forEach(obj => {
                if (!obj?.isTable || obj === exceptTable) return;
                obj._selectedCells = new Set();
                refreshTableSelectionVisual(obj);
            });
            canvas.requestRenderAll();
        }

        function getTableCellFromPointer(table, pointer) {
            if (!table || !pointer) return null;
            const local = table.toLocalPoint(new fabric.Point(pointer.x, pointer.y), 'center', 'center');
            let currentY = -table.height / 2;

            for (let r = 0; r < table.rows; r++) {
                const h = table.rowHeights[r];
                let currentX = -table.width / 2;
                for (let c = 0; c < table.cols; c++) {
                    const w = table.colWidths[c];
                    if (local.x >= currentX && local.x <= currentX + w && local.y >= currentY && local.y <= currentY + h) {
                        return { row: r, col: c, index: r * table.cols + c };
                    }
                    currentX += w;
                }
                currentY += h;
            }
            return null;
        }

        function getTableCellLocalRect(table, cellIndex) {
            if (!table?.isTable) return null;
            const maxIndex = table.rows * table.cols - 1;
            if (!Number.isInteger(cellIndex) || cellIndex < 0 || cellIndex > maxIndex) return null;
            const row = Math.floor(cellIndex / table.cols);
            const col = cellIndex % table.cols;
            const totalWidth = table.colWidths.reduce((sum, w) => sum + w, 0);
            const totalHeight = table.rowHeights.reduce((sum, h) => sum + h, 0);
            let left = -totalWidth / 2;
            let top = -totalHeight / 2;
            for (let c = 0; c < col; c++) left += table.colWidths[c];
            for (let r = 0; r < row; r++) top += table.rowHeights[r];
            return {
                left,
                top,
                width: table.colWidths[col],
                height: table.rowHeights[row],
                row,
                col
            };
        }

        function getTableCellEditorRect(table, cellIndex) {
            const localRect = getTableCellLocalRect(table, cellIndex);
            if (!localRect) return null;
            const tableMatrix = table.calcTransformMatrix();
            const vpt = canvas.viewportTransform || [1, 0, 0, 1, 0, 0];
            const finalMatrix = fabric.util.multiplyTransformMatrices(vpt, tableMatrix);
            const corners = [
                new fabric.Point(localRect.left, localRect.top),
                new fabric.Point(localRect.left + localRect.width, localRect.top),
                new fabric.Point(localRect.left + localRect.width, localRect.top + localRect.height),
                new fabric.Point(localRect.left, localRect.top + localRect.height)
            ].map(p => fabric.util.transformPoint(p, finalMatrix));
            const xs = corners.map(p => p.x);
            const ys = corners.map(p => p.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const canvasRect = canvas.upperCanvasEl.getBoundingClientRect();
            return {
                left: canvasRect.left + minX,
                top: canvasRect.top + minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        function closeTableCellEditor({ commit = true } = {}) {
            if (!activeTableCellEditor) return;
            activeTableCellEditor.close(commit);
        }

        function startTableCellEditor(table, cellIndex) {
            if (!table?.isTable) return;
            ensureTableCellData(table);
            const cell = table.cellData[cellIndex];
            if (!cell) return;

            closeTableCellEditor({ commit: true });

            const rect = getTableCellEditorRect(table, cellIndex);
            if (!rect || rect.width < 4 || rect.height < 4) return;

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'table-cell-editor';
            input.value = cell.text || '';
            input.style.left = `${Math.round(rect.left + 1)}px`;
            input.style.top = `${Math.round(rect.top + 1)}px`;
            input.style.width = `${Math.max(28, Math.round(rect.width - 2))}px`;
            input.style.height = `${Math.max(22, Math.round(rect.height - 2))}px`;
            input.style.fontSize = `${Math.max(10, Math.round(cell.fontSize || 14))}px`;
            input.style.textAlign = cell.textAlign || 'left';
            input.style.fontFamily = 'inherit';

            document.body.appendChild(input);

            let closed = false;
            const previousValue = cell.text || '';
            const closeEditor = (shouldCommit) => {
                if (closed) return;
                closed = true;
                const nextValue = input.value;
                if (shouldCommit && table.isTable && previousValue !== nextValue) {
                    ensureTableCellData(table);
                    if (table.cellData[cellIndex]) {
                        table.cellData[cellIndex].text = nextValue;
                        updateTableLayout(table);
                        canvas.requestRenderAll();
                        requestSaveState();
                    }
                }
                input.remove();
                if (activeTableCellEditor && activeTableCellEditor.input === input) {
                    activeTableCellEditor = null;
                }
                if (canvas.getActiveObject() === table) refreshInspector({ target: table });
            };

            activeTableCellEditor = { table, cellIndex, input, close: closeEditor };

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    closeEditor(true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeEditor(false);
                }
            });
            input.addEventListener('blur', () => closeEditor(true));

            requestAnimationFrame(() => {
                input.focus();
                input.select();
            });
        }

        function getSelectedTableCellIndices(table, { fallbackAll = false } = {}) {
            ensureTableCellData(table);
            if (!(table._selectedCells instanceof Set)) table._selectedCells = new Set();
            const selected = Array.from(table._selectedCells).filter(i => Number.isInteger(i) && i >= 0 && i < table.rows * table.cols);
            if (selected.length || !fallbackAll) return selected;
            return Array.from({ length: table.rows * table.cols }, (_, i) => i);
        }

        function getTableCellRowCol(table, cellIndex) {
            ensureTableCellData(table);
            const max = Math.max(0, table.rows * table.cols - 1);
            const idx = Math.max(0, Math.min(max, parseInt(cellIndex, 10) || 0));
            return {
                index: idx,
                row: Math.floor(idx / table.cols),
                col: idx % table.cols
            };
        }

        function tableCellRefLabel(table, cellIndex) {
            const rc = getTableCellRowCol(table, cellIndex);
            return `R${rc.row + 1} C${rc.col + 1}`;
        }

        function getSingleSelectedTableCellIndex(table) {
            const selected = getSelectedTableCellIndices(table, { fallbackAll: false });
            return selected.length === 1 ? selected[0] : -1;
        }

        function setSelectedTableCells(table, indices, { append = false, toggle = false } = {}) {
            if (!table?.isTable) return;
            ensureTableCellData(table);
            const maxIdx = table.rows * table.cols - 1;
            let next = append || toggle ? new Set(table._selectedCells || []) : new Set();
            indices.forEach(idx => {
                if (!Number.isInteger(idx) || idx < 0 || idx > maxIdx) return;
                if (toggle) {
                    if (next.has(idx)) next.delete(idx);
                    else next.add(idx);
                } else {
                    next.add(idx);
                }
            });
            table._selectedCells = next;
            refreshTableSelectionVisual(table);
            canvas.requestRenderAll();
        }

        function getCommonSelectedTableCellValue(table, key, { fallbackAll = false } = {}) {
            const indices = getSelectedTableCellIndices(table, { fallbackAll });
            if (!indices.length) return '';
            const values = indices.map(i => {
                const cell = table.cellData[i];
                if (!cell) return undefined;
                if (key.includes('.')) {
                    const [k1, k2] = key.split('.');
                    return cell[k1]?.[k2];
                }
                return cell[key];
            });
            const first = values[0];
            return values.every(v => v === first) ? first : '';
        }

        function applyToSelectedTableCells(table, updater, { fallbackAll = true } = {}) {
            if (!table?.isTable) return;
            ensureTableCellData(table);
            const indices = getSelectedTableCellIndices(table, { fallbackAll });
            if (!indices.length) return;
            indices.forEach(idx => updater(table.cellData[idx], idx));
            updateTableLayout(table);
            canvas.requestRenderAll();
            requestSaveState();
        }

        function toggleSelectedTableBorderSide(table, side) {
            if (!['top', 'right', 'bottom', 'left'].includes(side)) return;
            ensureTableCellData(table);
            const indices = getSelectedTableCellIndices(table, { fallbackAll: true });
            if (!indices.length) return;
            const allOn = indices.every(idx => table.cellData[idx]?.borders?.[side] !== false);
            indices.forEach(idx => {
                const cell = table.cellData[idx];
                cell.borders = cell.borders || { top: true, right: true, bottom: true, left: true };
                cell.borders[side] = !allOn;
            });
            updateTableLayout(table);
            canvas.requestRenderAll();
            requestSaveState();
        }

        function rebuildTableCells(table) {
            if (!table || !table.isTable) return;
            ensureTableCellData(table);
            const existingSelection = new Set(getSelectedTableCellIndices(table));
            const center = table.getCenterPoint();
            table.getObjects().slice().forEach(cell => table.remove(cell));

            for (let r = 0; r < table.rows; r++) {
                for (let c = 0; c < table.cols; c++) {
                    const index = r * table.cols + c;
                    const cellGroup = createTableCellGroup({
                        width: table.colWidths[c],
                        height: table.rowHeights[r],
                        cellData: table.cellData[index],
                        cellIndex: index,
                        row: r,
                        col: c
                    });
                    table.add(cellGroup);
                }
            }

            table._selectedCells = existingSelection;
            table.originalColWidths = [...table.colWidths];
            table.originalRowHeights = [...table.rowHeights];
            updateTableLayout(table, center);
        }

        function createTableObject({
            x,
            y,
            rows,
            cols,
            cellWidth,
            cellHeight,
            headerRows = 1,
            headerFill = '#f3f4f6',
            bodyFill = '#ffffff',
            borderColor = '#333333',
            borderWidth = 1
        }) {
            const colWidths = Array(Math.max(1, cols)).fill(Math.max(25, cellWidth));
            const rowHeights = Array(Math.max(1, rows)).fill(Math.max(25, cellHeight));

            const table = new fabric.Group([], {
                left: x,
                top: y,
                originX: 'center',
                originY: 'center',
                isTable: true,
                rows: Math.max(1, rows),
                cols: Math.max(1, cols),
                colWidths,
                rowHeights,
                originalColWidths: [...colWidths],
                originalRowHeights: [...rowHeights],
                headerRows: Math.max(0, Math.min(rows, headerRows)),
                headerFill,
                bodyFill,
                borderColor,
                borderWidth,
                cellData: [],
                hasControls: true,
                hasBorders: true,
                cornerColor: '#4285F4',
                cornerStyle: 'circle',
                transparentCorners: false,
                borderScaleFactor: 2,
                objectCaching: false,
                lockScalingFlip: true,
                name: getUniqueName('table'),
                pageId: currentCanvasPageId()
            });

            table._selectedCells = new Set();
            table.selectedCells = [];
            rebuildTableCells(table);
            return table;
        }

        function addTableRow(table) {
            const nextRows = Math.max(1, table.rows + 1);
            const nextCols = Math.max(1, table.cols);
            resizeTableCellData(table, nextRows, nextCols);
            table.rowHeights.push(table.rowHeights[table.rowHeights.length - 1] || 50);
            table.headerRows = Math.min(table.headerRows || 0, nextRows);
            rebuildTableCells(table);
            canvas.requestRenderAll();
            requestSaveState();
        }

        function removeTableRow(table) {
            if (table.rows <= 1) return;
            const nextRows = table.rows - 1;
            const nextCols = table.cols;
            resizeTableCellData(table, nextRows, nextCols);
            table.rowHeights.pop();
            table.headerRows = Math.min(table.headerRows || 0, nextRows);
            rebuildTableCells(table);
            canvas.requestRenderAll();
            requestSaveState();
        }

        function addTableColumn(table) {
            const nextRows = table.rows;
            const nextCols = table.cols + 1;
            resizeTableCellData(table, nextRows, nextCols);
            table.colWidths.push(table.colWidths[table.colWidths.length - 1] || 120);
            rebuildTableCells(table);
            canvas.requestRenderAll();
            requestSaveState();
        }

        function removeTableColumn(table) {
            if (table.cols <= 1) return;
            const nextRows = table.rows;
            const nextCols = table.cols - 1;
            resizeTableCellData(table, nextRows, nextCols);
            table.colWidths.pop();
            rebuildTableCells(table);
            canvas.requestRenderAll();
            requestSaveState();
        }

        const adders = {
            text: (x, y, content = 'Sample Text') => canvas.add(new fabric.Textbox(content, { left: x, top: y, fontSize: 28, fill: '#000000', fontFamily: 'Arial', originX: 'center', originY: 'center', styles: [], padding: 0, name: getUniqueName('text'), lockUniScaling: true, pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
            rect: ({ x, y, asSquare = true } = {}) => canvas.add(new fabric.Rect({ left: x, top: y, width: asSquare ? 150 : 220, height: 150, fill: '#ffffff', stroke: '#000000', strokeWidth: 2, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName(asSquare ? 'square' : 'rectangle'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
            circle: (x, y) => canvas.add(new fabric.Circle({ left: x, top: y, radius: 75, fill: '#ffffff', stroke: '#000000', strokeWidth: 2, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName('circle'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
            triangle: (x, y) => canvas.add(new fabric.Triangle({ left: x, top: y, width: 150, height: 130, fill: '#ffffff', stroke: '#000000', strokeWidth: 2, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName('triangle'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
            line: (x, y) => {
                const spawnPoint = (Number.isFinite(x) && Number.isFinite(y))
                    ? { x, y }
                    : getDefaultSpawnPoint();
                const startPoint = new fabric.Point(spawnPoint.x - 75, spawnPoint.y);
                const endPoint = new fabric.Point(spawnPoint.x + 75, spawnPoint.y);

                const line = new fabric.Line([startPoint.x, startPoint.y, endPoint.x, endPoint.y], {
                    stroke: '#000000',
                    strokeWidth: 4,
                    strokeUniform: true,
                    originX: 'center',
                    originY: 'center',
                    padding: 0,
                    name: getUniqueName('line'),
                    pageId: currentCanvasPageId()
                });

                normalizeLineFromCanvasEndpoints(line, startPoint, endPoint);
                canvas.add(line).setActiveObject(line);
                canvas.renderAll();
            },
            star: (x, y) => { const pts = (n, oR, iR) => { const p = []; let a = -Math.PI / 2; const s = (Math.PI * 2) / n; for (let i = 0; i < n; i++) { p.push({ x: oR * Math.cos(a), y: oR * Math.sin(a) }); a += s / 2; p.push({ x: iR * Math.cos(a), y: iR * Math.sin(a) }); a += s / 2; } return p; }; canvas.add(new fabric.Polygon(pts(5, 75, 35), { left: x, top: y, fill: '#ffffff', stroke: '#000000', strokeWidth: 2, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName('star'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()); },
            square: (x, y) => adders.rect({ x, y, asSquare: true }),
            arrow: (x, y) => canvas.add(new fabric.Path('M 0 20 L 60 20 L 60 0 L 100 30 L 60 60 L 60 40 L 0 40 Z', { left: x, top: y, fill: '#ffffff', stroke: '#000000', strokeWidth: 2, strokeUniform: true, originX: 'center', originY: 'center', name: getUniqueName('arrow'), pageId: currentCanvasPageId() })).setActiveObject(canvas.getObjects().pop()),
            image: (x, y, url, elementData = {}) => { fabric.Image.fromURL(url, (img) => { img.set({ left: x, top: y, scaleX: 0.5, scaleY: 0.5, originX: 'center', originY: 'center', name: getUniqueName('image'), pageId: currentCanvasPageId(), ...elementData }); canvas.add(img).setActiveObject(img); }, { crossOrigin: 'anonymous' }); },
            svg: (x, y, url, elementData = {}) => {
                fabric.loadSVGFromURL(url, (objects, options) => {
                    if (!objects || objects.length === 0) return;
                    objects.forEach(obj => {
                        obj.objectCaching = false;
                    });
                    const group = new fabric.Group(objects, {
                        ...options, ...elementData,
                        left: x, top: y, originX: 'center', originY: 'center',
                        isSvgGroup: true, name: getUniqueName('svg'), pageId: currentCanvasPageId(), objectCaching: false
                    });
                    group.scaleToWidth(150);
                    group.setCoords();
                    canvas.add(group).setActiveObject(canvas.getObjects().pop());
                    canvas.renderAll();
                }, null, { crossOrigin: 'anonymous' });
            },
            // 6. Restored Table Code
            table: (x, y) => {
                tableCreatorModal.style.display = 'flex';

                const createHandler = () => {
                    const rows = parsePositiveInt($('#tableRows').value, 3);
                    const cols = parsePositiveInt($('#tableCols').value, 3);
                    const cellWidth = parsePositiveInt($('#tableCellWidth').value, 120);
                    const cellHeight = parsePositiveInt($('#tableCellHeight').value, 50);
                    const headerRows = Math.max(0, Math.min(rows, parseInt($('#tableHeaderRows').value, 10) || 0));
                    if (rows <= 0 || cols <= 0) return;

                    const spawnPoint = (Number.isFinite(x) && Number.isFinite(y))
                        ? { x, y }
                        : getDefaultSpawnPoint();
                    const table = createTableObject({
                        x: spawnPoint.x,
                        y: spawnPoint.y,
                        rows,
                        cols,
                        cellWidth,
                        cellHeight,
                        headerRows
                    });

                    table.setPositionByOrigin(new fabric.Point(spawnPoint.x, spawnPoint.y), 'center', 'center');
                    canvas.add(table).setActiveObject(table);
                    canvas.requestRenderAll();
                    closeTableModal();
                };

                const closeTableModal = () => {
                    tableCreatorModal.style.display = 'none';
                    $('#confirmTableCreate').removeEventListener('click', createHandler);
                    $('#cancelTableCreate').removeEventListener('click', closeTableModal);
                    $('#closeTableCreator').removeEventListener('click', closeTableModal);
                };

                on('#confirmTableCreate', 'click', createHandler, { once: true });
                on('#cancelTableCreate', 'click', closeTableModal, { once: true });
                on('#closeTableCreator', 'click', closeTableModal, { once: true });
            }
        };
        // 6. Restored Table Code
        function updateTableLayout(table, preservedCenter = null) {
            if (!table || !table.isTable) return;
            ensureTableCellData(table);

            const cellObjects = table.getObjects();
            const allChildrenAreCells = cellObjects.length === table.rows * table.cols
                && cellObjects.every(obj => obj?.isTableCellGroup);
            if (!allChildrenAreCells) {
                rebuildTableCells(table);
                return;
            }

            const totalWidth = table.colWidths.reduce((sum, w) => sum + w, 0);
            const totalHeight = table.rowHeights.reduce((sum, h) => sum + h, 0);
            const center = preservedCenter || table.getCenterPoint();
            const selected = table._selectedCells instanceof Set ? table._selectedCells : new Set();

            let currentY = -totalHeight / 2;
            for (let r = 0; r < table.rows; r++) {
                let currentX = -totalWidth / 2;
                for (let c = 0; c < table.cols; c++) {
                    const cellIndex = r * table.cols + c;
                    const cellGroup = table.item(cellIndex);
                    if (!cellGroup) continue;
                    const width = table.colWidths[c];
                    const height = table.rowHeights[r];
                    const cellData = table.cellData[cellIndex] || getDefaultTableCellData(table, r, c);
                    updateTableCellGroupVisual(cellGroup, width, height, cellData, selected.has(cellIndex));
                    cellGroup.set({
                        left: currentX + width / 2,
                        top: currentY + height / 2,
                        originX: 'center',
                        originY: 'center',
                        row: r,
                        col: c,
                        cellIndex
                    });
                    cellGroup.setCoords();
                    currentX += width;
                }
                currentY += table.rowHeights[r];
            }

            table.width = totalWidth;
            table.height = totalHeight;
            table.setPositionByOrigin(center, 'center', 'center');
            table.dirty = true;
            table.setCoords();
            table.selectedCells = Array.from(selected);
        }
        // 6. Restored Table Code
        class TableResizer {

            constructor(canvas) {
                this.canvas = canvas;
                this.state = {};
                this.resetState();

                this.RESIZE_HANDLE_AREA = 12;
                this.MIN_CELL_SIZE = 25;
            }

            resetState() {
                if (this.state.target) {
                    this.state.target.lockMovementX = false;
                    this.state.target.lockMovementY = false;
                }
                this.state = {
                    isResizing: false,
                    target: null,
                    type: null,
                    index: -1,
                    startX: 0,
                    startY: 0,
                    originalPos: { x: 0, y: 0 },
                    originalWidths: [],
                    originalHeights: [],
                };
                this.canvas.defaultCursor = 'default';
            }

            init() {
                this.canvas.on('mouse:down', this.handleMouseDown.bind(this));
                this.canvas.on('mouse:move', this.handleMouseMove.bind(this));
                this.canvas.on('mouse:up', this.handleMouseUp.bind(this));
                this.canvas.on('object:modified', this.handleObjectScaling.bind(this));
            }

            handleObjectScaling(options) {
                const table = options.target;
                if (!table || !table.isTable) return;

                const { scaleX, scaleY } = table;

                let totalWidth = 0;
                for (let i = 0; i < table.colWidths.length; i++) {
                    const newWidth = table.originalColWidths[i] * scaleX;
                    table.colWidths[i] = Math.max(this.MIN_CELL_SIZE, newWidth);
                    totalWidth += table.colWidths[i];
                }

                let totalHeight = 0;
                for (let i = 0; i < table.rowHeights.length; i++) {
                    const newHeight = table.originalRowHeights[i] * scaleY;
                    table.rowHeights[i] = Math.max(this.MIN_CELL_SIZE, newHeight);
                    totalHeight += table.rowHeights[i];
                }

                table.width = totalWidth;
                table.height = totalHeight;
                table.scaleX = 1;
                table.scaleY = 1;

                updateTableLayout(table);
            }

            handleMouseDown(options) {
                if (options.target && options.target.isTable) {
                    options.target.originalColWidths = [...options.target.colWidths];
                    options.target.originalRowHeights = [...options.target.rowHeights];
                }

                if (!this.canvas.defaultCursor.includes('resize') || !options.target || !options.target.isTable) {
                    return;
                }

                const pointer = this.canvas.getPointer(options.e);
                const table = options.target;

                this.state.isResizing = true;
                this.state.target = table;
                this.state.startX = pointer.x;
                this.state.startY = pointer.y;
                this.state.originalPos = { x: table.left, y: table.top };
                this.state.originalWidths = [...table.colWidths];
                this.state.originalHeights = [...table.rowHeights];

                table.lockMovementX = true;
                table.lockMovementY = true;
            }

            handleMouseMove(options) {
                if (this.state.isResizing) {
                    this.performResize(options);
                } else {
                    this.detectHover(options);
                }
            }

            performResize(options) {
                const pointer = this.canvas.getPointer(options.e);
                const { target, type, index, startX, startY, originalPos } = this.state;
                const dx = pointer.x - startX;
                const dy = pointer.y - startY;

                switch (type) {
                    // --- INTERNAL RESIZING (PUSH/PULL) ---
                    case 'col': {
                        const newWidth = this.state.originalWidths[index] + dx;
                        const adjacentNewWidth = this.state.originalWidths[index + 1] - dx;
                        if (newWidth >= this.MIN_CELL_SIZE && adjacentNewWidth >= this.MIN_CELL_SIZE) {
                            target.colWidths[index] = newWidth;
                            target.colWidths[index + 1] = adjacentNewWidth;
                        }
                        break;
                    }
                    case 'row': {
                        const newHeight = this.state.originalHeights[index] + dy;
                        const adjacentNewHeight = this.state.originalHeights[index + 1] - dy;
                        if (newHeight >= this.MIN_CELL_SIZE && adjacentNewHeight >= this.MIN_CELL_SIZE) {
                            target.rowHeights[index] = newHeight;
                            target.rowHeights[index + 1] = adjacentNewHeight;
                        }
                        break;
                    }
                    // --- EDGE RESIZING (PIVOT LOGIC) ---
                    case 'edge-right': {
                        const newWidth = this.state.originalWidths[index] + dx;
                        if (newWidth >= this.MIN_CELL_SIZE) {
                            target.colWidths[index] = newWidth;
                            // [FIX] Move the table's center by HALF the delta to keep the left edge anchored.
                            target.left = originalPos.x + dx / 2;
                        }
                        break;
                    }
                    case 'edge-left': {
                        const newWidth = this.state.originalWidths[index] - dx;
                        if (newWidth >= this.MIN_CELL_SIZE) {
                            target.colWidths[index] = newWidth;
                            // Move the table's center by HALF the delta to keep the right edge anchored.
                            target.left = originalPos.x + dx / 2;
                        }
                        break;
                    }
                    case 'edge-bottom': {
                        const newHeight = this.state.originalHeights[index] + dy;
                        if (newHeight >= this.MIN_CELL_SIZE) {
                            target.rowHeights[index] = newHeight;
                            // [FIX] Move the table's center by HALF the delta to keep the top edge anchored.
                            target.top = originalPos.y + dy / 2;
                        }
                        break;
                    }
                    case 'edge-top': {
                        const newHeight = this.state.originalHeights[index] - dy;
                        if (newHeight >= this.MIN_CELL_SIZE) {
                            target.rowHeights[index] = newHeight;
                            // Move the table's center by HALF the delta to keep the bottom edge anchored.
                            target.top = originalPos.y + dy / 2;
                        }
                        break;
                    }
                }

                // This function recalculates total dimensions and repositions internal cells.
                updateTableLayout(target);

                // We must re-render the canvas to see the changes.
                this.canvas.requestRenderAll();
            }

            detectHover(options) {
                const target = this.canvas.findTarget(options.e);
                if (!target || !target.isTable || !target.hasControls) {
                    if (this.canvas.defaultCursor !== 'default') this.canvas.defaultCursor = 'default';
                    if (this.canvas.hoverCursor !== 'default') this.canvas.hoverCursor = 'default';
                    return;
                }

                const pointer = this.canvas.getPointer(options.e);
                const table = target;
                const localPoint = table.toLocalPoint(new fabric.Point(pointer.x, pointer.y), 'center', 'center');

                let onBoundary = false;

                let currentX = -table.width / 2;
                for (let c = 0; c < table.cols; c++) {
                    if (c === 0 && Math.abs(localPoint.x - currentX) < this.RESIZE_HANDLE_AREA) {
                        this.canvas.defaultCursor = 'ew-resize';
                        this.canvas.hoverCursor = 'ew-resize';
                        this.state.type = 'edge-left';
                        this.state.index = 0;
                        onBoundary = true; break;
                    }
                    currentX += table.colWidths[c];
                    if (Math.abs(localPoint.x - currentX) < this.RESIZE_HANDLE_AREA) {
                        this.canvas.defaultCursor = 'ew-resize';
                        this.canvas.hoverCursor = 'ew-resize';
                        this.state.type = (c === table.cols - 1) ? 'edge-right' : 'col';
                        this.state.index = c;
                        onBoundary = true; break;
                    }
                }

                if (!onBoundary) {
                    let currentY = -table.height / 2;
                    for (let r = 0; r < table.rows; r++) {
                        if (r === 0 && Math.abs(localPoint.y - currentY) < this.RESIZE_HANDLE_AREA) {
                            this.canvas.defaultCursor = 'ns-resize';
                            this.canvas.hoverCursor = 'ns-resize';
                            this.state.type = 'edge-top';
                            this.state.index = 0;
                            onBoundary = true; break;
                        }
                        currentY += table.rowHeights[r];
                        if (Math.abs(localPoint.y - currentY) < this.RESIZE_HANDLE_AREA) {
                            this.canvas.defaultCursor = 'ns-resize';
                            this.canvas.hoverCursor = 'ns-resize';
                            this.state.type = (r === table.rows - 1) ? 'edge-bottom' : 'row';
                            this.state.index = r;
                            onBoundary = true; break;
                        }
                    }
                }

                if (!onBoundary) {
                    this.canvas.defaultCursor = 'default';
                    this.canvas.hoverCursor = 'default';
                }
            }

            handleMouseUp() {
                if (this.state.isResizing) {
                    if (this.state.target) {
                        this.state.target.originalColWidths = [...this.state.target.colWidths];
                        this.state.target.originalRowHeights = [...this.state.target.rowHeights];
                    }
                    this.resetState();
                    this.canvas.requestRenderAll();
                }
            }
        }
        const tableResizer = new TableResizer(canvas);
        tableResizer.init();

        canvas.on('mouse:down', (options) => {
            if (activeTableCellEditor) closeTableCellEditor({ commit: true });
            const table = options.target;
            if (!table || !table.isTable) return;
            if (tableResizer.state.isResizing || canvas.defaultCursor.includes('resize')) return;

            const pointer = canvas.getPointer(options.e);
            const hit = getTableCellFromPointer(table, pointer);
            if (!hit) return;

            const append = !!options.e.shiftKey;
            const toggle = !!(options.e.ctrlKey || options.e.metaKey);
            if (!append && !toggle) clearTableCellSelections(table);

            setSelectedTableCells(table, [hit.index], { append, toggle });
            refreshInspector({ target: table });
            updateFloatingLinker(table);
        });

        canvas.on('mouse:dblclick', (options) => {
            const table = options.target;
            if (!table || !table.isTable) return;
            if (tableResizer.state.isResizing || canvas.defaultCursor.includes('resize')) return;

            const pointer = canvas.getPointer(options.e);
            const hit = getTableCellFromPointer(table, pointer);
            if (!hit) return;

            clearTableCellSelections(table);
            setSelectedTableCells(table, [hit.index]);
            startTableCellEditor(table, hit.index);
            refreshInspector({ target: table });
            updateFloatingLinker(table);
        });

        canvas.on('mouse:wheel', () => {
            if (activeTableCellEditor) closeTableCellEditor({ commit: true });
        });


        document.getElementById('imageUpload').addEventListener('change', e => { if (!e.target.files || !e.target.files[0]) return; const reader = new FileReader(); reader.onload = (ev) => { const spawn = getDefaultSpawnPoint(); adders.image(spawn.x, spawn.y, ev.target.result); e.target.value = ''; }; reader.readAsDataURL(e.target.files[0]); });
        document.querySelectorAll('.shape-chip').forEach(chip => { const type = chip.getAttribute('data-add'); chip.addEventListener('dragstart', e => { e.dataTransfer.setData('text/plain', `component:${type}`); }); chip.addEventListener('click', () => { if (!adders[type]) return; if (type === 'image') { $('#imageUpload').click(); return; } const spawn = getDefaultSpawnPoint(); adders[type](spawn.x, spawn.y); }); });
        const dropTarget = canvas.upperCanvasEl; canvas.calcOffset();
        dropTarget.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
        dropTarget.addEventListener('drop', (e) => {
            e.preventDefault(); const { x, y } = canvas.getPointer(e); const data = e.dataTransfer.getData('text/plain'); const [dataType, value] = data.split(/:(.*)/s);
            if (dataType === 'component' && adders[value]) { if (value === 'image') { const file = e.dataTransfer.files?.[0]; if (file?.type.startsWith('image/')) { const reader = new FileReader(); reader.onload = (ev) => adders.image(x, y, ev.target.result); reader.readAsDataURL(file); } else { $('#imageUpload').click(); } } else { adders[value](x, y); } }
            else if (dataType === 'element') { const elementData = JSON.parse(value); adders.image(x, y, elementData.image_url, { oid: elementData.id }); }
        });

        // --- SIDEBAR RESIZING & TOGGLING ---
        const mainLayout = document.getElementById('main-layout'); const leftResizer = document.getElementById('left-resizer'); const rightResizer = document.getElementById('right-resizer'); let isResizingLeft = false, isResizingRight = false; let lastLeftPanelWidth = '300px', lastRightPanelWidth = '300px'; mainLayout.style.gridTemplateColumns = `${lastLeftPanelWidth} 5px 1fr 5px ${lastRightPanelWidth}`;
        function initResizer(resizer, resizeFlagSetter, panelSide) { resizer.addEventListener('mousedown', (e) => { e.preventDefault(); resizeFlagSetter(true); document.body.style.cursor = 'col-resize'; document.body.style.userSelect = 'none'; }); document.addEventListener('mousemove', (e) => { if (!resizeFlagSetter()) return; const mainRect = mainLayout.getBoundingClientRect(); if (panelSide === 'left') { const newWidth = e.clientX - mainRect.left; if (newWidth > 150 && newWidth < mainRect.width / 2) { mainLayout.style.gridTemplateColumns = `${newWidth}px 5px 1fr 5px ${mainLayout.style.gridTemplateColumns.split(' ')[4]}`; lastLeftPanelWidth = `${newWidth}px`; } } else { const newWidth = mainRect.right - e.clientX; if (newWidth > 200 && newWidth < mainRect.width / 2) { mainLayout.style.gridTemplateColumns = `${mainLayout.style.gridTemplateColumns.split(' ')[0]} 5px 1fr 5px ${newWidth}px`; lastRightPanelWidth = `${newWidth}px`; } } canvas.setWidth(canvasWrapper.getBoundingClientRect().width); canvas.renderAll(); }); document.addEventListener('mouseup', () => { if (resizeFlagSetter()) { resizeFlagSetter(false); document.body.style.cursor = 'default'; document.body.style.userSelect = 'auto'; } }); }
        initResizer(leftResizer, (v) => { if (v !== undefined) isResizingLeft = v; return isResizingLeft; }, 'left'); initResizer(rightResizer, (v) => { if (v !== undefined) isResizingRight = v; return isResizingRight; }, 'right');
        function refreshCanvasSize() { setTimeout(() => { const { width, height } = canvasWrapper.getBoundingClientRect(); canvas.setWidth(width); canvas.setHeight(height); canvas.renderAll(); centerAndFitPage(); }, 50); }
        document.getElementById('left-panel-toggle').addEventListener('click', () => {
            const btn = document.getElementById('left-panel-toggle'); const cols = mainLayout.style.gridTemplateColumns.split(' '); if (cols[0] !== '0px') {
                lastLeftPanelWidth = cols[0]; mainLayout.style.gridTemplateColumns = `0px 0px 1fr 5px ${cols[4]}`;
                document.querySelector('.panel.left')?.classList.add('collapsed'); btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
            } else {
                mainLayout.style.gridTemplateColumns = `${lastLeftPanelWidth} 5px 1fr 5px ${cols[4]}`;
                document.querySelector('.panel.left')?.classList.remove('collapsed'); btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`;
            } refreshCanvasSize();
        });
        document.getElementById('right-panel-toggle').addEventListener('click', () => {
            const btn = document.getElementById('right-panel-toggle'); const cols = mainLayout.style.gridTemplateColumns.split(' '); if (cols[4] !== '0px') {
                lastRightPanelWidth = cols[4]; mainLayout.style.gridTemplateColumns = `${cols[0]} 5px 1fr 0px 0px`;
                document.querySelector('.panel.right')?.classList.add('collapsed'); btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>`;
            } else {
                mainLayout.style.gridTemplateColumns = `${cols[0]} 5px 1fr 5px ${lastRightPanelWidth}`;
                document.querySelector('.panel.right')?.classList.remove('collapsed'); btn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
            } refreshCanvasSize();
        });
        // --- REBUILT: SNAPPING GUIDES ---
        const snapThreshold = 10, snapColor = '#ed7062';
        let snapLines = [], snapHighlightBox = null;

        function handleSmartSnapping(options) {
            if (!snapEnabled) return;
            if (options?.transform?.action === 'modifyLineEndpoint') return;

            const target = options.target;
            if (!target || target.locked || target.isArtboard) return;

            clearSnapLines();
            clearSnapHighlight();

            const zoom = canvas.getZoom() || 1;
            let snapX = null;
            let snapY = null;
            let snapObject = null;

            const selectedMembers = target.type === 'activeSelection'
                ? new Set(target.getObjects())
                : new Set([target]);

            const otherObjects = canvas.getObjects().filter(o =>
                o.visible &&
                o.evented &&
                !selectedMembers.has(o) &&
                !o.excludeFromExport &&
                !o.isSnapLine &&
                !o.isArtboard
            );

            const checkSnap = (targetPoint, objPoint, axis, obj) => {
                if (Math.abs(targetPoint - objPoint) >= snapThreshold / zoom) return;
                const current = axis === 'X' ? snapX : snapY;
                const next = { targetPoint, objPoint };
                if (!current || Math.abs(targetPoint - objPoint) < Math.abs(current.targetPoint - current.objPoint)) {
                    if (axis === 'X') snapX = next;
                    else snapY = next;
                    snapObject = obj;
                }
            };

            const getEdges = (obj) => {
                obj.setCoords();
                const rect = obj.getBoundingRect(true, true);
                return {
                    left: rect.left,
                    right: rect.left + rect.width,
                    top: rect.top,
                    bottom: rect.top + rect.height,
                    centerX: rect.left + rect.width / 2,
                    centerY: rect.top + rect.height / 2
                };
            };

            const targetEdges = getEdges(target);

            if (pageRect) {
                const pageEdges = getEdges(pageRect);
                checkSnap(targetEdges.centerX, pageEdges.centerX, 'X', pageRect);
                checkSnap(targetEdges.left, pageEdges.left, 'X', pageRect);
                checkSnap(targetEdges.right, pageEdges.right, 'X', pageRect);
                checkSnap(targetEdges.centerY, pageEdges.centerY, 'Y', pageRect);
                checkSnap(targetEdges.top, pageEdges.top, 'Y', pageRect);
                checkSnap(targetEdges.bottom, pageEdges.bottom, 'Y', pageRect);
            }

            otherObjects.forEach(obj => {
                const edges = getEdges(obj);
                [edges.left, edges.centerX, edges.right].forEach(x => {
                    checkSnap(targetEdges.left, x, 'X', obj);
                    checkSnap(targetEdges.centerX, x, 'X', obj);
                    checkSnap(targetEdges.right, x, 'X', obj);
                });
                [edges.top, edges.centerY, edges.bottom].forEach(y => {
                    checkSnap(targetEdges.top, y, 'Y', obj);
                    checkSnap(targetEdges.centerY, y, 'Y', obj);
                    checkSnap(targetEdges.bottom, y, 'Y', obj);
                });
            });

            if (snapX) target.left -= (snapX.targetPoint - snapX.objPoint);
            if (snapY) target.top -= (snapY.targetPoint - snapY.objPoint);
            target.setCoords();

            if (snapX) drawSnapLine({ x1: snapX.objPoint, y1: -5000, x2: snapX.objPoint, y2: 5000 });
            if (snapY) drawSnapLine({ y1: snapY.objPoint, x1: -5000, y2: snapY.objPoint, x2: 5000 });
            if (snapObject && snapObject !== pageRect) drawSnapHighlight(snapObject);
        }

        function drawSnapLine(coords) {
            const line = new fabric.Line([coords.x1, coords.y1, coords.x2, coords.y2], {
                stroke: snapColor,
                strokeWidth: 1,
                selectable: false,
                evented: false,
                isSnapLine: true,
                excludeFromExport: true
            });
            snapLines.push(line);
            canvas.add(line);
            line.bringToFront();
        }

        function drawSnapHighlight(obj) {
            if (!obj) return;

            obj.setCoords(); // update object coordinates

            // get bounding rect in canvas space
            const rect = obj.getBoundingRect(true); // pass `true` to get absolute coordinates including transformations

            clearSnapHighlight();

            snapHighlightBox = new fabric.Rect({
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height,
                originX: 'left',
                originY: 'top',
                selectable: false,
                evented: false,
                fill: 'transparent',
                stroke: snapColor,
                strokeWidth: 1,
                isSnapLine: true,
                excludeFromExport: true,
                strokeDashArray: [4, 4],
            });

            canvas.add(snapHighlightBox);
            snapHighlightBox.bringToFront();
        }

        function clearSnapLines() {
            snapLines.forEach(line => canvas.remove(line));
            snapLines = [];
            clearSnapHighlight();
        }

        function clearSnapHighlight() {
            if (snapHighlightBox) {
                canvas.remove(snapHighlightBox);
                snapHighlightBox = null;
            }
        }

        canvas.on('before:transform', clearSnapLines);
        canvas.on('selection:cleared', clearSnapLines);

        // --- SETTINGS & API KEY MODAL ---
        const settingsBtn = $('#settingsBtn'); const settingsModal = $('#settingsModal'); const closeSettingsModalBtn = $('#closeSettingsModal');
        settingsBtn.addEventListener('click', openSettingsModal); closeSettingsModalBtn.addEventListener('click', () => settingsModal.style.display = 'none'); settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) { settingsModal.style.display = 'none'; } });
        const openCustomerPortal = async () => { const btn = $('#manageSubscriptionBtn'); if (btn) { btn.disabled = true; btn.textContent = 'Generating link...'; } try { const { data, error } = await supabase.functions.invoke('lemonsqueezy-sub-manager', { body: { action: 'getPortalLink' } }); if (error) throw error; if (data && data.url) window.open(data.url, '_blank'); else throw new Error('Could not generate portal link.'); } catch (error) { alert(`Error: ${error.message}`); } finally { if (btn) { btn.disabled = false; btn.textContent = 'Manage Subscription'; } } };
        async function openSettingsModal() { const settingsContent = $('#settingsContent'); settingsContent.innerHTML = '<p class="muted">Loading account details...</p>'; settingsModal.style.display = 'flex'; const { data: { user } } = await supabase.auth.getUser(); if (!user) { settingsContent.innerHTML = '<p>Please log in to manage your settings.</p>'; return; } const { data: profile, error } = await supabase.from('profiles').select('role').eq('id', user.id).single(); if (error || !profile) { settingsContent.innerHTML = '<p class="error">Could not load your profile.</p>'; return; } const currentTheme = localStorage.getItem('csvlink-theme') || 'dark'; let modalHTML = `<div class="settings-section stack"><h4>Appearance</h4><button id="themeToggleBtn" class="btn ghost" style="width: 100%;">${currentTheme === 'dark' ? 'Switch to Light Mode' : 'Switch to Dark Mode'}</button></div><div class="settings-section stack" style="gap: 16px;"><h4>Account</h4><div class="stack"><label for="newPassword">New Password</label><input type="password" id="newPassword" placeholder="Enter new password"></div><div class="stack"><label for="confirmPassword">Confirm Password</label><input type="password" id="confirmPassword" placeholder="Confirm new password"></div><button id="changePasswordBtn" class="btn">Update Password</button><p id="passwordMessage" class="muted" style="text-align:center; margin-top: 4px;"></p></div>`; if (profile.role === 'pro' || profile.role === 'admin') { modalHTML += `<div class="settings-section stack"><h4>Subscription</h4><p class="muted">You are on the Pro plan.</p><button id="manageSubscriptionBtn" class="btn ghost" style="width: 100%;">Manage Subscription</button></div>`; } else { modalHTML += `<div class="settings-section stack"><h4>Upgrade to Pro</h4><p class="muted">Upgrade for API access and unlimited templates.</p><a href="/#pricing" class="btn" style="text-decoration: none;">View Pricing Plans</a></div>`; } if (profile.role === 'pro' || profile.role === 'admin') { modalHTML += `<div class="settings-section stack" style="gap: 16px;"><h4>Developer API Keys</h4><div id="newKeyContainer" class="stack" style="display:none;"><h5>Your New API Key</h5><p class="muted">Copy this key and store it safely. <strong>You will not see it again.</strong></p><div id="newKeyDisplay"></div></div><div class="stack"><h5>Your Existing Keys</h5><div id="existingKeysList" class="stack">Loading...</div></div><button id="generateKeyBtn" class="btn">Generate New API Key</button><p id="keyMessage" class="muted" style="text-align:center; margin-top: 4px;"></p></div>`; } settingsContent.innerHTML = modalHTML; attachSettingsEventListeners(user.id, profile.role); }
        function attachSettingsEventListeners(userId, role) { on('#themeToggleBtn', 'click', toggleTheme); on('#changePasswordBtn', 'click', async () => { const newPassword = $('#newPassword').value, confirmPassword = $('#confirmPassword').value, msgEl = $('#passwordMessage'); if (!newPassword || newPassword !== confirmPassword) { msgEl.textContent = 'Passwords do not match or are empty.'; return; } msgEl.textContent = 'Updating...'; const { error } = await supabase.auth.updateUser({ password: newPassword }); if (error) { msgEl.textContent = `Error: ${error.message}`; } else { msgEl.textContent = 'Password updated successfully!'; $('#newPassword').value = ''; $('#confirmPassword').value = ''; } }); if (role === 'pro' || role === 'admin') { on('#generateKeyBtn', 'click', handleGenerateKey); loadAndDisplayKeys(userId); if ($('#manageSubscriptionBtn')) on('#manageSubscriptionBtn', 'click', openCustomerPortal); } }
        function applyTheme(theme) {
            document.body.classList.toggle('light-mode', theme === 'light');
            localStorage.setItem('csvlink-theme', theme);
            // page outline for visibility
            if (pageRect) {
                pageRect.set({ stroke: theme === 'light' ? 'rgba(15,23,42,0.25)' : 'rgba(255,255,255,0.25)', strokeWidth: 1 });
                canvas.requestRenderAll();
            }
            const icon = $('#themeIconSvg');
            if (icon) {
                icon.innerHTML = (theme === 'light')
                    ? '<circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="M4.93 4.93l1.41 1.41"/><path d="M17.66 17.66l1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="M4.93 19.07l1.41-1.41"/><path d="M17.66 6.34l1.41-1.41"/>'
                    : '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>';
            }
        }
        function toggleTheme() {
            const newTheme = (localStorage.getItem('csvlink-theme') || 'dark') === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
            const themeBtn = $('#themeToggleBtn');
            if (themeBtn) themeBtn.textContent = newTheme === 'dark' ? 'Switch to Light Mode' : 'Switch to Dark Mode';
        }
        // toolbar icon toggle
        $('#themeIconBtn')?.addEventListener('click', toggleTheme);
        async function loadAndDisplayKeys(userId) { const list = $('#existingKeysList'); const { data: keys, error } = await supabase.from('api_keys').select('api_key, created_at').eq('user_id', userId); if (error) { list.innerHTML = '<p class="error">Could not load keys.</p>'; return; } if (keys.length === 0) { list.innerHTML = '<p class="muted">No API keys generated.</p>'; } else { list.innerHTML = keys.map(k => `<div class="api-key-item"><span>${k.api_key.substring(0, 11)}...${k.api_key.substring(k.api_key.length - 4)}</span><span class="muted">Created: ${new Date(k.created_at).toLocaleDateString()}</span></div>`).join(''); } }
        async function handleGenerateKey() { const btn = $('#generateKeyBtn'), msg = $('#keyMessage'), container = $('#newKeyContainer'), display = $('#newKeyDisplay'); btn.disabled = true; btn.textContent = 'Generating...'; msg.textContent = ''; container.style.display = 'none'; try { const { data, error } = await supabase.functions.invoke('generate-api-key'); if (error) throw error; display.textContent = data.apiKey; container.style.display = 'block'; const { data: { user } } = await supabase.auth.getUser(); loadAndDisplayKeys(user.id); } catch (error) { msg.textContent = `Error: ${error.message}`; } finally { btn.disabled = false; btn.textContent = 'Generate New API Key'; } }

        // --- INSPECTOR & HELPERS ---
        const inspector = $('#inspector'); const multiInspector = $('#multiSelectInspector');
        canvas.on('selection:created', (e) => {
            if (activeTableCellEditor) closeTableCellEditor({ commit: true });
            if (!e.target?.isTable) clearTableCellSelections();
            refreshInspector(e);
            renderLayers();
            updateFloatingLinker(e.target);
        });
        canvas.on('selection:updated', (e) => {
            if (activeTableCellEditor) closeTableCellEditor({ commit: true });
            if (!e.target?.isTable) clearTableCellSelections();
            refreshInspector(e);
            renderLayers();
            updateFloatingLinker(e.target);
        });
        canvas.on('selection:cleared', () => {
            if (activeTableCellEditor) closeTableCellEditor({ commit: true });
            clearTableCellSelections();
            $('#noSelection').style.display = 'block';
            inspector.style.display = 'none';
            multiInspector.style.display = 'none';
            renderPageInspector();
            renderLayers();
            updateFloatingLinker(null);
        });
        function updateLiveInspector(options) { const target = options.target; if (!target || target.type === 'activeSelection') return; const updateValue = (id, value) => { const el = document.getElementById(id); if (el) el.value = value; }; updateValue('inspector-pos-x', Math.round(target.left)); updateValue('inspector-pos-y', Math.round(target.top)); updateValue('inspector-dim-w', Math.round(target.getScaledWidth())); updateValue('inspector-dim-h', Math.round(target.getScaledHeight())); updateValue('inspector-opacity-slider', target.opacity); updateValue('inspector-opacity-input', target.opacity); updateValue('inspector-stroke-width-slider', target.strokeWidth); updateValue('inspector-stroke-width-input', target.strokeWidth); if (target.rx !== undefined) { updateValue('inspector-corner-radius-slider', target.rx); updateValue('inspector-corner-radius-input', target.rx); } }
        function refreshInspector(e) { const target = e.target || canvas.getActiveObject(); if (!target) return; if (target.type === 'activeSelection') { inspector.style.display = 'none'; multiInspector.style.display = 'grid'; $('#noSelection').style.display = 'none'; renderMultiSelectInspector(target); } else { multiInspector.style.display = 'none'; inspector.style.display = 'grid'; $('#noSelection').style.display = 'none'; renderSingleObjectInspector(target); } }
        function getCommonPropertyValue(objects, property) { const firstValue = objects[0][property]; for (let i = 1; i < objects.length; i++) { if (objects[i][property] !== firstValue) return ''; } return firstValue; }
        function setCommonPropertyValue(objects, property, value) { objects.forEach(obj => obj.set(property, value)); canvas.renderAll(); requestSaveState(); }
        function selectSameTypeObjects(baseObject) {
            if (!baseObject) return;
            const matches = canvas.getObjects().filter(obj => {
                if (!obj || obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine || obj.isArtboard) return false;
                if (obj.locked) return false;
                if (baseObject.isTable) return !!obj.isTable;
                if (baseObject.isSvgGroup) return !!obj.isSvgGroup;
                return obj.type === baseObject.type && !obj.isTable && !obj.isSvgGroup;
            });

            if (!matches.length) return;
            if (matches.length === 1) canvas.setActiveObject(matches[0]);
            else canvas.setActiveObject(new fabric.ActiveSelection(matches, { canvas }));
            canvas.requestRenderAll();
            refreshInspector({ target: canvas.getActiveObject() });
        }
        function renderMultiSelectInspector(selection) {
            multiInspector.innerHTML = '';
            const objects = selection.getObjects();

            // Check if all selected objects are text
            const allText = objects.every(obj => obj.type === 'textbox');

            multiInspector.appendChild(section('Actions', [
                buttonRow('Group', () => { if (selection.size() > 1) selection.toGroup(); canvas.requestRenderAll(); }),
                buttonRow('Remove', () => { objects.forEach(obj => canvas.remove(obj)); canvas.discardActiveObject().renderAll(); })
            ]));

            // Alignment for multiple objects
            multiInspector.appendChild(section('Align Objects', [alignMultipleObjectsButtons()]));
            multiInspector.appendChild(section('Align to Page', [alignToPageButtons(true)]));
            multiInspector.appendChild(section('Distribute', [distributeButtons()]));

            // If all selected are text, show text formatting
            if (allText) {
                const commonFontSize = getCommonPropertyValue(objects, 'fontSize');
                const commonFontFamily = getCommonPropertyValue(objects, 'fontFamily');
                const commonFill = getCommonPropertyValue(objects, 'fill');
                const commonTextAlign = getCommonPropertyValue(objects, 'textAlign');
                const commonFontWeight = getCommonPropertyValue(objects, 'fontWeight');
                const commonFontStyle = getCommonPropertyValue(objects, 'fontStyle');
                const commonUnderline = getCommonPropertyValue(objects, 'underline');

                multiInspector.appendChild(section('Text Formatting', [
                    inputRow('Font Size', commonFontSize || '', v => setCommonPropertyValue(objects, 'fontSize', parseFloat(v) || 14)),
                    selectRow('Font Family', FONT_LIST, commonFontFamily || 'Arial', v => setCommonPropertyValue(objects, 'fontFamily', v)),
                    colorInputRow('Text Color', commonFill || '#000000', v => setCommonPropertyValue(objects, 'fill', v)),
                    buttonGroupRow('Text Style', [
                        { value: 'bold', label: 'B', active: commonFontWeight === 'bold' },
                        { value: 'italic', label: 'I', active: commonFontStyle === 'italic' },
                        { value: 'underline', label: 'U', active: commonUnderline === true }
                    ], null, (v) => {
                        objects.forEach(obj => {
                            if (v === 'bold') obj.set('fontWeight', obj.fontWeight === 'bold' ? 'normal' : 'bold');
                            else if (v === 'italic') obj.set('fontStyle', obj.fontStyle === 'italic' ? 'normal' : 'italic');
                            else if (v === 'underline') obj.set('underline', !obj.underline);
                        });
                        canvas.renderAll();
                        requestSaveState();
                        refreshInspector({ target: selection });
                    }),
                    buttonGroupRow('Alignment', ['left', 'center', 'right', 'justify'], commonTextAlign || 'left', v => {
                        objects.forEach(obj => { obj.set({ textAlign: v }); obj.initDimensions(); });
                        canvas.requestRenderAll();
                        requestSaveState();
                    })
                ]));
            }

            multiInspector.appendChild(section('Common', [
                sliderRow('Opacity', getCommonPropertyValue(objects, 'opacity') ?? 1, (v) => setCommonPropertyValue(objects, 'opacity', v), { min: 0, max: 1, step: 0.01 }),
                colorInputRow('Stroke Color', getCommonPropertyValue(objects, 'stroke') ?? '', v => setCommonPropertyValue(objects, 'stroke', v)),
                sliderRow('Stroke Width', getCommonPropertyValue(objects, 'strokeWidth') ?? 0, (v) => setCommonPropertyValue(objects, 'strokeWidth', v), { min: 0, max: 50, step: 1 })
            ]));
        }



        function setObjectDimensions(obj, w, h, opts = {}) {
            const lockWidth = !!opts.lockWidth;
            const minSize = 1;
            if (!obj || !obj.width || !obj.height) return;
            const newW = Math.max(minSize, Number(w) || obj.getScaledWidth());
            const newH = Math.max(minSize, Number(h) || obj.getScaledHeight());

            const baseW = obj.width;
            const baseH = obj.height;

            if (!lockWidth) obj.scaleX = newW / baseW;
            obj.scaleY = newH / baseH;
            obj.setCoords();
        }

        function dimensionsRow(obj) {
            const isTextbox = obj?.type === 'textbox';
            const w = document.createElement('div');
            w.className = 'stack full-width';
            w.innerHTML = `<label>Dimensions</label>`;
            const r = document.createElement('div');
            r.className = 'row';

            const x = document.createElement('input');
            x.type = 'number';
            x.value = Math.round(obj.getScaledWidth());
            x.id = 'inspector-dim-w';

            const y = document.createElement('input');
            y.type = 'number';
            y.value = Math.round(obj.getScaledHeight());
            y.id = 'inspector-dim-h';

            if (isTextbox) {
                x.disabled = true;
                x.title = 'Text box width is locked. Use the text box handles to resize width.';
                x.style.opacity = '0.6';
            }

            const update = () => {
                setObjectDimensions(obj, x.value, y.value, { lockWidth: isTextbox });
                canvas.requestRenderAll();
                updateLiveInspector({ target: canvas.getActiveObject() });
            };
            const finalUpdate = () => { update(); requestSaveState(); };
            x.oninput = update; y.oninput = update;
            x.onchange = finalUpdate; y.onchange = finalUpdate;

            r.append(x, y);
            w.appendChild(r);
            return w;
        }

        function renderSingleObjectInspector(o) {
            inspector.innerHTML = '';
            const actions = [];
            if (o.type === 'group' && !o.isTable && !o.isSvgGroup) actions.push(buttonRow('Ungroup', () => o.toActiveSelection()));
            actions.push(buttonRow('Select Same Type', () => selectSameTypeObjects(o)));
            actions.push(buttonRow('Remove', () => canvas.remove(o)));
            inspector.appendChild(section('Actions', actions));

            inspector.appendChild(section('Advanced Links', [buttonRow(`Manage Links (${getBindingsFor(o).length})`, () => { selectedObjectForManager = o; openDataLinksManager(); })]));
            if (o.type === 'image') inspector.appendChild(section('Image', [buttonRow('Crop Image', () => openVisualCropper(o))]));
            if (['rect', 'image', 'circle', 'triangle', 'polygon'].includes(o.type)) { const shapeProps = []; if (['rect', 'image'].includes(o.type)) shapeProps.push(sliderRow('Corner Radius', o.rx ?? 0, (v) => o.set({ rx: v, ry: v }), { min: 0, max: Math.min(o.width, o.height) / 2, step: 1 })); inspector.appendChild(section('Shape Properties', shapeProps)); }

            if (o.isSvgGroup) {
                inspector.appendChild(section('SVG Style', [
                    colorInputRow('Fill', o.fill, v => { o.set('fill', v); o.forEachObject(sub => { if (sub.fill !== 'none') sub.set({ fill: v }) }); }),
                    colorInputRow('Stroke', o.stroke, v => { o.set('stroke', v); o.forEachObject(sub => sub.set({ stroke: v })); }),
                    sliderRow('Stroke Width', o.strokeWidth ?? 1, v => {
                        o.set({ strokeWidth: parseFloat(v) });
                        o.forEachObject(sub => sub.set({ strokeWidth: parseFloat(v) }));
                        // Fix for pivot shift: setCoords and recalibrate if group
                        o.setCoords();
                        if (o.type === 'group') {
                            // This re-calculates the group size based on children
                            const center = o.getCenterPoint();
                            o.addWithUpdate();
                            o.setPositionByOrigin(center, 'center', 'center');
                        }
                        canvas.renderAll();
                        requestSaveState();
                    }, { min: 0, max: 20, step: 0.5 })
                ]));
            }

            if (['rect', 'triangle', 'circle', 'polygon', 'path'].includes(o.type)) { inspector.appendChild(section('Fill', [colorInputRow('Color', o.fill, v => o.set({ fill: v })), buttonRow('Fill with Image', () => { editingFillObject = o; $('#imageFillUpload').click(); })])); $('#imageFillUpload').onchange = e => { if (!e.target.files?.[0] || !editingFillObject) return; const reader = new FileReader(); reader.onload = ev => { fabric.Image.fromURL(ev.target.result, img => { editingFillObject.set('fill', new fabric.Pattern({ source: img.getElement(), repeat: 'repeat' })); canvas.renderAll(); requestSaveState(); }, { crossOrigin: 'anonymous' }); }; reader.readAsDataURL(e.target.files[0]); e.target.value = ''; }; }
            if (['rect', 'triangle', 'circle', 'polygon', 'path', 'line'].includes(o.type)) {
                inspector.appendChild(section('Stroke', [
                    colorInputRow('Color', o.stroke || '#000000', v => {
                        o.set({ stroke: v || null });
                    }),
                    sliderRow('Width', o.strokeWidth ?? 1, v => {
                        o.set({ strokeWidth: Math.max(0, parseFloat(v) || 0) });
                        o.setCoords();
                    }, { min: 0, max: 40, step: 0.5 })
                ]));
            }

            if (o.isTable) {
                ensureTableCellData(o);
                const selectedCells = getSelectedTableCellIndices(o);
                const singleSelectedCellIndex = selectedCells.length === 1 ? selectedCells[0] : -1;
                const cellTextBinding = singleSelectedCellIndex >= 0
                    ? getBindingsFor(o).find(b => b.property === 'Cell Text' && getNormalizedBindingCellIndex(o, b) === singleSelectedCellIndex)
                    : null;
                const selectionInfo = document.createElement('div');
                selectionInfo.className = 'full-width muted';
                selectionInfo.style.fontSize = '11px';
                selectionInfo.style.marginBottom = '6px';
                selectionInfo.textContent = selectedCells.length
                    ? `${selectedCells.length} cell(s) selected`
                    : 'No cells selected. Click table cells (Shift/Ctrl for multi-select). Double-click a cell to edit.';

                const cellLinkInfo = document.createElement('div');
                cellLinkInfo.className = 'full-width muted';
                cellLinkInfo.style.fontSize = '11px';
                if (singleSelectedCellIndex < 0) {
                    cellLinkInfo.textContent = 'Data Link: select exactly one cell to link it to a data column.';
                } else {
                    cellLinkInfo.textContent = `Data Link ${tableCellRefLabel(o, singleSelectedCellIndex)}: ${cellTextBinding?.column || 'not linked'}`;
                }

                const tableRows = [
                    selectionInfo,
                    cellLinkInfo,
                    buttonRow('Link Selected Cell To Column', () => {
                        if (singleSelectedCellIndex < 0) {
                            showNotification('Select exactly one table cell first.');
                            return;
                        }
                        let binding = cellTextBinding;
                        if (!binding) {
                            binding = saveBinding(o, { column: '', property: 'Cell Text', cellIndex: singleSelectedCellIndex });
                        } else {
                            binding.cellIndex = singleSelectedCellIndex;
                            requestSaveState();
                        }
                        openColumnSelectionModal(o, binding, {
                            onLinked: () => {
                                if (dataLinksManagerModal && dataLinksManagerModal.style.display === 'flex') renderDataLinksManager();
                                refreshInspector({ target: o });
                            }
                        });
                    }),
                    buttonRow('Remove Selected Cell Link', () => {
                        if (singleSelectedCellIndex < 0 || !cellTextBinding) {
                            showNotification('No linked cell selected.');
                            return;
                        }
                        removeBinding(o, cellTextBinding);
                        refreshInspector({ target: o });
                    }),
                    buttonRow('Select All Cells', () => {
                        setSelectedTableCells(o, Array.from({ length: o.rows * o.cols }, (_, i) => i));
                        refreshInspector({ target: o });
                    }),
                    buttonRow('Clear Cell Selection', () => {
                        o._selectedCells = new Set();
                        refreshTableSelectionVisual(o);
                        canvas.requestRenderAll();
                        refreshInspector({ target: o });
                    }),
                    inputRow('Rows', o.rows || 1, v => {
                        const targetRows = Math.max(1, parseInt(v, 10) || 1);
                        resizeTableCellData(o, targetRows, Math.max(1, o.cols || 1));
                        o.rowHeights = Array.from({ length: targetRows }, (_, i) => o.rowHeights?.[i] || o.rowHeights?.[0] || 50);
                        o.headerRows = Math.min(o.headerRows || 0, targetRows);
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }, 'number'),
                    inputRow('Columns', o.cols || 1, v => {
                        const targetCols = Math.max(1, parseInt(v, 10) || 1);
                        resizeTableCellData(o, Math.max(1, o.rows || 1), targetCols);
                        o.colWidths = Array.from({ length: targetCols }, (_, i) => o.colWidths?.[i] || o.colWidths?.[0] || 120);
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }, 'number'),
                    inputRow('Header Rows', o.headerRows || 0, v => {
                        o.headerRows = Math.max(0, Math.min(o.rows || 1, parseInt(v, 10) || 0));
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }, 'number'),
                    colorInputRow('Header Fill', o.headerFill || '#f3f4f6', v => {
                        o.headerFill = v;
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }),
                    colorInputRow('Body Fill', o.bodyFill || '#ffffff', v => {
                        o.bodyFill = v;
                        rebuildTableCells(o);
                        canvas.requestRenderAll();
                    }),
                    colorInputRow('Border Color', o.borderColor || '#333333', v => {
                        o.borderColor = v;
                        applyToSelectedTableCells(o, (cell) => { cell.borderColor = v || '#333333'; }, { fallbackAll: true });
                    }),
                    sliderRow('Border Width', o.borderWidth || 1, v => {
                        o.borderWidth = parseFloat(v);
                        applyToSelectedTableCells(o, (cell) => { cell.borderWidth = Math.max(0.5, parseFloat(v) || 1); }, { fallbackAll: true });
                    }, { min: 0, max: 20, step: 0.5 }),
                    inputRow('Cell Text', getCommonSelectedTableCellValue(o, 'text', { fallbackAll: false }) || '', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.text = v; }, { fallbackAll: true });
                    }),
                    colorInputRow('Cell Fill', getCommonSelectedTableCellValue(o, 'fill', { fallbackAll: false }) || '#ffffff', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.fill = v || '#ffffff'; }, { fallbackAll: true });
                    }),
                    colorInputRow('Cell Text Color', getCommonSelectedTableCellValue(o, 'textColor', { fallbackAll: false }) || '#111111', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.textColor = v || '#111111'; }, { fallbackAll: true });
                    }),
                    sliderRow('Cell Font Size', getCommonSelectedTableCellValue(o, 'fontSize', { fallbackAll: false }) || 14, v => {
                        applyToSelectedTableCells(o, (cell) => { cell.fontSize = Math.max(6, parseFloat(v) || 14); }, { fallbackAll: true });
                    }, { min: 6, max: 96, step: 1 }),
                    buttonGroupRow('Cell H Align', ['left', 'center', 'right', 'justify'], getCommonSelectedTableCellValue(o, 'textAlign', { fallbackAll: false }) || '', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.textAlign = v; }, { fallbackAll: true });
                    }),
                    buttonGroupRow('Cell V Align', ['top', 'middle', 'bottom'], getCommonSelectedTableCellValue(o, 'textVAlign', { fallbackAll: false }) || '', v => {
                        applyToSelectedTableCells(o, (cell) => { cell.textVAlign = v; }, { fallbackAll: true });
                    }),
                    buttonRow('Center Text In Cell', () => {
                        applyToSelectedTableCells(o, (cell) => {
                            cell.textAlign = 'center';
                            cell.textVAlign = 'middle';
                        }, { fallbackAll: true });
                    }),
                    iconButtonsRow('Borders', [
                        { icon: tableActionIcon('top'), label: 'Top', title: 'Toggle top border', onClick: () => toggleSelectedTableBorderSide(o, 'top') },
                        { icon: tableActionIcon('right'), label: 'Right', title: 'Toggle right border', onClick: () => toggleSelectedTableBorderSide(o, 'right') },
                        { icon: tableActionIcon('bottom'), label: 'Bottom', title: 'Toggle bottom border', onClick: () => toggleSelectedTableBorderSide(o, 'bottom') },
                        { icon: tableActionIcon('left'), label: 'Left', title: 'Toggle left border', onClick: () => toggleSelectedTableBorderSide(o, 'left') }
                    ]),
                    iconButtonsRow('Structure', [
                        { icon: tableActionIcon('addRow'), label: 'Row+', title: 'Add row', onClick: () => addTableRow(o) },
                        { icon: tableActionIcon('removeRow'), label: 'Row-', title: 'Remove row', onClick: () => removeTableRow(o) },
                        { icon: tableActionIcon('addCol'), label: 'Col+', title: 'Add column', onClick: () => addTableColumn(o) },
                        { icon: tableActionIcon('removeCol'), label: 'Col-', title: 'Remove column', onClick: () => removeTableColumn(o) }
                    ])
                ];
                inspector.appendChild(section('Table', tableRows));
            }

            if (o.type === 'textbox') {
                inspector.appendChild(section('Text', [
                    inputRow('Content', o.text, v => o.set({ text: v }), 'textarea'),
                    inputRow('Font Size', o.fontSize, v => o.set({ fontSize: parseFloat(v) })),
                    (() => {
                        const w = document.createElement('div');
                        w.className = 'stack full-width';
                        w.innerHTML = `<label>Font Family</label>`;
                        const r = document.createElement('div');
                        r.className = 'row';
                        r.style.gap = '8px';

                        const s = document.createElement('select');
                        s.style.flex = '1';
                        FONT_LIST.forEach(opt => s.innerHTML += `<option value="${opt}" ${opt == o.fontFamily ? 'selected' : ''}>${opt}</option>`);
                        s.onchange = e => { o.set({ fontFamily: e.target.value }); canvas.renderAll(); requestSaveState(); };

                        const btn = document.createElement('button');
                        btn.className = 'btn ghost icon-only';
                        btn.title = 'Upload Font';
                        btn.innerHTML = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>';
                        btn.onclick = () => $('#fontUpload').click();

                        r.append(s, btn);
                        w.appendChild(r);
                        return w;
                    })(),
                    colorInputRow('Fill Color', o.fill, v => o.set({ fill: v })),
                    buttonGroupRow('Text Style', [
                        { value: 'bold', label: 'B', active: o.fontWeight === 'bold' },
                        { value: 'italic', label: 'I', active: o.fontStyle === 'italic' },
                        { value: 'underline', label: 'U', active: o.underline === true }
                    ], null, (v) => {
                        if (v === 'bold') o.set('fontWeight', o.fontWeight === 'bold' ? 'normal' : 'bold');
                        else if (v === 'italic') o.set('fontStyle', o.fontStyle === 'italic' ? 'normal' : 'italic');
                        else if (v === 'underline') o.set('underline', !o.underline);
                        canvas.renderAll();
                        requestSaveState();
                        refreshInspector({ target: o });
                    }),
                    buttonGroupRow('Alignment', ['left', 'center', 'right', 'justify'], o.textAlign, v => { o.set({ textAlign: v }); o.initDimensions(); canvas.requestRenderAll(); })
                ]));
            }
            inspector.appendChild(section('Common', [
                xyInputRow('Position', { x: o.left, y: o.top }, (p) => o.set({ left: p.x, top: p.y })),
                xyInputRow('Dimensions', { w: o.getScaledWidth(), h: o.getScaledHeight() }, (d) => { setObjectDimensions(o, d.w, d.h); }),
                sliderRow('Opacity', o.opacity ?? 1, (v) => o.set({ opacity: v }), { min: 0, max: 1, step: 0.01 }),
            ]));
            inspector.appendChild(section('Align to Page', [alignToPageButtons()]));
        }
        function renderPageInspector() {
            const pageRect = canvas.getObjects().find(o => o.oid === 'pageRect');
            if (!pageRect) return;
            const container = document.getElementById('pageInspector');
            if (!container) return;
            container.innerHTML = '';
            const pageProps = section('Page Style', [
                colorInputRow('Background Color', pageRect.fill || '#ffffff', (v) => {
                    pageRect.set({ fill: v });
                    canvas.requestRenderAll();
                    requestSaveState();
                }),
                buttonRow('Set Background Image', () => {
                    const up = document.getElementById('imageFillUpload');
                    if (!up) return;
                    editingFillObject = pageRect;
                    up.click();
                })
            ]);
            container.appendChild(pageProps);
        }
        on('#loadTemplateBtnPage', 'click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleTemplateLoader(e.currentTarget || e.target);
        });
        function section(title, rows) { const w = document.createElement('div'); w.className = 'stack'; w.innerHTML = `<h3>${title}</h3>`; const g = document.createElement('div'); g.className = 'prop-grid'; rows.forEach(r => g.appendChild(r)); w.appendChild(g); return w; }
        function inputRow(label, value, onChange, type = 'text') { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const i = document.createElement(type === 'textarea' ? 'textarea' : 'input'); if (type !== 'textarea') i.type = type; i.value = value ?? ''; i.oninput = () => { onChange(i.value); canvas.requestRenderAll(); }; i.onchange = () => requestSaveState(); if (type === 'textarea') i.rows = 3; w.appendChild(i); return w; }
        function xyInputRow(label, values, onChange) { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const r = document.createElement('div'); r.className = 'row'; const x = document.createElement('input'); x.type = 'number'; x.value = Math.round(values.x ?? values.w ?? 0); const y = document.createElement('input'); y.type = 'number'; y.value = Math.round(values.y ?? values.h ?? 0); if (label === 'Position') { x.id = 'inspector-pos-x'; y.id = 'inspector-pos-y'; } else if (label === 'Dimensions') { x.id = 'inspector-dim-w'; y.id = 'inspector-dim-h'; } const update = () => { const v = label === 'Position' ? { x: parseFloat(x.value), y: parseFloat(y.value) } : { w: parseFloat(x.value), h: parseFloat(y.value) }; onChange(v); canvas.requestRenderAll(); updateLiveInspector({ target: canvas.getActiveObject() }); }; const finalUpdate = () => { update(); requestSaveState(); }; x.oninput = update; y.oninput = update; x.onchange = finalUpdate; y.onchange = finalUpdate; r.append(x, y); w.appendChild(r); return w; }
        function sliderRow(label, value, onChange, { min = 0, max = 100, step = 1 }, idPrefix = null) { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const r = document.createElement('div'); r.className = 'slider-wrapper'; const s = document.createElement('input'); s.type = 'range'; s.min = min; s.max = max; s.step = step; s.value = value; const n = document.createElement('input'); n.type = 'number'; n.min = min; n.max = max; n.step = step; n.value = value; const idBase = idPrefix || 'inspector-' + label.toLowerCase().replace(/\s+/g, '-'); s.id = idBase + '-slider'; n.id = idBase + '-input'; const update = (val) => { onChange(val); canvas.requestRenderAll(); }; s.oninput = () => { n.value = s.value; update(parseFloat(s.value)); }; n.oninput = () => { s.value = n.value; update(parseFloat(n.value)); }; s.onchange = () => requestSaveState(); n.onchange = () => requestSaveState(); r.append(s, n); w.appendChild(r); return w; }
        function selectRow(label, opts, val, onChange) { const w = document.createElement('div'); w.className = 'stack full-width'; w.innerHTML = `<label>${label}</label>`; const s = document.createElement('select'); opts.forEach(opt => s.innerHTML += `<option value="${opt}" ${opt == val ? 'selected' : ''}>${opt}</option>`); s.onchange = e => { onChange(e.target.value); canvas.renderAll(); requestSaveState(); }; w.appendChild(s); return w; }
        function buttonRow(label, onClick) { const w = document.createElement('div'); w.className = 'full-width'; const b = document.createElement('button'); b.className = 'btn ghost'; b.textContent = label; b.onclick = onClick; b.style.width = '100%'; w.appendChild(b); return w; }
        function tableActionIcon(kind) {
            const icons = {
                addRow: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="14" height="14"/><line x1="3" y1="11" x2="17" y2="11"/><line x1="20" y1="16" x2="20" y2="22"/><line x1="17" y1="19" x2="23" y2="19"/></svg>',
                removeRow: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="14" height="14"/><line x1="3" y1="11" x2="17" y2="11"/><line x1="17" y1="19" x2="23" y2="19"/></svg>',
                addCol: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="14" height="14"/><line x1="10" y1="4" x2="10" y2="18"/><line x1="20" y1="16" x2="20" y2="22"/><line x1="17" y1="19" x2="23" y2="19"/></svg>',
                removeCol: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="4" width="14" height="14"/><line x1="10" y1="4" x2="10" y2="18"/><line x1="17" y1="19" x2="23" y2="19"/></svg>',
                top: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16"/><line x1="4" y1="4" x2="20" y2="4" stroke-width="3"/></svg>',
                right: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16"/><line x1="20" y1="4" x2="20" y2="20" stroke-width="3"/></svg>',
                bottom: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16"/><line x1="4" y1="20" x2="20" y2="20" stroke-width="3"/></svg>',
                left: '<svg class="inspector-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16"/><line x1="4" y1="4" x2="4" y2="20" stroke-width="3"/></svg>'
            };
            return icons[kind] || '';
        }
        function iconButtonsRow(label, items) {
            const w = document.createElement('div');
            w.className = 'stack full-width';
            w.innerHTML = `<label>${label}</label>`;
            const r = document.createElement('div');
            r.className = 'row';
            r.style.gap = '6px';
            items.forEach(item => {
                const b = document.createElement('button');
                b.className = 'btn ghost';
                b.style.flex = '1';
                b.style.padding = '0 8px';
                b.style.height = '30px';
                b.title = item.title || item.label || '';
                b.innerHTML = `${item.icon || ''}${item.label ? `<span>${item.label}</span>` : ''}`;
                b.onclick = item.onClick;
                r.appendChild(b);
            });
            w.appendChild(r);
            return w;
        }
        function colorInputRow(label, value, onChange) {
            const w = document.createElement('div');
            w.className = 'stack full-width';
            w.innerHTML = `<label>${label}</label>`;
            const r = document.createElement('div');
            r.className = 'color-picker-wrapper';

            const t = document.createElement('input');
            t.type = 'text';
            t.value = value || '';
            t.placeholder = 'No color';

            const c = document.createElement('input');
            c.type = 'color';
            c.value = value || '#000000';

            // "Clear Color" button
            const clearBtn = document.createElement('button');
            clearBtn.className = 'btn ghost';
            clearBtn.textContent = '×';
            clearBtn.title = 'Clear color (set to null)';
            clearBtn.style.cssText = 'padding: 4px 8px; font-size: 16px; line-height: 1;';
            clearBtn.onclick = (e) => {
                e.preventDefault();
                t.value = '';
                onChange(null);
                canvas.requestRenderAll();
                requestSaveState();
            };

            const update = (val) => { onChange(val); canvas.requestRenderAll(); };
            t.oninput = () => { if (t.value) c.value = t.value; update(t.value || null); };
            c.oninput = () => { t.value = c.value; update(c.value); };
            t.onchange = () => requestSaveState();
            c.onchange = () => requestSaveState();

            r.append(t, c, clearBtn);
            w.appendChild(r);
            return w;
        }
        function buttonGroupRow(label, options, value, onChange) {
            const w = document.createElement('div');
            w.className = 'stack full-width';
            w.innerHTML = `<label>${label}</label>`;
            const r = document.createElement('div');
            r.className = 'align-buttons';
            r.style.gridTemplateColumns = `repeat(${options.length}, 32px)`;

            const icons = {
                left: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/></svg>',
                center: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/></svg>',
                right: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M9 15v2h12v-2H9zm-6 6h18v-2H3v2zm6-8h12v-2H9v2zM3 7v2h18V7H3zM3 3v2h18V3H3z"/></svg>',
                justify: '<svg fill="currentColor" viewBox="0 0 24 24"><path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/></svg>'
            };

            options.forEach(opt => {
                const isObject = typeof opt === 'object';
                const val = isObject ? opt.value : opt;
                const label = isObject ? opt.label : opt;
                const isActive = isObject ? opt.active : (val === value);

                const btn = document.createElement('button');
                btn.className = 'btn ghost';
                if (isActive) btn.classList.add('active');

                // Use icon if available, otherwise use label
                if (icons[val]) {
                    btn.innerHTML = icons[val];
                } else {
                    btn.textContent = label;
                    btn.style.fontWeight = val === 'bold' ? 'bold' : 'normal';
                    btn.style.fontStyle = val === 'italic' ? 'italic' : 'normal';
                    btn.style.textDecoration = val === 'underline' ? 'underline' : 'none';
                }

                btn.onclick = () => {
                    onChange(val);
                    // For toggle buttons (bold, italic, underline), don't clear others
                    if (!isObject || !opt.hasOwnProperty('active')) {
                        r.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    }
                };
                r.appendChild(btn);
            });
            w.appendChild(r);
            return w;
        }

        // --- VISUAL CROPPER ---
        function initializeVisualCropper() { const modal = $('#visualCropModal'); const container = $('#visualCropContainer'); cropCanvas = new fabric.Canvas('cropCanvas', { selection: false, backgroundColor: '#222' }); new ResizeObserver(() => { const { width, height } = container.getBoundingClientRect(); cropCanvas.setWidth(width).setHeight(height); }).observe(container); on('#closeVisualCropModal', 'click', closeVisualCropper); on('#cancelCropBtn', 'click', closeVisualCropper); on('#applyCropBtn', 'click', applyCrop); }
        function openVisualCropper(imageObject) { croppingImage = imageObject; const modal = $('#visualCropModal'); modal.style.display = 'flex'; cropCanvas.clear(); const { width: cW, height: cH } = $('#visualCropContainer').getBoundingClientRect(); cropCanvas.setWidth(cW).setHeight(cH); const imgEl = croppingImage.getElement(); const scale = Math.min(cW / imgEl.naturalWidth, cH / imgEl.naturalHeight) * 0.8; const imgInstance = new fabric.Image(imgEl, { selectable: false, evented: false, scaleX: scale, scaleY: scale }); cropCanvas.add(imgInstance); cropCanvas.centerObject(imgInstance); cropCanvas.add(new fabric.Rect({ fill: 'rgba(0,0,0,0.3)', width: cW, height: cH, selectable: false, evented: false })); const cropBox = new fabric.Rect({ left: imgInstance.left, top: imgInstance.top, width: imgInstance.getScaledWidth(), height: imgInstance.getScaledHeight(), fill: 'transparent', stroke: '#fff', strokeWidth: 2, cornerColor: '#fff', cornerSize: 12, transparentCorners: false, }); cropCanvas.add(cropBox); cropCanvas.setActiveObject(cropBox); cropCanvas.renderAll(); }
        function closeVisualCropper() { $('#visualCropModal').style.display = 'none'; croppingImage = null; cropCanvas.clear(); }
        function applyCrop() { if (!croppingImage || !cropCanvas.getActiveObject()) return; const cropBox = cropCanvas.getActiveObject(); const imgInstance = cropCanvas.getObjects('image')[0]; const cropX = (cropBox.left - imgInstance.left) / imgInstance.scaleX; const cropY = (cropBox.top - imgInstance.top) / imgInstance.scaleY; const width = cropBox.getScaledWidth() / imgInstance.scaleX; const height = cropBox.getScaledHeight() / imgInstance.scaleY; croppingImage.set({ cropX, cropY, width, height }); croppingImage.scaleToWidth(cropBox.getScaledWidth()); canvas.renderAll(); requestSaveState(); closeVisualCropper(); }

        // --- ALIGNMENT & DATA BINDING ---
        function alignToPageButtons(isMultiSelect = false) {
            const container = document.createElement('div');
            container.className = 'align-buttons full-width';
            const icons = {
                left: '<svg viewBox="0 0 24 24"><path d="M18 21V3h2v18h-2zm-4 0V3h2v18h-2zM4 21h6V3H4v18z" fill="currentColor"/></svg>',
                h_center: '<svg viewBox="0 0 24 24"><path d="M4 21V3h2v18H4zm14 0V3h2v18h-2zM9 21V3h6v18H9z" fill="currentColor"/></svg>',
                right: '<svg viewBox="0 0 24 24"><path d="M4 21V3h2v18H4zm4 0V3h2v18H8zm12 0h-6V3h6v18z" fill="currentColor"/></svg>',
                top: '<svg viewBox="0 0 24 24" transform="rotate(90)"><path d="M18 21V3h2v18h-2zm-4 0V3h2v18h-2zM4 21h6V3H4v18z" fill="currentColor"/></svg>',
                v_center: '<svg viewBox="0 0 24 24" transform="rotate(90)"><path d="M4 21V3h2v18H4zm14 0V3h2v18h-2zM9 21V3h6v18H9z" fill="currentColor"/></svg>',
                bottom: '<svg viewBox="0 0 24 24" transform="rotate(90)"><path d="M4 21V3h2v18H4zm4 0V3h2v18H8zm12 0h-6V3h6v18z" fill="currentColor"/></svg>'
            };

            // Actions for single objects
            const singleActions = {
                left: o => o.set({ originX: 'left', left: pageRect.left }),
                h_center: o => o.set({ originX: 'center', left: pageRect.left + pageRect.width / 2 }),
                right: o => o.set({ originX: 'left', left: pageRect.left + pageRect.width - o.getScaledWidth() }),
                top: o => o.set({ originY: 'top', top: pageRect.top }),
                v_center: o => o.set({ originY: 'center', top: pageRect.top + pageRect.height / 2 }),
                bottom: o => o.set({ originY: 'top', top: pageRect.top + pageRect.height - o.getScaledHeight() })
            };

            // For multi-select, we calculate offset to move the whole group
            function alignMultiSelection(selection, key) {
                if (!selection) return;
                const bounds = selection.getBoundingRect(true, true);
                let dx = 0, dy = 0;

                switch (key) {
                    case 'left':
                        dx = pageRect.left - bounds.left;
                        break;
                    case 'h_center':
                        dx = (pageRect.left + pageRect.width / 2) - (bounds.left + bounds.width / 2);
                        break;
                    case 'right':
                        dx = (pageRect.left + pageRect.width) - (bounds.left + bounds.width);
                        break;
                    case 'top':
                        dy = pageRect.top - bounds.top;
                        break;
                    case 'v_center':
                        dy = (pageRect.top + pageRect.height / 2) - (bounds.top + bounds.height / 2);
                        break;
                    case 'bottom':
                        dy = (pageRect.top + pageRect.height) - (bounds.top + bounds.height);
                        break;
                }

                // Move all objects by the calculated offset
                selection.forEachObject(obj => {
                    obj.set({ left: obj.left + dx, top: obj.top + dy });
                    obj.setCoords();
                });
                selection.setCoords();
            }

            Object.keys(icons).forEach(key => {
                const btn = document.createElement('button');
                btn.className = 'btn ghost';
                btn.innerHTML = icons[key];
                btn.title = `Align ${key.replace('_', ' ')}`;
                btn.onclick = () => {
                    const active = canvas.getActiveObject();
                    if (active && pageRect) {
                        if (active.type === 'activeSelection') {
                            alignMultiSelection(active, key);
                        } else {
                            singleActions[key](active);
                            active.setCoords();
                        }
                        canvas.renderAll();
                        requestSaveState();
                    }
                };
                container.appendChild(btn);
            });
            return container;
        }

        function alignMultipleObjectsButtons() {
            const container = document.createElement('div');
            container.className = 'align-buttons full-width';
            container.style.gridTemplateColumns = 'repeat(6, 32px)';

            const alignments = [
                { key: 'left', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="3" y1="4" x2="3" y2="20" stroke="currentColor" stroke-width="2"/><rect x="6" y="7" width="8" height="3" fill="currentColor"/><rect x="6" y="14" width="12" height="3" fill="currentColor"/></svg>', title: 'Align left edges' },
                { key: 'h_center', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="12" y1="3" x2="12" y2="21" stroke="currentColor" stroke-width="2"/><rect x="7" y="6" width="10" height="3" fill="currentColor"/><rect x="5" y="15" width="14" height="3" fill="currentColor"/></svg>', title: 'Align centers horizontally' },
                { key: 'right', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="21" y1="4" x2="21" y2="20" stroke="currentColor" stroke-width="2"/><rect x="10" y="7" width="8" height="3" fill="currentColor"/><rect x="6" y="14" width="12" height="3" fill="currentColor"/></svg>', title: 'Align right edges' },
                { key: 'top', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="4" y1="3" x2="20" y2="3" stroke="currentColor" stroke-width="2"/><rect x="7" y="6" width="3" height="8" fill="currentColor"/><rect x="14" y="6" width="3" height="12" fill="currentColor"/></svg>', title: 'Align top edges' },
                { key: 'v_center', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="3" y1="12" x2="21" y2="12" stroke="currentColor" stroke-width="2"/><rect x="6" y="7" width="3" height="10" fill="currentColor"/><rect x="15" y="5" width="3" height="14" fill="currentColor"/></svg>', title: 'Align centers vertically' },
                { key: 'bottom', icon: '<svg viewBox="0 0 24 24" width="16" height="16"><line x1="4" y1="21" x2="20" y2="21" stroke="currentColor" stroke-width="2"/><rect x="7" y="10" width="3" height="8" fill="currentColor"/><rect x="14" y="6" width="3" height="12" fill="currentColor"/></svg>', title: 'Align bottom edges' }
            ];

            alignments.forEach(({ key, icon, title }) => {
                const btn = document.createElement('button');
                btn.className = 'btn ghost align-btn';
                btn.innerHTML = icon;
                btn.title = title;
                btn.onclick = () => {
                    const active = canvas.getActiveObject();
                    if (!active || active.type !== 'activeSelection') return;

                    const objects = active.getObjects();
                    if (objects.length < 2) return;

                    // Calculate alignment reference
                    let refValue;
                    if (key === 'left') {
                        refValue = Math.min(...objects.map(o => o.left - o.getScaledWidth() / 2));
                        objects.forEach(o => o.set({ left: refValue + o.getScaledWidth() / 2 }));
                    } else if (key === 'right') {
                        refValue = Math.max(...objects.map(o => o.left + o.getScaledWidth() / 2));
                        objects.forEach(o => o.set({ left: refValue - o.getScaledWidth() / 2 }));
                    } else if (key === 'h_center') {
                        const lefts = objects.map(o => o.left);
                        refValue = (Math.min(...lefts) + Math.max(...lefts)) / 2;
                        objects.forEach(o => o.set({ left: refValue }));
                    } else if (key === 'top') {
                        refValue = Math.min(...objects.map(o => o.top - o.getScaledHeight() / 2));
                        objects.forEach(o => o.set({ top: refValue + o.getScaledHeight() / 2 }));
                    } else if (key === 'bottom') {
                        refValue = Math.max(...objects.map(o => o.top + o.getScaledHeight() / 2));
                        objects.forEach(o => o.set({ top: refValue - o.getScaledHeight() / 2 }));
                    } else if (key === 'v_center') {
                        const tops = objects.map(o => o.top);
                        refValue = (Math.min(...tops) + Math.max(...tops)) / 2;
                        objects.forEach(o => o.set({ top: refValue }));
                    }

                    objects.forEach(o => o.setCoords());
                    canvas.renderAll();
                    requestSaveState();
                };
                container.appendChild(btn);
            });

            return container;
        }

        // --- Distribution tools (multi-select) ---
        function distributeSelection(selection, axis) {
            if (!selection || selection.type !== 'activeSelection') return;
            const objs = selection.getObjects().filter(o => o && o.oid !== 'pageRect' && !o.isArtboard);
            if (objs.length < 3) return; // distribution needs 3+ objects

            const rectFor = (o) => {
                o.setCoords();
                return o.getBoundingRect(true, true);
            };

            const items = objs.map(o => ({ o, r: rectFor(o) }));
            if (axis === 'h') {
                items.sort((a, b) => a.r.left - b.r.left);
                const leftEdge = Math.min(...items.map(i => i.r.left));
                const rightEdge = Math.max(...items.map(i => i.r.left + i.r.width));
                const total = items.reduce((s, i) => s + i.r.width, 0);
                const gap = (rightEdge - leftEdge - total) / (items.length - 1);
                let cursor = leftEdge;
                items.forEach(i => {
                    const dx = cursor - i.r.left;
                    i.o.left += dx;
                    i.o.setCoords();
                    // refresh cached rect for subsequent objects
                    cursor += i.r.width + gap;
                });
            } else {
                items.sort((a, b) => a.r.top - b.r.top);
                const topEdge = Math.min(...items.map(i => i.r.top));
                const bottomEdge = Math.max(...items.map(i => i.r.top + i.r.height));
                const total = items.reduce((s, i) => s + i.r.height, 0);
                const gap = (bottomEdge - topEdge - total) / (items.length - 1);
                let cursor = topEdge;
                items.forEach(i => {
                    const dy = cursor - i.r.top;
                    i.o.top += dy;
                    i.o.setCoords();
                    cursor += i.r.height + gap;
                });
            }

            selection.setCoords();
            canvas.requestRenderAll();
            requestSaveState();
        }

        function distributeButtons() {
            const container = document.createElement('div');
            container.className = 'align-buttons';
            container.style.gridTemplateColumns = 'repeat(2, 32px)';

            const hBtn = document.createElement('button');
            hBtn.className = 'btn ghost';
            hBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16"><rect x="3" y="4" width="2" height="16" fill="currentColor" opacity="0.3"/><rect x="19" y="4" width="2" height="16" fill="currentColor" opacity="0.3"/><rect x="11" y="6" width="2" height="12" fill="currentColor"/></svg>';
            hBtn.title = 'Distribute Horizontally';
            hBtn.onclick = () => distributeSelection(canvas.getActiveObject(), 'h');

            const vBtn = document.createElement('button');
            vBtn.className = 'btn ghost';
            vBtn.innerHTML = '<svg viewBox="0 0 24 24" width="16" height="16" style="transform: rotate(90deg)"><rect x="3" y="4" width="2" height="16" fill="currentColor" opacity="0.3"/><rect x="19" y="4" width="2" height="16" fill="currentColor" opacity="0.3"/><rect x="11" y="6" width="2" height="12" fill="currentColor"/></svg>';
            vBtn.title = 'Distribute Vertically';
            vBtn.onclick = () => distributeSelection(canvas.getActiveObject(), 'v');

            container.append(hBtn, vBtn);
            return container;
        }
        function getBindingsFor(o) { const id = ensureId(o); if (!bindings.has(id)) bindings.set(id, []); return bindings.get(id); }
        function isCellTextBinding(o, b) {
            return !!(o?.isTable && b?.property === 'Cell Text');
        }
        function getNormalizedBindingCellIndex(table, binding) {
            if (!table?.isTable) return 0;
            ensureTableCellData(table);
            const max = Math.max(0, table.rows * table.cols - 1);
            const raw = parseInt(binding?.cellIndex, 10);
            const idx = Number.isFinite(raw) ? raw : 0;
            return Math.max(0, Math.min(max, idx));
        }
        function bindingsMatch(o, a, b) {
            if (a?.property !== b?.property) return false;
            if (isCellTextBinding(o, a) || isCellTextBinding(o, b)) {
                return getNormalizedBindingCellIndex(o, a) === getNormalizedBindingCellIndex(o, b);
            }
            return true;
        }
        function saveBinding(o, b) {
            const arr = getBindingsFor(o);
            const incoming = { ...(b || {}) };
            if (isCellTextBinding(o, incoming)) incoming.cellIndex = getNormalizedBindingCellIndex(o, incoming);
            let existing = arr.find(i => bindingsMatch(o, i, incoming));
            if (!existing) {
                arr.push(incoming);
                existing = incoming;
            } else {
                Object.assign(existing, incoming);
            }
            requestSaveState();
            return existing;
        }
        function removeBinding(o, b) { const arr = getBindingsFor(o); const i = arr.indexOf(b); if (i > -1) arr.splice(i, 1); requestSaveState(); }
        function ensureId(o) { if (!o.oid) o.oid = `obj_${Date.now()}_${Math.random()}`; return o.oid; }
        canvas.on('object:added', (e) => {
            if (!e.target) return;
            ensureId(e.target);
            if (e.target.type === 'textbox') {
                e.target.padding = 0;
            }
            applyLockStateToObject(e.target);
            if (e.target.type === 'path' || e.target.isSvgGroup || e.target.type === 'group') {
                e.target.objectCaching = false;
            }
            if (e.target.oid !== 'pageRect' && !e.target.excludeFromExport && !e.target.isSnapLine && !e.target.isArtboard && !e.target.pageId) {
                e.target.pageId = currentCanvasPageId();
            }
        });


        // --- 8. CORRECTED & ENHANCED FLOATING UI LOGIC ---
        const floatingLinker = $('#floating-linker');
        const floatingLinkBtn = $('#floatingLinkBtn');
        const floatingColumnList = $('#floatingColumnList');
        const floatingColumnListContent = $('#floatingColumnListContent');
        const floatingColumnSearch = $('#floatingColumnSearch');

        function updateFloatingLinker(target) {
            const activeObjects = canvas.getActiveObjects();

            // Hide if nothing is selected
            if (activeObjects.length === 0) {
                floatingLinker.style.display = 'none';
                floatingColumnList.style.display = 'none';
                return;
            }

            // Keep endpoint handles unobstructed while editing lines.
            if (activeObjects.length === 1 && activeObjects[0]?.type === 'line') {
                floatingLinker.style.display = 'none';
                floatingColumnList.style.display = 'none';
                return;
            }

            // Show the main floating container for any selection (single or multiple)
            floatingLinker.style.display = 'flex';

            // The "anchor" for positioning is always the active selection group or the single object
            const anchor = canvas.getActiveObject();
            updateFloatingLinkerPosition(anchor);

            // Only show the "Link Data" button for a SINGLE selection when data is loaded
            if (activeObjects.length === 1 && headers.length > 0) {
                floatingLinkBtn.style.display = 'inline-flex';
                let objBindings = getBindingsFor(activeObjects[0]);

                // If it's a table and a specific cell is selected, show only what's linked to that cell
                if (activeObjects[0].isTable) {
                    const selectedCellIndex = getSingleSelectedTableCellIndex(activeObjects[0]);
                    if (selectedCellIndex >= 0) {
                        objBindings = objBindings.filter(b =>
                            b.property === 'Cell Text' &&
                            getNormalizedBindingCellIndex(activeObjects[0], b) === selectedCellIndex
                        );
                    }
                }

                if (objBindings.length > 0) {
                    // Show actual linked column names
                    const colNames = [...new Set(objBindings.map(b => b.column).filter(Boolean))];
                    floatingLinkBtn.textContent = colNames.length > 0 ? colNames.join(', ') : 'Link Data';
                } else {
                    floatingLinkBtn.textContent = 'Link Data';
                }
            } else {
                floatingLinkBtn.style.display = 'none';
            }
        }

        function updateFloatingLinkerPosition(target) {
            // Guard against errors if the target or its coordinates aren't ready
            if (!target || !floatingLinker) return;

            if (!target.oCoords) {
                if (typeof target.setCoords === 'function') target.setCoords();
                if (!target.oCoords) return;
            }

            const canvasRect = canvas.upperCanvasEl.getBoundingClientRect();

            // Default object controls expose `tr`; custom controls (e.g. line endpoints) may not.
            let anchorPoint = target.oCoords.tr
                || target.oCoords.br
                || target.oCoords.end
                || target.oCoords.start
                || null;

            if (!anchorPoint || !Number.isFinite(anchorPoint.x) || !Number.isFinite(anchorPoint.y)) {
                const coords = typeof target.getCoords === 'function' ? target.getCoords() : null;
                if (Array.isArray(coords) && coords.length > 0) {
                    anchorPoint = coords.reduce((best, p) => {
                        if (!best) return p;
                        if (p.x > best.x) return p;
                        if (p.x === best.x && p.y < best.y) return p;
                        return best;
                    }, null);
                }
            }

            if (!anchorPoint || !Number.isFinite(anchorPoint.x) || !Number.isFinite(anchorPoint.y)) return;

            floatingLinker.style.left = `${anchorPoint.x + canvasRect.left + 10}px`;
            floatingLinker.style.top = `${anchorPoint.y + canvasRect.top}px`;
        }


        // Show/Hide the column list dropdown
        floatingLinkBtn.addEventListener('click', () => {
            const target = canvas.getActiveObject();
            if (!target) return;
            const isVisible = floatingColumnList.style.display === 'block';
            floatingColumnList.style.display = isVisible ? 'none' : 'block';
            if (!isVisible) {
                renderFloatingColumnList(target, '');
                floatingColumnSearch.focus();
            }
        });

        // Filter the column list
        floatingColumnSearch.addEventListener('input', () => {
            renderFloatingColumnList(canvas.getActiveObject(), floatingColumnSearch.value);
        });

        function renderFloatingColumnList(target, query) {
            if (!target) return;
            floatingColumnListContent.innerHTML = '';
            const q = query.toLowerCase();

            // If identifier column is set, show a grouped view with row selector
            const hasIdentifier = identifierColumn && headers.includes(identifierColumn);

            // Determine if there's an existing binding for the current focus (single cell for tables, or first binding for others)
            let currentBinding = null;
            if (target.isTable) {
                const cellIdx = getSingleSelectedTableCellIndex(target);
                if (cellIdx >= 0) {
                    currentBinding = getBindingsFor(target).find(b =>
                        b.property === 'Cell Text' &&
                        getNormalizedBindingCellIndex(target, b) === cellIdx
                    );
                }
            } else {
                currentBinding = getBindingsFor(target)[0];
            }

            headers.filter(h => h.toLowerCase().includes(q)).forEach(h => {
                const item = document.createElement('div');
                item.className = 'col-item';
                item.style.cssText = 'display: flex; flex-direction: column; gap: 4px;';

                const isSelected = currentBinding && currentBinding.column === h;
                if (isSelected) {
                    item.setAttribute('aria-selected', 'true');
                }

                const headerRow = document.createElement('div');
                headerRow.style.cssText = 'display: flex; justify-content: space-between; align-items: center; width: 100%;';

                const label = document.createElement('span');
                label.textContent = h;
                headerRow.appendChild(label);

                if (isSelected) {
                    const unlinkBtn = document.createElement('button');
                    unlinkBtn.className = 'btn ghost';
                    unlinkBtn.style.cssText = 'padding: 0; min-width: 20px; height: 20px; border: none; background: transparent; color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center; border-radius: 4px;';
                    unlinkBtn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M18 6L6 18M6 6l12 12"/></svg>';
                    unlinkBtn.title = 'Remove Link';
                    unlinkBtn.onmouseover = () => unlinkBtn.style.background = 'rgba(239, 68, 68, 0.1)';
                    unlinkBtn.onmouseout = () => unlinkBtn.style.background = 'transparent';
                    unlinkBtn.onclick = (e) => {
                        e.stopPropagation();
                        removeBinding(target, currentBinding);
                        floatingColumnList.style.display = 'none';
                        updateFloatingLinker(target);
                        refreshInspector({ target });
                    };
                    headerRow.appendChild(unlinkBtn);
                }
                item.appendChild(headerRow);

                // Check if this column has multi-row data when identifier is set
                let rowSelectEl = null;
                if (hasIdentifier && h !== identifierColumn) {
                    // Count unique identifier values to see if multi-row
                    const identValues = [...new Set(dataRows.map(r => r[identifierColumn]).filter(Boolean))];
                    const hasMultiRow = identValues.some(id => dataRows.filter(r => r[identifierColumn] === id).length > 1);
                    if (hasMultiRow) {
                        // Show a row index selector
                        const maxRowsPerIdent = Math.max(...identValues.map(id => dataRows.filter(r => r[identifierColumn] === id).length));
                        rowSelectEl = document.createElement('select');
                        rowSelectEl.style.cssText = 'font-size: 11px; padding: 2px 4px; margin-top: 2px;';
                        for (let ri = 0; ri < maxRowsPerIdent; ri++) {
                            const opt = document.createElement('option');
                            opt.value = ri;
                            opt.textContent = `Row ${ri + 1}`;
                            rowSelectEl.appendChild(opt);
                        }
                        if (isSelected && typeof currentBinding.rowIndex === 'number') {
                            rowSelectEl.value = currentBinding.rowIndex;
                        }
                        rowSelectEl.onclick = (e) => e.stopPropagation();
                        item.appendChild(rowSelectEl);
                    }
                }

                item.onclick = () => {
                    const selectedRowIndex = rowSelectEl ? parseInt(rowSelectEl.value, 10) : 0;
                    const bindingData = { column: h, rowIndex: selectedRowIndex };

                    if (target.isTable) {
                        const selectedCellIndex = getSingleSelectedTableCellIndex(target);
                        if (selectedCellIndex < 0) {
                            showNotification('Select one table cell before linking data.');
                            floatingColumnList.style.display = 'none';
                            return;
                        }
                        const existing = getBindingsFor(target).find(b =>
                            b.property === 'Cell Text' && getNormalizedBindingCellIndex(target, b) === selectedCellIndex
                        );
                        if (existing) {
                            existing.column = h;
                            if (hasIdentifier) existing.rowIndex = selectedRowIndex;
                            requestSaveState();
                        } else {
                            const newB = { column: h, property: 'Cell Text', cellIndex: selectedCellIndex };
                            if (hasIdentifier) newB.rowIndex = selectedRowIndex;
                            saveBinding(target, newB);
                        }
                    } else {
                        const defaultProp = defaultPropertyFor(target);
                        const targetBindings = getBindingsFor(target);
                        if (targetBindings.length > 0) {
                            targetBindings[0].column = h;
                            targetBindings[0].property = defaultProp;
                            if (hasIdentifier) targetBindings[0].rowIndex = selectedRowIndex;
                        } else {
                            const newB = { column: h, property: defaultProp };
                            if (hasIdentifier) newB.rowIndex = selectedRowIndex;
                            saveBinding(target, newB);
                        }
                    }
                    requestSaveState();
                    floatingColumnList.style.display = 'none';
                    updateFloatingLinker(target);
                    refreshInspector({ target });
                };
                floatingColumnListContent.appendChild(item);
            });
        }

        // Add event handlers for Duplicate and Delete buttons
        on('#duplicateBtn', 'click', () => {
            const activeObject = canvas.getActiveObject();
            if (!activeObject) return;

            // Use the paste function to handle both single and multi-selection duplication
            activeObject.clone(cloned => {
                _clipboard = cloned;
                paste();
            }, ['oid', 'name']);
        });

        on('#deleteBtn', 'click', () => {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                activeObjects.forEach(obj => canvas.remove(obj));
                canvas.discardActiveObject();
                canvas.renderAll();
            }
        });

        // Bring to Front / Send to Back quick buttons
        on('#bringToFrontBtn', 'click', () => {
            const activeObjects = canvas.getActiveObjects();
            activeObjects.forEach(obj => canvas.bringToFront(obj));
            renderLayers();
            requestSaveState();
        });

        on('#sendToBackBtn', 'click', () => {
            const activeObjects = canvas.getActiveObjects();
            activeObjects.forEach(obj => canvas.sendToBack(obj));
            keepPageRectAtBack();
            renderLayers();
            requestSaveState();
        });

        canvas.on('object:moving', () => {
            floatingLinker.style.display = 'none';
            floatingColumnList.style.display = 'none';
        });
        canvas.on('object:modified', () => {
            updateFloatingLinker(canvas.getActiveObject());
        });

        // Hide dropdown if clicking outside
        window.addEventListener('click', (e) => {
            if (!floatingLinker.contains(e.target)) {
                floatingColumnList.style.display = 'none';
            }
        });

        const dataLinksManagerModal = $('#dataLinksManagerModal');
        const openDataLinksManagerBtn = $('#openDataLinksManagerBtn');
        const closeDataLinksManagerModalBtn = $('#closeDataLinksManagerModal');
        let selectedObjectForManager = null;

        // --- IDENTIFIER COLUMN LOGIC ---
        function refreshIdentifierDropdown() {
            const dropdown = $('#csvIdentifierColumnDropdown');
            if (!dropdown) return;
            dropdown.innerHTML = '<option value="">(None)</option>';
            headers.forEach(h => {
                const opt = document.createElement('option');
                opt.value = h;
                opt.textContent = h;
                if (h === identifierColumn) opt.selected = true;
                dropdown.appendChild(opt);
            });
        }

        on('#csvIdentifierColumnDropdown', 'change', (e) => {
            identifierColumn = e.target.value;
            requestSaveState();
        });

        function showIdentifierColumnModal() {
            const modal = $('#identifierColumnModal');
            const select = $('#identifierColumnSelect');
            const preview = $('#identifierColumnPreview');
            if (!modal || !select) return;

            select.innerHTML = '<option value="">(None — each row is a separate page)</option>';
            headers.forEach(h => {
                const opt = document.createElement('option');
                opt.value = h;
                opt.textContent = h;
                if (h === identifierColumn) opt.selected = true;
                select.appendChild(opt);
            });

            const updatePreview = () => {
                const col = select.value;
                if (!col) {
                    preview.textContent = `Each of the ${dataRows.length} rows will generate a separate page.`;
                    return;
                }
                const uniqueValues = [...new Set(dataRows.map(r => r[col]).filter(Boolean))];
                const multiRowCount = uniqueValues.filter(v => dataRows.filter(r => r[col] === v).length > 1).length;
                preview.textContent = `${uniqueValues.length} unique value(s). ${multiRowCount} with multiple rows.`;
            };
            select.onchange = updatePreview;
            updatePreview();

            modal.style.display = 'flex';
        }

        on('#confirmIdentifierColumnBtn', 'click', () => {
            const select = $('#identifierColumnSelect');
            identifierColumn = select ? select.value : '';
            refreshIdentifierDropdown();
            requestSaveState();
            $('#identifierColumnModal').style.display = 'none';
        });

        on('#skipIdentifierColumnBtn', 'click', () => {
            identifierColumn = '';
            refreshIdentifierDropdown();
            requestSaveState();
            $('#identifierColumnModal').style.display = 'none';
        });

        on('#closeIdentifierColumnModal', 'click', () => {
            $('#identifierColumnModal').style.display = 'none';
        });

        function openDataLinksManager() {
            renderDataLinksManager();
            dataLinksManagerModal.style.display = 'flex';
        }
        function closeDataLinksManager() {
            dataLinksManagerModal.style.display = 'none';
            selectedObjectForManager = null;
        }
        openDataLinksManagerBtn.addEventListener('click', openDataLinksManager);
        closeDataLinksManagerModalBtn.addEventListener('click', closeDataLinksManager);

        function renderDataLinksManager() {
            const objectsList = $('#dataLinksObjectsList');
            objectsList.innerHTML = '';
            const objects = canvas.getObjects().filter(o => o.oid !== 'pageRect' && !o.excludeFromExport && !o.isArtboard);
            if (objects.length === 0) {
                objectsList.innerHTML = '<p class="muted" style="font-size:12px; text-align:center;">No objects on canvas.</p>';
                $('#dataLinksEditorContent').innerHTML = '<p class="muted" style="text-align:center; padding-top: 24px;">Add an object to the canvas to create a data link.</p>';
                return;
            }
            objects.forEach(obj => {
                const item = document.createElement('div');
                item.className = 'data-links-object-item';
                item.setAttribute('data-oid', ensureId(obj));
                // Keep object names consistent with the Layers panel
                let name = obj.name || obj.type;
                const bindingCount = getBindingsFor(obj).length;
                item.innerHTML = `<strong>${name}</strong> <br> <span class="muted">${bindingCount} link(s)</span>`;
                item.addEventListener('click', () => {
                    selectedObjectForManager = obj;
                    document.querySelectorAll('.data-links-object-item').forEach(el => el.removeAttribute('aria-selected'));
                    item.setAttribute('aria-selected', 'true');
                    renderBindingsForObject(obj);
                });
                objectsList.appendChild(item);
            });
            if (selectedObjectForManager) {
                const selectedItem = objectsList.querySelector(`[data-oid="${selectedObjectForManager.oid}"]`);
                if (selectedItem) selectedItem.setAttribute('aria-selected', 'true');
                else selectedObjectForManager = null;
            }
            if (selectedObjectForManager) renderBindingsForObject(selectedObjectForManager);
            else $('#dataLinksEditorContent').innerHTML = '<p class="muted" style="text-align:center; padding-top: 24px;">Select an object from the left to manage its data links.</p>';
        }

        function renderBindingsForObject(obj) {
            const container = $('#dataLinksEditorContent');
            container.innerHTML = '';
            const linksWrapper = document.createElement('div');
            linksWrapper.className = 'links-list-wrapper';
            const header = document.createElement('h4');
            header.textContent = 'Active Links';
            linksWrapper.appendChild(header);
            const objectBindings = getBindingsFor(obj);
            if (objectBindings.length === 0) {
                linksWrapper.innerHTML += '<p class="muted" style="text-align:center; padding: 16px 0;">No data links configured for this object.</p>';
            } else {
                objectBindings.forEach(b => linksWrapper.appendChild(bindingEditorRow(obj, b)));
            }
            const buttonWrapper = document.createElement('div');
            buttonWrapper.className = 'add-link-button-wrapper';
            const addButton = document.createElement('button');
            addButton.className = 'btn';
            addButton.textContent = 'Add New Link';
            addButton.style.width = '100%';
            addButton.onclick = () => {
                const newBinding = { column: '', property: defaultPropertyFor(obj) };
                if (obj.isTable && newBinding.property === 'Cell Text') {
                    const selectedCellIndex = getSingleSelectedTableCellIndex(obj);
                    newBinding.cellIndex = selectedCellIndex >= 0 ? selectedCellIndex : 0;
                }
                saveBinding(obj, newBinding);
                renderDataLinksManager();
            };
            buttonWrapper.appendChild(addButton);
            container.append(linksWrapper, buttonWrapper);
        }

        function bindingEditorRow(o, b) {
            const box = document.createElement('div');
            box.className = 'stack';
            box.style.cssText = 'border:1px solid var(--border);padding:8px;border-radius:8px;margin-top:8px;';

            box.appendChild(selectRow('Property', propertyOptionsFor(o), b.property, v => {
                b.property = v;
                if (isCellTextBinding(o, b)) b.cellIndex = getNormalizedBindingCellIndex(o, b);
                requestSaveState();
                renderDataLinksManager();
            }));

            const info = document.createElement('div');
            info.className = 'muted';
            info.textContent = `Linked to: ${b.column || '\u2014'}${(b.rowIndex > 0) ? ` (Row ${b.rowIndex + 1})` : ''}`;
            info.style.fontSize = '12px';

            if (isCellTextBinding(o, b)) {
                ensureTableCellData(o);
                b.cellIndex = getNormalizedBindingCellIndex(o, b);
                const targetCell = document.createElement('div');
                targetCell.className = 'muted';
                targetCell.style.fontSize = '12px';
                targetCell.textContent = `Target Cell: ${tableCellRefLabel(o, b.cellIndex)}`;

                const posWrap = document.createElement('div');
                posWrap.className = 'row';
                posWrap.style.gap = '8px';
                posWrap.style.marginTop = '6px';
                const rowInput = document.createElement('input');
                rowInput.type = 'number';
                rowInput.min = '1';
                rowInput.max = `${o.rows}`;
                rowInput.title = 'Row';
                rowInput.value = `${Math.floor(b.cellIndex / o.cols) + 1}`;
                const colInput = document.createElement('input');
                colInput.type = 'number';
                colInput.min = '1';
                colInput.max = `${o.cols}`;
                colInput.title = 'Column';
                colInput.value = `${(b.cellIndex % o.cols) + 1}`;

                const updateCellTarget = () => {
                    const row = Math.max(1, Math.min(o.rows, parseInt(rowInput.value, 10) || 1));
                    const col = Math.max(1, Math.min(o.cols, parseInt(colInput.value, 10) || 1));
                    rowInput.value = `${row}`;
                    colInput.value = `${col}`;
                    b.cellIndex = (row - 1) * o.cols + (col - 1);
                    targetCell.textContent = `Target Cell: ${tableCellRefLabel(o, b.cellIndex)}`;
                    requestSaveState();
                    refreshInspector({ target: o });
                };
                rowInput.oninput = updateCellTarget;
                colInput.oninput = updateCellTarget;
                posWrap.append(rowInput, colInput);
                box.append(targetCell, posWrap);
            }

            const linkBtn = document.createElement('button');
            linkBtn.className = b.column ? 'btn primary' : 'btn';
            linkBtn.textContent = b.column ? 'Change Column' : 'Link Column';
            linkBtn.onclick = () => {
                openColumnSelectionModal(o, b);
            };

            const delBtn = document.createElement('button');
            delBtn.className = 'btn ghost';
            delBtn.textContent = 'Remove';
            delBtn.onclick = () => {
                removeBinding(o, b);
                renderDataLinksManager();
            };

            const btnGroup = document.createElement('div');
            btnGroup.className = 'row';
            btnGroup.style.marginTop = '8px';
            btnGroup.append(linkBtn, delBtn);

            box.append(info, btnGroup);
            return box;
        }


        function openColumnSelectionModal(object, binding, options = {}) {
            const modal = $('#columnSelectModal');
            const list = $('#columnSelectList');
            const searchInput = $('#columnSelectSearch');
            const confirmBtn = $('#confirmColumnSelect');

            const renderList = (query = '') => {
                list.innerHTML = '';
                const q = query.toLowerCase();
                headers.forEach((h, index) => {
                    if (h.toLowerCase().includes(q)) {
                        const item = document.createElement('div');
                        item.className = 'col-item';
                        item.dataset.columnName = h; // Store name for confirmation

                        const sample = dataRows.length > 0 ? (dataRows[0]?.[h] ?? '\u2014') : '\u2014';

                        item.innerHTML = `<strong>Column ${index + 1}: ${h}</strong><div class="muted" style="font-size: 11px;">Sample: ${sample}</div>`;

                        // Preselect currently linked column
                        if (binding.column && binding.column === h) {
                            item.setAttribute('aria-selected', 'true');
                        }

                        item.onclick = () => {
                            list.querySelectorAll('.col-item').forEach(el => el.removeAttribute('aria-selected'));
                            item.setAttribute('aria-selected', 'true');
                        };
                        list.appendChild(item);
                    }
                });
            };

            // Use a fresh, single-use event listener for confirmation to avoid old references
            const confirmHandler = () => {
                const selectedEl = list.querySelector('[aria-selected="true"]');
                if (selectedEl) {
                    binding.column = selectedEl.dataset.columnName;
                    requestSaveState();
                    if (typeof options.onLinked === 'function') options.onLinked(binding);
                    else renderDataLinksManager(); // Refresh manager to show the new column name
                    modal.style.display = 'none';
                } else {
                    showNotification("Please select a column.", 'info', 2000);
                }
            };

            confirmBtn.onclick = confirmHandler;

            searchInput.oninput = () => renderList(searchInput.value);

            renderList(); // Initial render
            modal.style.display = 'flex';
        }

        function propertyOptionsFor(o) { const common = ['Opacity', 'Stroke Color', 'Stroke Width']; if (o.isTable) return ['Cell Text', 'Border Color', 'Border Width']; if (o.type === 'textbox') return ['Text Content', 'Font Family', 'Font Size', 'Fill Color', ...common]; if (['rect', 'image'].includes(o.type)) common.push('Corner Radius'); if (o.isSvgGroup || ['rect', 'circle', 'triangle', 'polygon', 'path'].includes(o.type)) return ['Fill', 'Stroke Color', 'Stroke Width', 'Opacity']; return common; }
        function defaultPropertyFor(o) { if (o?.isTable) return 'Cell Text'; return o.type === 'textbox' ? 'Text Content' : 'Fill'; }

        // --- EXPORT ---
        const exportFormatSelect = $('#exportFormatSelect');
        const exportBtn = $('#exportBtn');
        const exportSinglePdfBtn = $('#exportSinglePdfBtn');
        const proLimitModal = $('#proLimitModal');

        // Update the UI based on user role and data loaded
        function updateExportUI() {
            const format = exportFormatSelect.value;
            const hasData = dataRows.length > 0;

            const isPro = userRole === 'pro' || userRole === 'admin';
            $('#exportFormatSelect option[value="png"]').disabled = !isPro;
            $('#exportFormatSelect option[value="jpg"]').disabled = !isPro;
            if (!isPro && (format === 'png' || format === 'jpg')) {
                exportFormatSelect.value = 'pdf';
            }

            if (hasData && format !== 'json') {
                exportBtn.textContent = 'Export as ZIP';
                exportSinglePdfBtn.style.display = 'inline-flex';
            } else {
                exportBtn.textContent = 'Export';
                exportSinglePdfBtn.style.display = 'none';
            }
        }

        // 3. Restored High-Quality "Invisible Canvas" Rendering Engine
        async function generateCanvasDataURL(format = 'jpeg', quality = 0.9) {
            if (!pageRect) return null;

            const { left: pageLeft, top: pageTop, width: pageW, height: pageH } = pageRect;

            // Use a higher multiplier for PNG for better quality, JPEG is fine at 2x
            const multiplier = format === 'png' ? 3 : 2;

            const tempCanvasEl = document.createElement('canvas');
            tempCanvasEl.width = pageW;
            tempCanvasEl.height = pageH;

            // Create a static canvas that won't be rendered to the screen
            const tempCanvas = new fabric.StaticCanvas(tempCanvasEl, {
                width: pageW,
                height: pageH,
                backgroundColor: pageRect.fill,
            });

            // Clone all objects except the page rectangle and guides
            const objectsToClone = canvas.getObjects().filter(obj => obj.oid !== 'pageRect' && !obj.excludeFromExport && !obj.isArtboard);
            const clonePromises = objectsToClone.map(obj => new Promise(resolve => obj.clone(resolve, SERIALIZE_PROPS)));
            const clonedObjects = await Promise.all(clonePromises);

            clonedObjects.forEach(clone => {
                // Position the clone relative to the page, not the entire canvas
                clone.set({
                    left: clone.left - pageLeft,
                    top: clone.top - pageTop
                });
                tempCanvas.add(clone);
            });

            // Ensure everything is rendered before exporting
            tempCanvas.renderAll();

            const dataURL = tempCanvas.toDataURL({
                format: format,
                quality: quality,
                multiplier: 3
            });

            // Clean up the temporary canvas
            tempCanvas.dispose();

            return dataURL;
        }

        function bindingPropertyToObjectProp(property) {
            switch (property) {
                case 'Text Content': return 'text';
                case 'Font Family': return 'fontFamily';
                case 'Font Size': return 'fontSize';
                case 'Fill':
                case 'Fill Color': return 'fill';
                case 'Opacity': return 'opacity';
                case 'Border Color': return 'borderColor';
                case 'Border Width': return 'borderWidth';
                case 'Stroke Color': return 'stroke';
                case 'Stroke Width': return 'strokeWidth';
                case 'Corner Radius': return 'rx';
                default: return property ? property.toLowerCase().replace(/\s/g, '') : '';
            }
        }

        function getRowsForIdentifier(identValue) {
            if (!identifierColumn || !identValue) return [];
            return dataRows.filter(r => r[identifierColumn] === identValue);
        }

        function applyDataBindingsForRow(row) {
            const originalStates = new Map();
            if (!row) return originalStates;

            // If identifier column is set, gather all rows for this identifier
            const identValue = identifierColumn ? row[identifierColumn] : null;
            const identRows = identValue ? getRowsForIdentifier(identValue) : [row];

            canvas.getObjects().forEach(obj => {
                const objBindings = getBindingsFor(obj);
                if (objBindings.length === 0) return;

                const originalProps = {};
                objBindings.forEach(binding => {
                    // Resolve which row to use: if binding has a rowIndex and identifier is set, use that row
                    const bindingRowIndex = (identifierColumn && typeof binding.rowIndex === 'number') ? binding.rowIndex : 0;
                    const effectiveRow = (identifierColumn && typeof binding.rowIndex === 'number') ? identRows[bindingRowIndex] : row;
                    const value = effectiveRow ? (effectiveRow[binding.column] ?? '') : '';
                    if (value == null) return;

                    if (obj.isTable && binding.property === 'Cell Text') {
                        ensureTableCellData(obj);
                        const cellIndex = getNormalizedBindingCellIndex(obj, binding);
                        if (!originalProps.__tableCellTexts) originalProps.__tableCellTexts = {};
                        if (originalProps.__tableCellTexts[cellIndex] === undefined) {
                            originalProps.__tableCellTexts[cellIndex] = obj.cellData[cellIndex]?.text || '';
                        }
                        applyBinding(obj, binding.property, value, binding);
                        return;
                    }

                    if (obj.isTable && (binding.property === 'Border Color' || binding.property === 'Border Width')) {
                        ensureTableCellData(obj);
                        if (!originalProps.__tableCellBorders) {
                            originalProps.__tableCellBorders = obj.cellData.map(cell => ({
                                borderColor: cell.borderColor,
                                borderWidth: cell.borderWidth
                            }));
                        }
                    }

                    const propName = bindingPropertyToObjectProp(binding.property);
                    if (propName && originalProps[propName] === undefined) originalProps[propName] = obj[propName];
                    applyBinding(obj, binding.property, value, binding);
                });

                if (Object.keys(originalProps).length > 0) originalStates.set(obj, originalProps);
            });

            canvas.renderAll();
            return originalStates;
        }

        function restoreDataBindingsState(originalStates) {
            originalStates.forEach((props, obj) => {
                if (props.__tableCellTexts && obj.isTable) {
                    ensureTableCellData(obj);
                    Object.entries(props.__tableCellTexts).forEach(([idx, text]) => {
                        const cellIndex = parseInt(idx, 10);
                        if (obj.cellData[cellIndex]) obj.cellData[cellIndex].text = text;
                    });
                }
                if (props.__tableCellBorders && obj.isTable) {
                    ensureTableCellData(obj);
                    props.__tableCellBorders.forEach((cellBorder, idx) => {
                        if (!obj.cellData[idx] || !cellBorder) return;
                        obj.cellData[idx].borderColor = cellBorder.borderColor;
                        obj.cellData[idx].borderWidth = cellBorder.borderWidth;
                    });
                }
                if (obj.isTable && (props.__tableCellTexts || props.__tableCellBorders)) {
                    updateTableLayout(obj);
                }
                const plainProps = { ...props };
                delete plainProps.__tableCellTexts;
                delete plainProps.__tableCellBorders;
                if (Object.keys(plainProps).length > 0) obj.set(plainProps);
            });
            if (originalStates.size > 0) canvas.renderAll();
        }

        // Main handler for the primary export button
        async function handleExport() {
            syncCurrentPageStateFromCanvas();
            const format = exportFormatSelect.value;
            const hasData = dataRows.length > 0;
            const totalRows = dataRows.length;
            const title = ($('#titleInput').value || 'Untitled_Template').trim();
            const isFreeUser = userRole !== 'pro' && userRole !== 'admin';

            // 2. Apply freemium limit
            // If identifier column is set, deduplicate rows by identifier for export
            let exportRows;
            if (hasData && identifierColumn && headers.includes(identifierColumn)) {
                const seen = new Set();
                exportRows = dataRows.filter(r => {
                    const id = r[identifierColumn];
                    if (!id || seen.has(id)) return false;
                    seen.add(id);
                    return true;
                });
            } else {
                exportRows = hasData ? dataRows : [null];
            }
            const rowsToProcess = hasData
                ? (isFreeUser ? exportRows.slice(0, 15) : exportRows)
                : [null];

            const zip = new JSZip();

            // Handle JSON export separately
            if (format === 'json') {
                const exportPayload = {
                    version: 'csvlink-template-v2',
                    ...buildTemplatePayload()
                };
                const json = JSON.stringify(exportPayload, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                saveAs(blob, `${title}.json`);
                return;
            }

            for (let i = 0; i < rowsToProcess.length; i++) {
                const row = rowsToProcess[i];
                const originalStates = row ? applyDataBindingsForRow(row) : new Map();

                const fileName = `${title}${hasData ? `_row_${i + 1}` : ''}.${format}`;
                const exportFormat = (format === 'pdf' || format === 'jpg') ? 'jpeg' : 'png';
                const dataURL = await generateCanvasDataURL(exportFormat);

                if (format === 'pdf') {
                    const { width: pageW, height: pageH } = pageRect;
                    const pdf = new jsPDF({ unit: 'px', format: [pageW, pageH] });
                    pdf.addImage(dataURL, 'JPEG', 0, 0, pageW, pageH);
                    if (hasData) {
                        zip.file(fileName, await pdf.output('blob'));
                    } else {
                        saveAs(pdf.output('blob'), fileName);
                    }
                } else if (format === 'png' || format === 'jpg') {
                    const blob = await (await fetch(dataURL)).blob();
                    if (hasData) {
                        zip.file(fileName, blob);
                    } else {
                        saveAs(blob, fileName);
                    }
                }

                // Restore original states
                restoreDataBindingsState(originalStates);
            }

            if (hasData) {
                const content = await zip.generateAsync({ type: "blob" });
                saveAs(content, `${title}.zip`);
            }

            // 2. Show pro modal AFTER export if limit was hit
            if (isFreeUser && totalRows > 15) {
                proLimitModal.style.display = 'flex';
            }
        }
        // Handle the "Single PDF" export button
        async function handleSinglePdfExport() {
            syncCurrentPageStateFromCanvas();
            if (!dataRows.length) return;

            const isFreeUser = userRole !== 'pro' && userRole !== 'admin';
            let singlePdfExportRows;
            if (identifierColumn && headers.includes(identifierColumn)) {
                const seen = new Set();
                singlePdfExportRows = dataRows.filter(r => {
                    const id = r[identifierColumn];
                    if (!id || seen.has(id)) return false;
                    seen.add(id);
                    return true;
                });
            } else {
                singlePdfExportRows = dataRows;
            }
            const totalRows = singlePdfExportRows.length;
            const rowsToProcess = isFreeUser ? singlePdfExportRows.slice(0, 15) : singlePdfExportRows;

            const title = ($('#titleInput').value || 'Untitled_Template').trim();
            if (!pageRect) { alert('Page object not found.'); return; }
            const { width: pageW, height: pageH } = pageRect;
            const pdf = new jsPDF({ unit: 'px', format: [pageW, pageH] });
            let firstPage = true;

            for (const row of rowsToProcess) {
                const originalStates = applyDataBindingsForRow(row);

                const dataURL = await generateCanvasDataURL('jpeg');
                if (!firstPage) pdf.addPage([pageW, pageH]);
                pdf.addImage(dataURL, 'JPEG', 0, 0, pageW, pageH);
                firstPage = false;

                restoreDataBindingsState(originalStates);
            }

            saveAs(pdf.output('blob'), `${title}_all_pages.pdf`);

            if (isFreeUser && totalRows > 15) {
                proLimitModal.style.display = 'flex';
            }
        }

        // Event Listeners for Export
        exportBtn.addEventListener('click', handleExport);
        exportSinglePdfBtn.addEventListener('click', handleSinglePdfExport);
        exportFormatSelect.addEventListener('change', updateExportUI);
        on('#closeProLimitModal', 'click', () => proLimitModal.style.display = 'none');

        // Binding logic
        function applyBinding(o, prop, val, binding = null) {
            const strVal = String(val).trim();
            const numVal = parseFloat(strVal);
            switch (prop) {
                case 'Text Content': if (o.type === 'textbox') o.set({ text: strVal }); break;
                case 'Cell Text':
                    if (o.isTable) {
                        ensureTableCellData(o);
                        const cellIndex = getNormalizedBindingCellIndex(o, binding || {});
                        if (o.cellData[cellIndex]) {
                            o.cellData[cellIndex].text = strVal;
                            updateTableLayout(o);
                        }
                    }
                    break;
                case 'Font Family': if (o.type === 'textbox') o.set({ fontFamily: strVal }); break;
                case 'Font Size': if (o.type === 'textbox' && !isNaN(numVal)) o.set({ fontSize: numVal }); break;
                case 'Fill': case 'Fill Color': o.set({ fill: strVal }); break;
                case 'Opacity': if (!isNaN(numVal)) o.set({ opacity: numVal }); break;
                case 'Border Color':
                    if (o.isTable) {
                        o.borderColor = strVal;
                        ensureTableCellData(o);
                        o.cellData.forEach(cell => { cell.borderColor = strVal; });
                        updateTableLayout(o);
                    }
                    break;
                case 'Border Width':
                    if (o.isTable && !isNaN(numVal)) {
                        o.borderWidth = numVal;
                        ensureTableCellData(o);
                        o.cellData.forEach(cell => { cell.borderWidth = Math.max(0.5, numVal); });
                        updateTableLayout(o);
                    }
                    break;
                case 'Stroke Color': o.set({ stroke: strVal }); break;
                case 'Stroke Width':
                    if (!isNaN(numVal)) {
                        o.set({ strokeWidth: numVal });
                        o.setCoords();
                    }
                    break;
                case 'Corner Radius': if ('rx' in o && !isNaN(numVal)) o.set({ rx: numVal, ry: numVal }); break;
                case 'Image Fill URL': fabric.Image.fromURL(strVal, img => o.set('fill', new fabric.Pattern({ source: img.getElement() })), { crossOrigin: 'anonymous' }); break;
            }
            canvas.renderAll();
        }


        onClick('#csvViewBtn', openCsvView);
        onClick('#closeCsvView', closeCsvView);
        function restoreCanvasStateAfterLoad(callback) {
            pageRect = canvas.getObjects().find(o => o.oid === 'pageRect');
            if (pageRect) {
                pageRect.set({
                    selectable: false,
                    evented: false,
                    hasControls: false,
                    hasBorders: false,
                    lockMovementX: true,
                    lockMovementY: true,
                    lockScalingX: true,
                    lockScalingY: true,
                    lockRotation: true,
                    isArtboard: true,
                    oid: 'pageRect'
                });
            }
            const pageId = currentCanvasPageId();
            canvas.getObjects().forEach(obj => {
                if (!obj || obj.oid === 'pageRect' || obj.excludeFromExport || obj.isSnapLine) return;
                try {
                    if (!obj.pageId) obj.pageId = pageId;
                    stabilizeObjectAfterLoad(obj);
                    if (obj.isTable) {
                        ensureTableCellData(obj);
                        const canInspectChildren = typeof obj.getObjects === 'function';
                        const hasCellGroups = canInspectChildren
                            && obj.getObjects().every(child => child?.isTableCellGroup);
                        if (!hasCellGroups) rebuildTableCells(obj);
                        else updateTableLayout(obj);
                    }
                } catch (error) {
                    console.warn('Object restore skipped due to invalid object state:', error, obj);
                }
            });
            if (documentPages[currentPageIndex] && pageRect) {
                documentPages[currentPageIndex].width = parsePositiveInt(Math.round(pageRect.width), DEFAULT_PAGE_WIDTH);
                documentPages[currentPageIndex].height = parsePositiveInt(Math.round(pageRect.height), DEFAULT_PAGE_HEIGHT);
            }
            keepPageRectAtBack();
            drawGrid();
            renderLayers();
            refreshCanvasPageControls();
            clampViewportTransform(canvas.viewportTransform);
            canvas.renderAll();
            // historyLocked will be set to false by the caller (undo/redo)
            if (typeof callback === 'function') {
                callback();
            }
        }
        function copy() { const activeObject = canvas.getActiveObject(); if (!activeObject) return; activeObject.clone(cloned => { _clipboard = cloned; }, SERIALIZE_PROPS); }
        function cut() { copy(); const activeObjects = canvas.getActiveObjects(); if (activeObjects.length) { activeObjects.forEach(obj => canvas.remove(obj)); canvas.discardActiveObject().renderAll(); } }
        function paste() { if (!_clipboard) return; _clipboard.clone(clonedObj => { canvas.discardActiveObject(); clonedObj.set({ left: clonedObj.left + 20, top: clonedObj.top + 20, evented: true, }); if (clonedObj.type === 'activeSelection') { clonedObj.canvas = canvas; clonedObj.forEachObject(obj => { obj.oid = `obj_${Date.now()}_${Math.random()}`; obj.name = getUniqueName(obj.name || obj.type); obj.pageId = currentCanvasPageId(); canvas.add(obj); }); clonedObj.setCoords(); } else { clonedObj.oid = `obj_${Date.now()}_${Math.random()}`; clonedObj.name = getUniqueName(clonedObj.name || clonedObj.type); clonedObj.pageId = currentCanvasPageId(); canvas.add(clonedObj); } canvas.setActiveObject(clonedObj); canvas.requestRenderAll(); requestSaveState(); }, SERIALIZE_PROPS); }
        function renderLayers(e) {
            const list = $('#layersList'); if (!list) return; list.innerHTML = '';
            const activeObjects = canvas.getActiveObjects();
            const objects = canvas.getObjects().filter(o => o.oid !== 'pageRect' && !o.excludeFromExport && !o.isSnapLine && !o.isArtboard);
            if (objects.length === 0) { list.innerHTML = '<p class="muted" style="text-align: center; padding: 24px 0; font-size: 13px;">Add an object to the canvas.</p>'; return; }
            objects.slice().reverse().forEach(obj => {
                const item = document.createElement('div');
                item.className = 'layer-item';
                item.dataset.locked = !!obj.locked;
                if (activeObjects.includes(obj)) item.classList.add('active');

                item.onclick = (e) => {
                    if (obj.locked) return;
                    // 7. Layer multi-select
                    if (e.shiftKey || e.ctrlKey || e.metaKey) {
                        if (canvas.getActiveObjects().includes(obj)) {
                            canvas.getActiveObject().removeWithUpdate(obj);
                        } else {
                            canvas.getActiveObject().addWithUpdate(obj);
                        }
                    } else {
                        canvas.setActiveObject(obj);
                    }
                    canvas.renderAll();
                };

                // DRAG AND DROP HANDLERS
                item.draggable = true;
                item.ondragstart = (e) => {
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', obj.oid);
                };
                item.ondragend = () => {
                    item.classList.remove('dragging');
                    document.querySelectorAll('.layer-item').forEach(i => i.classList.remove('drag-over'));
                };
                item.ondragover = (e) => {
                    e.preventDefault();
                    item.classList.add('drag-over');
                };
                item.ondragleave = () => {
                    item.classList.remove('drag-over');
                };
                item.ondrop = (e) => {
                    e.preventDefault();
                    const draggedOid = e.dataTransfer.getData('text/plain');
                    const draggedObj = canvas.getObjects().find(o => o.oid === draggedOid);
                    if (draggedObj && draggedObj !== obj) {
                        // Move draggedObj to be above obj
                        canvas.remove(draggedObj);
                        const objects = canvas.getObjects();
                        const targetIndex = objects.indexOf(obj);
                        canvas.insertAt(draggedObj, targetIndex + 1);

                        // Re-ensure pageRect is at bottom
                        keepPageRectAtBack();
                        renderLayers();
                        requestSaveState();
                    }
                };

                // Capitalize layer name (first letter uppercase)
                const rawName = obj.name || obj.type;
                const displayName = rawName.charAt(0).toUpperCase() + rawName.slice(1);
                const nameSpan = document.createElement('span'); nameSpan.className = 'layer-name'; nameSpan.textContent = displayName;
                nameSpan.ondblclick = () => { /* ... rename logic ... */ };

                item.innerHTML = `
            <div class="layer-actions">
                <button title="Lock/Unlock" class="btn ghost btn-lock"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">${obj.locked ? '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>' : '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>'}</svg></button>
                <button title="Bring Forward" class="btn ghost btn-fwd"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M6 15l6-6 6 6"/></svg></button>
                <button title="Send Backward" class="btn ghost btn-bwd"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M6 9l6 6 6-6"/></svg></button>
                <button title="Bring to Front" class="btn ghost btn-front"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 5l6 6m-6-6l-6 6M12 19V5M5 19h14"/></svg></button>
                <button title="Send to Back" class="btn ghost btn-back"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M12 19l-6-6m6 6l6-6M12 5v14M5 5h14"/></svg></button>
            </div>`;
                item.prepend(nameSpan);

                item.querySelector('.btn-lock').onclick = (e) => { e.stopPropagation(); toggleLock(obj); };
                item.querySelector('.btn-front').onclick = (e) => { e.stopPropagation(); canvas.bringToFront(obj); renderLayers(); requestSaveState(); };
                item.querySelector('.btn-back').onclick = (e) => { e.stopPropagation(); canvas.sendToBack(obj); keepPageRectAtBack(); renderLayers(); requestSaveState(); };
                item.querySelector('.btn-fwd').onclick = (e) => { e.stopPropagation(); canvas.bringForward(obj); renderLayers(); requestSaveState(); };
                item.querySelector('.btn-bwd').onclick = (e) => { e.stopPropagation(); canvas.sendBackwards(obj); renderLayers(); requestSaveState(); };
                list.appendChild(item);
            });
        }
        function toggleLock(obj) {
            obj.locked = !obj.locked;
            applyLockStateToObject(obj);
            if (obj.locked) canvas.discardActiveObject();
            obj.setCoords();
            canvas.renderAll();
            renderLayers();
            requestSaveState();
        }
        function centerAndFitPage() {
            if (!pageRect) return;
            const { width: wrapperW, height: wrapperH } = canvasWrapper.getBoundingClientRect();
            const pageW = pageRect.width;
            const pageH = pageRect.height;
            const zoom = Math.min(wrapperW / pageW, wrapperH / pageH) * 0.95;
            canvas.setZoom(zoom);
            const center = pageRect.getCenterPoint();
            const vpt = [zoom, 0, 0, zoom, (wrapperW / 2) - center.x * zoom, (wrapperH / 2) - center.y * zoom];
            clampViewportTransform(vpt);
            canvas.setViewportTransform(vpt);
            updateZoomLabel();
            canvas.renderAll();
        }
        onClick('#centerViewBtn', centerAndFitPage);
        window.addEventListener('keydown', e => { if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return; const isCtrl = e.ctrlKey || e.metaKey; const activeObj = canvas.getActiveObject(); if (isCtrl && e.key.toLowerCase() === 'z') { e.preventDefault(); if (e.shiftKey) redo(); else undo(); } if (isCtrl && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); } if (isCtrl && e.key.toLowerCase() === 'c') { e.preventDefault(); copy(); } if (isCtrl && e.key.toLowerCase() === 'x') { e.preventDefault(); cut(); } if (isCtrl && e.key.toLowerCase() === 'v') { e.preventDefault(); paste(); } if (isCtrl && e.key.toLowerCase() === 'a') { e.preventDefault(); const allObjects = canvas.getObjects().filter(o => o.selectable); canvas.setActiveObject(new fabric.ActiveSelection(allObjects, { canvas: canvas })); canvas.renderAll(); } if (isCtrl && e.key.toLowerCase() === 'g') { e.preventDefault(); if (activeObj && activeObj.type === 'activeSelection') activeObj.toGroup(); } if (isCtrl && e.shiftKey && e.key.toLowerCase() === 'g') { e.preventDefault(); if (activeObj && activeObj.type === 'group') activeObj.toActiveSelection(); } if (e.key.startsWith('Arrow') && activeObj) { e.preventDefault(); const amount = e.shiftKey ? 10 : 1; switch (e.key) { case 'ArrowUp': activeObj.top -= amount; break; case 'ArrowDown': activeObj.top += amount; break; case 'ArrowLeft': activeObj.left -= amount; break; case 'ArrowRight': activeObj.left += amount; break; } activeObj.setCoords(); canvas.renderAll(); } if (e.key === 'Delete' || e.key === 'Backspace') { const activeObjects = canvas.getActiveObjects(); if (activeObjects.length) { activeObjects.forEach(obj => canvas.remove(obj)); canvas.discardActiveObject().renderAll(); } } });
        window.addEventListener('keyup', e => { if (e.key.startsWith('Arrow') && canvas.getActiveObject()) { requestSaveState(); } });

        // --- AI ASSISTANT ---
        const aiBubble = $('#ai-bubble');
        const aiModal = $('#aiModalBackdrop');
        const aiCloseBtn = $('#aiCloseModal');
        const aiSendBtn = $('#aiSendBtn');
        const aiApiKeyInput = $('#aiApiKey');
        const aiPromptInput = $('#aiPrompt');
        const aiSendBtnText = $('#aiSendBtnText');
        const aiLoadingSpinner = $('#aiLoadingSpinner');
        const aiImageUploadInput = $('#aiImageUpload');
        const aiImageNameEl = $('#aiImageName');
        const clearAiImageBtn = $('#clearAiImageBtn');
        const pastedImageContainer = $('#pasted-image-container');
        const pastedImage = $('#pasted-image');
        let pastedImageData = null;

        const savedApiKey = localStorage.getItem('googleAiApiKey');
        if (savedApiKey) {
            aiApiKeyInput.value = savedApiKey;
        }

        function setAiImageAttachment(dataUrl, fileLabel = 'Image attached') {
            if (!dataUrl) return;
            pastedImageData = dataUrl;
            pastedImage.src = dataUrl;
            pastedImageContainer.style.display = 'block';
            if (aiImageNameEl) aiImageNameEl.textContent = fileLabel;
        }

        function clearAiImageAttachment() {
            pastedImageData = null;
            pastedImage.removeAttribute('src');
            pastedImageContainer.style.display = 'none';
            if (aiImageUploadInput) aiImageUploadInput.value = '';
            if (aiImageNameEl) aiImageNameEl.textContent = '';
        }

        // Handle the paste event 
        aiPromptInput.addEventListener('paste', (event) => {
            const items = (event.clipboardData || event.originalEvent.clipboardData).items;
            if (!items) return;
            for (const item of items) {
                if (item.kind === 'file' && item.type && item.type.startsWith('image/')) {
                    const blob = item.getAsFile();
                    if (!blob) continue;
                    const reader = new FileReader();
                    reader.onload = (loadEvent) => {
                        setAiImageAttachment(loadEvent.target.result, 'Pasted image');
                    };
                    reader.readAsDataURL(blob);
                    break;
                }
            }
        });

        if (aiImageUploadInput) {
            aiImageUploadInput.addEventListener('change', (event) => {
                const file = event.target.files?.[0];
                if (!file) return;
                if (!file.type || !file.type.startsWith('image/')) {
                    alert('Please choose an image file.');
                    clearAiImageAttachment();
                    return;
                }
                const reader = new FileReader();
                reader.onload = (loadEvent) => {
                    setAiImageAttachment(loadEvent.target.result, file.name || 'Attached image');
                };
                reader.readAsDataURL(file);
            });
        }

        if (clearAiImageBtn) {
            clearAiImageBtn.addEventListener('click', () => {
                clearAiImageAttachment();
            });
        }

        aiBubble.addEventListener('click', () => { aiModal.style.display = 'flex'; });
        aiCloseBtn.addEventListener('click', () => { aiModal.style.display = 'none'; });
        aiModal.addEventListener('click', (e) => { if (e.target === aiModal) aiModal.style.display = 'none'; });

        aiSendBtn.addEventListener('click', async () => {
            const apiKey = aiApiKeyInput.value.trim();
            const userPrompt = aiPromptInput.value.trim();
            const aiMode = document.querySelector('input[name="aiMode"]:checked')?.value || 'new';
            const hasReferenceImage = !!pastedImageData;
            const strictReplicaRequested = /(exact|exactly|recreate|replicate|same layout|match this|as is)/i.test(userPrompt);
            if (!apiKey) { alert('Please enter your Google AI Studio API key.'); return; }
            if (!userPrompt && !pastedImageData) { alert('Please enter a request or attach an image.'); return; }
            localStorage.setItem('googleAiApiKey', apiKey);

            aiSendBtn.disabled = true;
            aiSendBtnText.style.display = 'none';
            aiLoadingSpinner.style.display = 'inline-flex';
            const activePage = documentPages[currentPageIndex] || { width: DEFAULT_PAGE_WIDTH, height: DEFAULT_PAGE_HEIGHT };
            const availableColumns = headers.length ? headers.join(', ') : 'None';
            const fullPrompt = `
You are generating a Fabric.js 5.3 template JSON for a visual template editor.
Return JSON only, no markdown.

Required output shape:
{
  "page": { "title": "string", "width": number, "height": number },
  "canvas": { "version": "5.3.0", "objects": [], "background": "transparent" },
  "bindings": []
}

Rules:
1) First object in canvas.objects must be a non-selectable page rectangle with oid "pageRect".
2) Keep layout clean: no accidental overlap, clear visual hierarchy, consistent spacing, modern style.
3) Use realistic typography, margins, and alignment; avoid clutter.
4) Every object must have a unique "oid".
5) If user references data fields, add bindings:
   ["object_id", [{"column":"column_name","property":"Text Content|Font Family|Font Size|Fill Color|Opacity|Stroke Color|Stroke Width|Fill|Cell Text","cellIndex":0}]]
6) Supported object types: rect, textbox, line, circle, image, path, group.
7) Keep page size context-aware. Current canvas size: ${activePage.width} x ${activePage.height}. If mode is "modify", keep current page size.
8) Existing data columns available: ${availableColumns}.
9) Prefer practical, production-quality template structure over experimental layouts.
10) For all non-page objects: locked=false, selectable=true, evented=true, and all lockMovement/lockScaling/lockRotation=false.
11) Do not use clipPath or transformMatrix.
12) For SVG/path icons, avoid clipping: use objectCaching=false and avoid negative scaling.
13) Mode: ${aiMode}. If mode is "new", replace current design. If mode is "modify", preserve existing structure and only apply requested changes.
14) If a reference image is attached, use it as the primary source of truth for geometry and content.
15) If asked to recreate exactly or match image: copy text content and line breaks faithfully, match relative spacing, border thickness, table cell structure, alignment, and proportions. Do not shrink the whole composition.
16) For forms/invoices, prefer precise rectangular borders and separate cells instead of merged approximations.

Icon source:
https://mzdhdmfjwdpolrxraqtv.supabase.co/storage/v1/object/public/elements/icons/{lucide-name}.svg

User Request:
${userPrompt}
Reference image attached: ${hasReferenceImage ? 'yes' : 'no'}
Strict replica intent: ${strictReplicaRequested ? 'yes' : 'no'}
`;

            try {
                const parts = [{ text: fullPrompt }];
                if (pastedImageData) {
                    parts.push({
                        inline_data: {
                            mime_type: pastedImageData.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/)[1],
                            data: pastedImageData.split(',')[1]
                        }
                    });
                }
                const response = await fetch(
                    "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent",
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json", "X-goog-api-key": apiKey, },
                        body: JSON.stringify({ contents: [{ parts: parts }] }),
                    }
                );
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${response.status} - ${errorData.error?.message || "Unknown error"}`);
                }
                const data = await response.json();
                let aiResponseText = data.candidates[0].content.parts[0].text;
                aiResponseText = aiResponseText.replace(/^```json\s*|```$/g, "").trim();
                const jsonMatch = aiResponseText.match(/\{[\s\S]*\}/);
                if (!jsonMatch) throw new Error('AI did not return valid JSON.');

                const newCanvasState = JSON.parse(jsonMatch[0]);
                const targetPageIndex = currentPageIndex;
                const existingPage = documentPages[targetPageIndex] || createBlankPageState(targetPageIndex, DEFAULT_PAGE_WIDTH, DEFAULT_PAGE_HEIGHT);
                const nextWidth = aiMode === 'modify'
                    ? parsePositiveInt(existingPage.width, DEFAULT_PAGE_WIDTH)
                    : parsePositiveInt(newCanvasState.page?.width, existingPage.width || DEFAULT_PAGE_WIDTH);
                const nextHeight = aiMode === 'modify'
                    ? parsePositiveInt(existingPage.height, DEFAULT_PAGE_HEIGHT)
                    : parsePositiveInt(newCanvasState.page?.height, existingPage.height || DEFAULT_PAGE_HEIGHT);
                const sanitizedCanvas = sanitizeCanvasStateForEditor(newCanvasState.canvas || newCanvasState, {
                    pageWidth: nextWidth,
                    pageHeight: nextHeight
                });
                const sanitizedBindings = sanitizeBindingsEntries(newCanvasState.bindings || existingPage.bindings || []);
                const aiPageState = normalizePageState({
                    id: existingPage.id,
                    title: existingPage.title,
                    width: nextWidth,
                    height: nextHeight,
                    canvas: sanitizedCanvas,
                    bindings: sanitizedBindings
                }, targetPageIndex);

                if (!documentPages.length) {
                    documentPages = [aiPageState];
                    currentPageIndex = 0;
                } else {
                    documentPages[targetPageIndex] = aiPageState;
                    currentPageIndex = targetPageIndex;
                }

                if (newCanvasState.page?.title) {
                    $('#titleInput').value = newCanvasState.page.title;
                }

                refreshCanvasPageControls();
                await switchToCanvasPage(currentPageIndex, { fitView: true, skipSave: true, suppressHistory: true });
                bindings = new Map(documentPages[currentPageIndex]?.bindings || []);
                if (aiMode === 'new') {
                    historyStack = [];
                    historyIndex = -1;
                    lastHistorySig = null;
                    updateHistoryButtons();
                }
                requestSaveState();
                if (typeof requestSaveState.flush === 'function') requestSaveState.flush();
                aiModal.style.display = "none";
            } catch (error) {
                console.error("AI Assistant Error:", error);
                alert(`An error occurred: ${error.message}`);
            } finally {
                aiSendBtn.disabled = false;
                aiSendBtnText.style.display = 'inline-block';
                aiLoadingSpinner.style.display = 'none';
                clearAiImageAttachment();
            }
        });

        // --- LEFT PANEL TABS & ELEMENTS ---
        function initializeLeftPanelTabs() {
            const tabButtons = document.querySelectorAll('.panel-tab-btn');
            const tabContents = document.querySelectorAll('.panel-tab-content');

            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Deactivate all tabs and content panels
                    tabButtons.forEach(b => b.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));

                    // Activate the clicked tab
                    btn.classList.add('active');

                    // Find and activate the correct content panel using the robust data-target attribute
                    const targetId = btn.dataset.target;
                    const targetContent = document.getElementById(targetId);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    } else {
                        console.error(`Tab content panel with ID "${targetId}" not found.`);
                    }
                });
            });

            const searchInput = $('#element-search');
            if (searchInput) {
                const debouncedSearch = debounce(searchElements, 300);
                searchInput.addEventListener('input', () => debouncedSearch(searchInput.value));
            }

            // Initial load of elements
            searchElements('');
        }
        let currentPage = 0;
        let isLoading = false; // Prevents fetching multiple pages at once
        let currentQuery = ''; // Tracks the active search query

        const ELEMENTS_PER_PAGE = 50;

        /**
         * A helper function to shuffle an array in place using the Fisher-Yates algorithm.
         * @param {Array} array The array to be shuffled.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
        }

        /**
         * Fetches and displays elements from Supabase with infinite scroll and randomization.
         * @param {string} query The search query.
         * @param {boolean} isNewSearch If true, resets pagination and clears the grid.
         */
        async function searchElements(query, isNewSearch = true) {
            if (!supabase || isLoading) return;

            const grid = document.getElementById('elements-grid');
            if (!grid) return;

            // --- Reset for a new search ---
            if (isNewSearch) {
                currentQuery = query;
                currentPage = 0;
                grid.innerHTML = '';
                // Clean up any existing IntersectionObserver
                if (grid.observer) {
                    grid.observer.disconnect();
                }
            }

            isLoading = true;

            // --- Loading Indicator ---
            const loadingIndicator = document.createElement('p');
            loadingIndicator.className = 'muted';
            loadingIndicator.textContent = 'Loading...';
            grid.appendChild(loadingIndicator);

            // --- Supabase Query with Pagination ---
            const from = currentPage * ELEMENTS_PER_PAGE;
            const to = from + ELEMENTS_PER_PAGE - 1;

            let queryBuilder = supabase.from('elements').select('id, name, image_url, tags');
            if (currentQuery) {
                queryBuilder = queryBuilder.or(`name.ilike.%${currentQuery}%,tags.cs.{${currentQuery}}`);
            }

            // Fetch in a consistent order (e.g., by ID) for stable pagination results.
            const { data, error } = await queryBuilder.order('id').range(from, to);

            // Always remove the loading indicator after the fetch attempt.
            grid.removeChild(loadingIndicator);
            isLoading = false;

            if (error) {
                console.error('Element search error:', error);
                grid.innerHTML = '<p class="muted">Error loading elements.</p>';
                return;
            }

            // Handle no results
            if (!data || data.length === 0) {
                if (isNewSearch) {
                    grid.innerHTML = '<p class="muted">No elements found.</p>';
                }
                // Stop here; no more data to load.
                return;
            }

            // --- RANDOMIZE THE BATCH ---
            shuffleArray(data);

            // --- Element Rendering Loop ---
            for (const el of data) {
                const chip = document.createElement('div');
                chip.className = 'element-chip';
                chip.draggable = true;

                const img = document.createElement('img');
                img.alt = el.name;
                img.loading = 'lazy'; // Defer loading off-screen images

                const isSvg = el.image_url.toLowerCase().endsWith('.svg');
                const imageUrlWithCacheBust = `${el.image_url}?t=${Date.now()}`;

                // Asynchronously load the image to avoid blocking the loop
                (async () => {
                    try {
                        if (isSvg) {
                            const response = await fetch(imageUrlWithCacheBust);
                            const blob = await response.blob();
                            const svgBlob = blob.type === 'image/svg+xml' ?
                                blob :
                                new Blob([await blob.text()], { type: 'image/svg+xml' });
                            img.src = URL.createObjectURL(svgBlob);
                        } else {
                            img.src = imageUrlWithCacheBust;
                        }
                    } catch (err) {
                        console.error(`Failed to load image for ${el.name}:`, err);
                        chip.innerHTML = `<span class="muted" style="font-size: 10px; text-align: center;">Load Error</span>`;
                        chip.draggable = false;
                    }
                })();

                img.onerror = () => {
                    chip.innerHTML = `<span class="muted" style="font-size: 10px; text-align: center;">Load Error</span>`;
                    chip.title = `Error loading: ${el.name}`;
                    chip.draggable = false;
                };

                chip.appendChild(img);

                // --- Drag Support (Handles all image types) ---
                chip.addEventListener('dragend', e => {
                    if (!(img.complete && img.naturalHeight !== 0)) return;

                    // Get mouse position relative to the canvas
                    const canvasRect = canvas.upperCanvasEl.getBoundingClientRect();
                    const mouseX = e.clientX - canvasRect.left;
                    const mouseY = e.clientY - canvasRect.top;

                    // Convert to Fabric coordinates considering zoom/pan
                    const pointer = canvas.getPointer({ clientX: e.clientX, clientY: e.clientY });

                    if (isSvg) {
                        adders.svg(pointer.x, pointer.y, img.src, { oid: el.id });
                    } else {
                        adders.image(pointer.x, pointer.y, img.src, { oid: el.id });
                    }
                });

                // --- Click Support ---
                chip.addEventListener('click', () => {
                    if (img.complete && img.naturalHeight !== 0) {
                        const { x, y } = canvas.getVpCenter();
                        // Logic correctly distinguishes between SVG and raster images
                        if (isSvg) {
                            adders.svg(x, y, img.src, { oid: el.id }); // img.src is the blob URL here
                        } else {
                            adders.image(x, y, img.src, { oid: el.id });
                        }
                    }
                });

                grid.appendChild(chip);
            }

            // Prepare for the next page
            currentPage++;

            // --- Intersection Observer Setup ---
            // If we loaded a full page, there might be more results.
            // Set up the observer on the last element to trigger loading the next page.
            if (data.length === ELEMENTS_PER_PAGE) {
                const lastElement = grid.lastElementChild;
                if (lastElement) {
                    const observer = new IntersectionObserver((entries) => {
                        if (entries[0].isIntersecting) {
                            observer.disconnect(); // Important: Stop observing the current last element
                            // Load the next page for the same query
                            searchElements(currentQuery, false);
                        }
                    }, { threshold: 0.5 }); // Trigger when 50% of the element is visible

                    observer.observe(lastElement);
                    grid.observer = observer; // Store for cleanup
                }
            }
        }

        // --- INTERACTIVE TOUR ---
        const tourModal = $('#tour-modal'); const tourHighlight = $('#tour-highlight'); let currentTourStep = 0; const tourSteps = [{ title: "How to Structure Your Data", content: `<p>Before importing, make sure your data is structured correctly in a .csv or .xlsx file.</p><img src="assets/images/data-structure-example.png" alt="Example data structure" style="max-width:100%; margin-bottom:1rem;" /><ul><li>Column names should start in cell <b>A1</b>.</li><li>Each new row will be treated as a different file or page.</li></ul>`, element: null }, { title: "How to Import Your Data", content: `<p>Press the <b>Load Data</b> button to open the file picker.</p><p>Valid formats are <b>.xlsx</b> and <b>.csv</b>.</p>`, element: 'label[for="csvInput"]' }, { title: "How to Generate with AI", content: `<p>Press the AI bubble to open the assistant.`, element: '#ai-bubble', action: () => { $('#dataLinksManagerModal').style.display = 'none'; $('#aiModalBackdrop').style.display = 'none' } }, { title: "How to Generate with AI", content: `You will need a <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio API key</a>.</p><ul><li>Login to you Google Account.</li><li>Click on "+ Create API Key"</li><li>Copy the key and paste it here</li> </ul>`, element: '#aiApiKey', action: () => { $('#dataLinksManagerModal').style.display = 'none'; $('#aiModalBackdrop').style.display = 'flex' } }, { title: "How to Generate with AI", content: `Now, enter your request in the prompt box and press "Send Request".</p><p><b>Tips:</b></p><ul><li>You can paste an image into the prompt to help with your idea.</li><li>Specify your column names in the prompt and the AI will try to link them automatically.</li></ul>`, element: '#aiPrompt', action: () => { $('#dataLinksManagerModal').style.display = 'none'; $('#aiModalBackdrop').style.display = 'flex' } }, { title: "How to Link Your Data", content: `<p>First, make sure you have imported your data.</p><p>Press <b>Data Links</b> to open the manager.</p>`, element: '#openDataLinksManagerBtn', action: () => { $('#aiModalBackdrop').style.display = 'none'; $('#dataLinksManagerModal').style.display = 'none'; } }, { title: "How to Link Your Data", content: `<p>From there, you can select an object, choose a column from your data, and link it to a property like 'Text Content' or 'Color'.</p>`, element: '.objects-list-container', action: () => { $('#aiModalBackdrop').style.display = 'none'; $('#dataLinksManagerModal').style.display = 'flex'; } }, { title: "Tour Complete!", content: `<p>You now know the basics! Start creating your templates.</p>`, element: null, action: () => { $('#dataLinksManagerModal').style.display = 'none'; } }];
        function startTour() { currentTourStep = 0; tourModal.style.display = 'flex'; goToStep(currentTourStep); } function endTour() { tourModal.style.display = 'none'; tourHighlight.style.display = 'none'; localStorage.setItem('hasSeenTour', 'true'); }
        function goToStep(stepIndex) {
            const step = tourSteps[stepIndex];
            if (!step) {
                endTour();
                return;
            }

            // Execute the action first to ensure the element is visible
            if (step.action) {
                step.action();
            }

            if (!step.action) {
                document.querySelectorAll('.modal-backdrop').forEach(m => m.style.display = 'none');
            }

            $('#tour-modal-title').textContent = step.title;
            $('#tour-modal-content').innerHTML = step.content;
            $('#tour-step-counter').textContent = `${stepIndex + 1} / ${tourSteps.length}`;
            $('#tour-prev-btn').disabled = stepIndex === 0;
            $('#tour-next-btn').style.display = stepIndex === tourSteps.length - 1 ? 'none' : 'inline-flex';
            $('#tour-finish-btn').style.display = stepIndex === tourSteps.length - 1 ? 'inline-flex' : 'none';

            const targetEl = step.element ? $(step.element) : null;
            if (targetEl) {
                // Now getBoundingClientRect will have the correct dimensions
                const rect = targetEl.getBoundingClientRect();
                tourHighlight.style.display = 'block';
                tourHighlight.style.width = `${rect.width + 10}px`;
                tourHighlight.style.height = `${rect.height + 10}px`;
                tourHighlight.style.top = `${rect.top - 5}px`;
                tourHighlight.style.left = `${rect.left - 5}px`;

                const modalRect = tourModal.getBoundingClientRect();
                let modalTop = rect.top + 30,
                    modalLeft = rect.right + modalRect.width;

                if (modalLeft + modalRect.width > window.innerWidth) {
                    modalLeft = rect.left - modalRect.width + 100;
                }
                if (modalTop + modalRect.height > window.innerHeight) {
                    modalTop = window.innerHeight - modalRect.height - 30;
                }

                modalTop = Math.max(15, modalTop);
                modalLeft = Math.max(15, modalLeft);

                tourModal.style.top = `${modalTop}px`;
                tourModal.style.left = `${modalLeft}px`;
            } else {
                tourHighlight.style.display = 'none';
                tourModal.style.top = '50%';
                tourModal.style.left = '50%';
                tourModal.style.transform = 'translate(-50%, -50%)';
            }
        }
        on('#start-tour-btn', 'click', startTour); on('#tour-close-btn', 'click', endTour); on('#tour-finish-btn', 'click', endTour); on('#tour-next-btn', 'click', () => { currentTourStep++; goToStep(currentTourStep); }); on('#tour-prev-btn', 'click', () => { currentTourStep--; goToStep(currentTourStep); });

        // 5. Enhanced Template Loader
        const templateLoaderModal = $('#template-loader-modal');
        async function toggleTemplateLoader(button) {
            if (templateLoaderModal.style.display === 'block') {
                templateLoaderModal.style.display = 'none';
                return;
            }
            const rect = button.getBoundingClientRect();
            const maxW = 420;
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            let left = rect.left;
            let top = rect.bottom + 8;
            if (left + maxW > vw - 12) left = Math.max(12, vw - maxW - 12);
            if (top > vh - 120) top = Math.max(12, rect.top - 8);
            templateLoaderModal.style.top = `${top}px`;
            templateLoaderModal.style.left = `${left}px`;
            templateLoaderModal.style.display = 'block';
            templateLoaderModal.innerHTML = '<p class="muted" style="padding: 24px; text-align: center;">Loading templates...</p>';

            const [publicTemplates, purchasedTemplates, myTemplates] = await Promise.all([
                supabase.from('public_templates').select('id, title, template_data'),
                currentUser ? supabase.from('purchased_templates').select('store_templates(id, title, template_data)').eq('user_id', currentUser.id) : Promise.resolve({ data: [] }),
                currentUser ? supabase.from('templates').select('id, title, template_data').eq('user_id', currentUser.id).order('created_at', { ascending: false }) : Promise.resolve({ data: [] })
            ]);

            templateLoaderModal.innerHTML = `
        <div class="template-modal-tabs">
            <button class="template-modal-tab active" data-tab="public">Public</button>
            <button class="template-modal-tab" data-tab="mine">My Templates</button>
            <button class="template-modal-tab" data-tab="purchased">Library</button>
        </div>
        <div id="public-templates" class="template-grid"></div>
        <div id="my-templates" class="template-grid" style="display:none;"></div>
        <div id="purchased-templates" class="template-grid" style="display:none;"></div>
        <div style="padding: 12px; border-top: 1px solid var(--border); background: var(--panel-2); display: flex; gap: 8px;">
            <button id="loadJsonBtn" class="btn ghost" style="flex: 1; font-size: 11px;">Upload JSON</button>
        </div>
        <input type="file" id="jsonUpload" accept=".json" style="display:none;">
    `;

            const publicGrid = $('#public-templates');
            publicGrid.innerHTML = '';
            (publicTemplates.data || []).forEach(t => publicGrid.appendChild(createTemplateItem(t, true)));

            const myGrid = $('#my-templates');
            myGrid.innerHTML = '';
            if (myTemplates.data && myTemplates.data.length > 0) {
                myTemplates.data.forEach(t => myGrid.appendChild(createTemplateItem(t, false)));
            } else {
                myGrid.innerHTML = `<div style="grid-column: 1 / -1; padding: 32px 16px; text-align: center;">
            <p class="muted" style="font-size: 12px; margin-bottom: 12px;">You haven't saved any templates yet.</p>
            <button onclick="templateLoaderModal.style.display='none'" class="btn primary" style="height: 28px; font-size: 11px;">Start Creating</button>
        </div>`;
            }

            const purchasedGrid = $('#purchased-templates');
            purchasedGrid.innerHTML = '';
            if (purchasedTemplates.data && purchasedTemplates.data.length > 0) {
                purchasedTemplates.data.forEach(t => purchasedGrid.appendChild(createTemplateItem(t.store_templates, false, true)));
            } else {
                purchasedGrid.innerHTML = '<p class="muted" style="font-size: 12px; text-align: center; grid-column: 1 / -1; padding: 32px 16px;">No purchased templates found.</p>';
            }

            document.querySelectorAll('.template-modal-tab').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.template-modal-tab').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    publicGrid.style.display = btn.dataset.tab === 'public' ? 'grid' : 'none';
                    myGrid.style.display = btn.dataset.tab === 'mine' ? 'grid' : 'none';
                    purchasedGrid.style.display = btn.dataset.tab === 'purchased' ? 'grid' : 'none';
                });
            });

            on('#loadJsonBtn', 'click', () => $('#jsonUpload').click());
        }

        function createTemplateItem(template, isPublic, isPurchased = false) {
            const item = document.createElement('div');
            item.className = 'template-item';

            const thumb = document.createElement('div');
            thumb.className = 'template-thumb';
            thumb.style.backgroundColor = '#111';
            thumb.innerHTML = '<div style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; opacity:0.1;"><svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg></div>';

            const title = document.createElement('div');
            title.className = 'template-title';
            title.textContent = template.title || 'Untitled Template';

            item.append(thumb, title);

            // Lightweight preview generation
            setTimeout(() => {
                try {
                    const data = template.template_data;
                    const previewCanvas = data?.canvas || data?.pages?.[0]?.canvas;
                    if (previewCanvas) {
                        const off = document.createElement('canvas');
                        off.width = 320;
                        off.height = 240;
                        const c2 = new fabric.StaticCanvas(off); // Use StaticCanvas for better performance
                        c2.loadFromJSON(previewCanvas, () => {
                            const pr = c2.getObjects().find(o => o.oid === 'pageRect');
                            if (pr) {
                                pr.set({ strokeWidth: 0, shadow: null });
                                const zoom = Math.min(off.width / pr.width, off.height / pr.height) * 0.95;
                                c2.setZoom(zoom);
                                c2.viewportTransform[4] = (off.width - pr.width * zoom) / 2;
                                c2.viewportTransform[5] = (off.height - pr.height * zoom) / 2;
                            }
                            c2.renderAll();
                            const dataUrl = off.toDataURL('image/jpeg', 0.8);
                            thumb.innerHTML = ''; // Clear placeholder
                            thumb.style.backgroundImage = `url(${dataUrl})`;
                            c2.dispose();
                        });
                    }
                } catch (e) {
                    console.error('Preview failed:', e);
                }
            }, 50);

            item.onclick = () => {
                loadTemplateFromDB(template.id, { public: isPublic, purchased: isPurchased });
                templateLoaderModal.style.display = 'none';
            };
            return item;
        }

        on('#jsonUpload', 'change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const json = JSON.parse(event.target.result);
                    if (json && (json.pages || json.canvas || json.page || json.bindings)) {
                        if (json.page?.title) $('#titleInput').value = json.page.title;
                        if (json.data) {
                            headers = json.data.headers || [];
                            dataRows = json.data.rows || [];
                        }
                        await setDocumentPagesFromTemplate(json, { fitView: true, selectedIndex: json.currentPageIndex });
                        bindings = new Map(documentPages[currentPageIndex]?.bindings || json.bindings || []);
                    } else if (json && json.objects) {
                        await setDocumentPagesFromTemplate({
                            page: {
                                title: $('#titleInput').value || 'Untitled_Template',
                                width: parsePositiveInt($('#pageWidth').value, DEFAULT_PAGE_WIDTH),
                                height: parsePositiveInt($('#pageHeight').value, DEFAULT_PAGE_HEIGHT)
                            },
                            canvas: json,
                            bindings: []
                        }, { fitView: true });
                    } else {
                        throw new Error('Unsupported JSON format.');
                    }

                    historyStack = [];
                    historyIndex = -1;
                    lastHistorySig = null;
                    requestSaveState();
                    templateLoaderModal.style.display = 'none';
                } catch (err) {
                    alert('Invalid JSON file.');
                }
            };
            reader.readAsText(file);
            e.target.value = ''; // Reset input
        });

        window.addEventListener('click', (e) => {
            if (!templateLoaderModal.contains(e.target) &&
                !e.target.closest('#loadTemplateBtnPage') &&
                !e.target.closest('#openLoaderFromSidebar') &&
                !e.target.closest('#toolbarLoadTemplateBtn')) {
                templateLoaderModal.style.display = 'none';
            }
        });

        // --- INITIALIZE ---
        window.addEventListener('DOMContentLoaded', initializeEditor);

    </script>
    <script type="module" src="tools/tool.js?v=20260219k"></script>

    <!-- Grouped Data By Modal -->
    <div id="identifierColumnModal" class="modal-backdrop" style="z-index: 10001;">
